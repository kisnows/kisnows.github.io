<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[泰国懒人游]]></title>
    <url>%2F2018%2F06%2F09%2Fthailand-travel-notes%2F</url>
    <content type="text"><![CDATA[泰国落地签我是飞到曼谷素万那普机场，下机后跟着人流直走，头上有指示牌，可以一路走到办理落地签的地方。办理落地签有两个通道，一个普通通道，一个快速通道。快速通道 2200🐖，普通通道 2000🐖。建议走快速通道，能省很多时间。 机场大巴从扶梯下来，好像是到一楼，然后会看到大巴售票点。 然后会看到大巴售票点，就长下图这个样子，有到芭堤雅和华欣的大巴，大概每小时一班车。然后面向大巴售票点左手边有吃饭的地方，在这个位置。 里面东西很便宜，进去要换票，一个人的话100🐖就够了。能吃很多东西，我当时吃了一碗面，一罐可乐，还剩了 15🐖。 曼谷 -&gt; 芭堤雅在大巴售票点买好票，售票员说 1.30 发车，我问了下在哪里，他指了个地方，说到 1.30 会有人领你们过去。从曼谷到芭堤雅大概两个小时的样，在芭堤雅有好几个下车点，分别是 North Pattaya Road（芭提雅北路）和 Central Pattaya Road（芭提雅中路）、South Pattaya Road（芭提雅南路）、 Thepprasit Road 和 Thappraya Road。下车点其实挺多的，特别是 Pattaya Road 的北、中、南路（都靠近海边的Beach Road），就是芭提雅的中心地带了，在这三个地点下车都很方便。我当时在 Central Pattaya Road（芭提雅中路）下车，然后就有一个摩的师傅上来拉活。我问了下价格，他说 one two zero ，我一开始半天没理解他们说什么，以为是 ‘three hundred’ 300 🐖。就拿出计算器按数字给他们看，他说不是，按了个 120 上去，我一想也行，就上车了。女生的话不怎么建议座这个，总感觉不是很安全的样子。 芭堤雅摩的直接把我载到了酒店，给钱的时候发生了一件很有意思的事情。我拿出一张 50 和 20 给他，我以为那张 50 是 100. 然后师傅一直在说什么我听不懂的语言，我还以为要坑我。两人瞎扯了半天，我才发现我给的钱不对，赶紧补上了 100 。进酒店办理入住，放下东西就先睡了一觉，哈哈。 一觉睡到了五点多，给饿醒了。就出去觅食，附近随便找了找，吃的东西还是很多的，也不是很贵，下面这个 200 🐖。 吃完出去到海边走了走，就回去了。 交通芭堤雅海边的交通还是很方便的，直接座双条车就好了，但是都是单行。南北走向， 1st rd 南行，2nd rd北行，双条招手即停，只要不问司机目的地和加钱，默认 10🐖，看好下车点按铃下车，先下车再付费。如果问了司机能不能去哪里，默认为包车价，但是要记得砍价。 趣事在芭堤雅的第二天就海边瞎逛了一天，中午在大众点评上定了个西餐，就从酒店出发去餐厅了。 里面的服务员都很礼貌，我上去说操着蹩脚的英语 I have a preorder ,结果他们没听懂。正当我打算打开翻译看看我提前预定了这句话怎么说时，一位服务员拿了一打订单过来问我叫什么名字，我说 ab 他们疑惑了一下 指着 ba 问是不是我，哈哈，我都忘了要先名后姓。然后就发生了很有意思的事情，他们端上来了一个很大的汉堡，就像图里这样：我一看这么大，犹豫了半天不知道怎么吃，然后就做出了很可笑的事情。叫来服务员，问了一句：”How to eat it?”女服务员姐姐直接笑了，然后跟我说用刀叉切，我傻逼的就去拿刀叉切了。刚切了一块，经理过来说你想怎么吃就怎么么吃，it’s up to you. 然后我就直接上手了。我都服了我，怎么能问出怎么吃这种问题，哈哈。 中途进来了几个跟团游的国人，我还帮他们当了下翻译，就我这蹩脚的英语，哈哈。不过不得不说，国人确实一进来大吵大闹的，感觉很不好，可能是因为都是大爷大妈，平时都习惯了的原因吧。 吃完逛了一圈，去商场买了条腰带，顺便帮一个网友到了她要的面膜。就回酒店休整了。 人下午去海边散步，认识了两个国内来的妹子，聊的很开心。 晚上打算去吃饭，被妹子拉着去步行街（红灯区）逛了一圈，红灯区里一看你是中国人，就会有很多人拿着不堪入目的牌子上来问你，说看不看什么表演之类的。不要去理就好了，就算你真抱着猎奇的心理去看，也不建议跟着这些推销的人去，很容易被宰。 不过吃饭的时候遇到了一点不愉快，我们大老远从芭堤雅市区走了好久然后打车才到那个店打算吃海鲜。结果我们一进去人家说了什么一堆乱七八糟的英语，我们三个人没一个人听懂，然后说我们找错地方了，带我们出去给我指路说在那边。然而在她手指的方向根本什么都没有，看起来应该是被餐厅莫名其妙的拒绝接待了。就下图这个餐厅： Maggic Restaurant, 最后只能打车回市区吃饭。吃完饭就跟妹子分道扬镳了。 可兰岛第三天报了个可兰岛一日游，玩的很嗨，全程有人接送，不用操什么心，哈哈。什么滑翔伞、海底漫步、浮潜乱七八糟的加起来才不到四百块，简直太便宜了。玩的也很舒服，就是师傅游艇开的很快，晕船的人要提前备好晕船药，看到船上有人晕的不行。这中间又认识了一个妹子，太强了，一个人出来玩，还玩了跳伞。佩服的不行，我本来也想玩的，可最后还是怂了，一是真的贵 3000 大洋，而是三千米跳下来还是很可怕的，我承认我一个人有点怂，哈哈。 芭堤雅 -&gt; 曼谷第四天早上就从芭堤雅往曼谷走，还是做大巴。酒店前台帮忙找了个摩的师傅把我拉过去，80🐖。进站买票后，就在候车室等候，车票上会写发车时间和座位号，按照要求走就行了。 又是两个小时，到了车站下来，我就去找 bts ，跟着地图走就行，下图这个就是 ekkamai 站入口。进去后买票等车，买票的话可以选择自动售卖机，但是只收硬币。也可以选择人工窗口，给纸币然后说要去那个站点就好了。候车的时候问了个泰妹，我要去的站是从那边做，因为怕做错。泰妹跟我说就这里，然而上车后还是怕做错站，就盯着这个指示和到站语音提醒看我做的方向对不对，还好是对的，果然漂亮的小姐姐不会骗人。因为住在老城区，bts 不直达，到站后打了个的士才到酒店，座的士去酒店的路上中间还发生了一点小插曲。提醒一下，打的的话要注意，一定让他打表 ‘by meter’ ，如果他不打表，那么要提前讲好价，否则容易被宰。或者选择用 Grab 这个打车软件，后来几天我就是用这个的，很方便，不过一定要看准定位，毕竟你们语言不通，司机就是打电话找你你也不知道对方在说什么。 曼谷到酒店收拾了一下，就去跟在芭堤雅新认识的一个也来了曼谷的朋友汇合。在暹罗广场吃了个饭，瞎逛了一会。商场里面竟是豪车，然而可能这辈子都买不起了，悲伤啊。 晚上和之前约好的一个妹子去考山路逛了一圈，真的是纯逛了一圈，都没有坐下来喝点东西感受一下气氛。 水上市场第二天报了一个水上市场一日游，全程有人接送，懒懒散散的逛了一圈，挺适合我，不用赶时间。里面可以买些小物件，挺好的。 虽然行程懒散，但时间还是挺长的，晚上看完萤火虫已经八点多了，回酒店休整了一下，然后在附近按了下脚就回酒店睡觉了。 市区第三天在泰国市区逛了一圈，有个地方好多日本人，店里面的点单也都是日文加泰文，可能附近很多日本人定居在这里吧。 晚上从 phone 逛完，本来打算座 bts 然后再打车回去的，路上却碰到了一排摩的师傅，就上去问了下去考山路多少钱。一个师傅说200，我说太贵，150行不行，他说不行，至少170，我也懒得坎价了，就打算跟他走了。结果有意思的是，不是跟我讲价师傅载我，而是另一个人载我，我还纳闷着呢，结果在我的师傅说我们两个一起送我过去，我一脸懵逼，我这么牛逼吗。然后带上头盔就上了车。那个跟我讲价的师傅就先走了，在我的师傅跟在后面。坐摩的感觉真的是很危险，穿梭在各种车与车之间，好几次我都害怕说这他妈撞了怎么办。庆幸自己戴头盔是一个非常正确的选择。路上还看到了一个bmw的摩托出了车祸，被一辆小轿车撞了，还好人都没事，带了头盔。 到了一个红灯前，跟我讲价的师傅和在我的师傅在那用泰语说什么，看起来像指路的样子。 然后讲价的师傅跟我说， I am teacher , I teach him. 才知道，原来他们是兄弟，弟弟第一次出来开摩的，我坐的就是弟弟骑的，哥哥跟我说我坐的这个是刚新买的摩托。我一看，还真是，本田的踏板摩托。 曼谷这边基本都是本田丰田，无论轿车或者摩托，目测百分之八十以上都是这两个日本品牌。轿车里面看到了好多思域，别说，还真帅。红灯完了，一群摩的 嗡 的就都冲出去了。那个新司机师傅一直在跟我说什么，然而我一句没听懂，都不知道他说的是泰语还是英语。 射击第四天去附近陆军练习场玩了下射击，真的很爽，那手枪后坐力，bong~ bong~ bong~ 的。玩完那个军官跟我说想不想玩长枪，当然想啊，毕竟淘宝上只有手枪的套餐。不过，50发 M4A1 3200🐖，相当于一发子弹十几块人民币，还是挺贵的，不过想想来都来了，玩！遂打算刷卡，结果人家只收现金，而我只有可怜的 500🐖，无奈就只能回去了。 谁知出门走出去200米就下起了暴雨，我竟然没带伞，尴尬。在路边蹲了一个小时等雨停，雨停了赶紧跑了回去，果然以后出门得看天气预报啊。 交通说说曼谷的交通吧，这边摩的很多，也很方便，因为曼谷的交通非常堵，如果打的的话经常被堵在路上好久，但是座摩的就不一样，很多路都可以走。 不过女生一个人玩的话，不是很推荐座摩的，不怎么安全。如果一定要做摩的记得认准这个小马甲，这种是正规的，每个人身后都写着名字和代号，晚上座摩的的话，可以拍照发家人以免万一。上车一定要带头盔，因为路上看到了有人出了交通事故，要是不带头盔还是很危险的。价格方面，摩的跟打的价格差不多，上车前一定要问价格，一定要砍价,价格水分还是很大的。 最后第五天早上就用 Grab 打了个车去机场回国了。 整体下来 9 天 8 晚的样子，花了大概 1.2W. 主要都花在酒店和机票上了，因为一个人出来玩，所以酒店都定的比较好，毕竟安全第一。整体上玩的还是很开心的，人都很亲切，毕竟微笑国度。而且也挺便宜，在那边花钱我也没有什么概念，基本就是大手大脚的花了，比国内便宜多了。 回国就要继续搬砖了，哈哈。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017年终总结]]></title>
    <url>%2F2018%2F03%2F28%2F2017-year-end-summary%2F</url>
    <content type="text"><![CDATA[工作年初，公司经历大的变动，整个理财业务线都干掉了，一大批人转岗的转岗、离职的离职。前端技术部这里，人也走了几个，六楼本来 5 个前端，最后只剩下了 3 个。原来的项目也都不做了，开始做的新的项目网易白条。风风火火做了将近一年，现在产品的数字还比较好看，年后就会上公开申请制对外正式开放，前景还是不错的。 只是，现在楼上两个前端年后又要走一个人，流动性那么大，没有一点归属感。加上阿里很多部门给我打电话让我过去面试，想想网易不怎么高的工资，有时候都有点动心，但还是一一拒绝了。起码在网易待满三年，好好沉淀一下。也磨练一下自己的性子，否则天天换工作，也不利于长久的职业发展。只是最近新上的区块链项目，虽然我没参与，但能让我感觉整个部门非常的浮躁，又在犹豫呆下去是否是正确的。 生活今年整体上还是过的像一碗白开水，中间偶有放点糖，但很快也就没有味道。 身体上已经明显能感觉到开始横向发展了，体重上了五六公斤，但是身体素质却下降了，引体向上只能做一个，我的天呐，大学的时候好歹也能轻松做十个的，这衰减的也太快了。说要锻炼身体，然而基本上只停留在嘴上，锻炼一次中间能间隔一个月，哈哈。 有时候觉得无聊，就想给自己培养个爱好，想来想去最后决定学个口琴，投入小，见效快。然后就买琴网上找教程，刚开始的几个月，还比较上心，基本天天练习，到现在不复杂的曲子都可以吹，而且自我感觉还不错。就是因为学的是布鲁斯口琴，低音的 6 需要压音，到现在也不能很好的压出好听的声音，更别提融入到曲子中去了，还需要继续练习啊。现在最喜欢的吹的曲子有两个，一个是 《alone》 一个是 《you are my sunshine》，心情不好的时候就自己吹给自己听。 日本旅游11 月左右，公司组织我们出国旅游，有三个地方可选：日本、塞班岛、澳洲。最后我选了日本，也是第一次出国，还是很开心。 去了北海道，日本的大农村，第一天入住的小镇下午五点大街上就一个人都没有了，跟同事出逛了一圈最后发现酒店附近的居酒屋七点以后开门。一群人进去想去感受日本当地的居酒屋文化，只是老板就一个人，而且跟我们语言不通，完全照顾不过来，看起来有点不是很开心的样子，不过我们喝的倒是很开心。 第二天去的第一个景点就是个动物园，这也是我第一次去动物园，看到了企鹅、狼、海豹、河马、长颈鹿，就是出来的时候差点掉队找不到组织。 后来又去了北海道厅、洞爷湖、熊厂、地狱谷、当天晚上入住的洞爷湖酒店环境真好。 中间还去了哪都忘了，最后落脚在札幌市区，然后第二天自由活动。白天逛街买东西，几个大商场同事们都买了好多东西，都是土豪啊，哈哈。 期间有件很意思的事情，我想买个 SONY 1000x ，结果和售货员就这个耳机的输入电压是多少沟通了好久，用各种翻译软件都不行，说英语不行、说汉语也不行。最后还是找了个湾湾过来，才成功的解决了输入电压的问题，人家是 usb 充电的，不牵扯 110v 还是 220v，然后才成功买到了耳机。 晚上和同事一起点了个 2w 日元的帝王蟹，看起来很不错，只是实在不怎么好吃。后来还上了电视塔，看了看札幌全貌。 整个日本一周游，也就到这结束了，玩的很开心。 换房子年末，房子到期。房东要把房租从 5000 涨到 6500 ，我的天呐，30% 的涨幅，去年我年度绩效是 A 也就 10% 的工资涨幅。这一看，住不下去了。就和几个合租的室友商量了一下，不租了。 好吧，又是 TMD 的换房子，真 TM 烦。 由于时间比较紧急，只有两个周末时间。所以看的房子也不多，一开始想的说找个好一点的小区，不住这些吹拉弹唱的回迁房了。然后看了几个高端小区的房子，结果大多都是隔断，而且价格还很坑爹。没办法，就继续在园小区附近找。房源不是很多，我们周末两天就去各个小区门口贴的小广告上找房子，最后的周末看了三个房子。两个都在路边，太吵，但其他环境还行。一个不靠路，但是在一楼，看房的时候挺安静的。当时就选了这个一楼的看起来挺安静的房子，然而这一切都是噩梦的开始啊。 搬进去睡的第一天，早上我突然听到一个陌生的声音在我耳边说话，我还以为房间来了什么人，吓了一跳。睁眼一看，一个人都没有，但说话的声音还在持续。拉开帘子一看窗外，我靠，小区起的早的人在楼下聊天，由于住在一楼，而且房子的单层玻璃隔音效果非常差，那声音就跟在我跟前说话差不多。当时都有点崩溃了，看来懒觉以后都睡不了了。而且，最近三月份左右，房间很潮，每天晚上躺床上的时候都能感觉到褥子潮潮的，睡着非常不舒服。这几天就找了个除湿器放房间里面除潮。新租的的房子搬进来也差不多两个月了，得出的结论就是，一楼的房子真心不适合居住啊。 感情反正很曲折就是了，懒得说。 去年的目标 每个月至少一篇博客 每个月都要出去走走，哪怕一个人 书还是要看的，那就三个月一本书吧 身体还是要锻炼的，心里有这个事情就行 写一个个人项目，并发布出来，无论项目多水 去年的目标也就完成了 50% 的样子，1 没完成、2 完成了、3 完成了、4 只能算偶尔会想起来、 5 写了个自动交易程序，确实够水，不过也算完成了。总体执行力实在是有点差，指定的计划基本很难执行。 这工作也快四年了，已经没有太大的心劲了，总觉得缺乏动力。所以今年就一个目标，给自己找点动力，具体下来，那就是找个女朋友，结束单身狗的生活。 PS： 一个年终总结拖了几个月， 2018 都过去 1/3 才勉强凑出来，实在是烦心的事情太多了，总之就这样吧。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>年终总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[indexedDB 不完全指南]]></title>
    <url>%2F2017%2F12%2F06%2Fstep-into-indexdb%2F</url>
    <content type="text"><![CDATA[介绍引用 MDN 的介绍： IndexedDB 是一个事务型数据库系统，类似于基于 SQL 的 RDBMS。 然而不同的是它使用固定列表，IndexedDB是一个基于JavaScript的面向对象的数据库。 IndexedDB允许您存储和检索用键索引的对象; 可以存储structured clone algorithm支持的任何对象。 您只需要指定数据库模式，打开与数据库的连接，然后检索和更新一系列事务中的数据。 IndexedDB 是一种低级API，用于客户端存储大量结构化数据(包括, 文件/ blobs)。该API使用索引来实现对该数据的高性能搜索。虽然 Web Storage 对于存储较少量的数据很有用，但对于存储更大量的结构化数据来说，这种方法不太有用。IndexedDB 提供了一个解决方案。 区别这是我整理的 WebStorage 和 indexedDB 的之间区别，有问题的地方还请指出。 用法1. 打开数据库 const DB_NAME = 'Netease'const DB_VERSION = 1const OB_NAMES = &#123; UseKeyPath: 'UseKeyPath', UseKeyGenerator: 'UseKeyGenerator'&#125;/** * NOTE: * 1. 第一次打开可能会提示用户获取 indexedDB 的权限 * 2. 浏览器隐身模式不会存在本地，只会存储在内存中 */const request = window.indexedDB.open(DB_NAME, DB_VERSION) indexedDB.open 接收两个参数，分别为数据库名称和版本，返回的是一个 IDBOpenDBRequest 对象。可以以 DOM 事件的方式监听它的 success 和 error 来获取到它的结果。几乎所有对 indexedDB 的异步操作都是这种以事件的方式进行，返回一个拥有结果或错误的 IDBRequest 对象。在这里，open 方法得到的结果是一个 IDBDatabase 的实例。 第二个参数是数据库的版本。版本决定了数据库的模式：存储在里面的 object store 和它们的结构。当第一次通过 open 方法打开数据库时，会触发一个 onupgradeneeded 事件，我们可以也只能在这里设置数据库模式。当数据库已经存在，而我们打开一个更高版本时，同样会触发 onupgradeneeded 事件，用来更新数据库模式。 添加处理方法我们可以通过监听它的 success, error 以及 upgradeneeded 事件来做相应的操作。 request.onerror = function (event) &#123; // Do something with request.errorCode! console.error('open request failed',event.target.error)&#125;request.onsuccess = function (event) &#123; // Do something with request.result! // console.log('open request success', event) var db = event.target.result db.onerror = function (e) &#123; console.error('Database error: ', e.target.error) &#125; db.onclose = e =&gt; &#123; console.error('Database close:', e.target.error) &#125;&#125; 可以在 success 事件里面拿到 db 对象，这个是后续操作的主体。 错误处理由于是基于 DOM 事件模式的，所以所有的错误是会冒泡的。也就是说在一个特定 request 的上引发的错误会依次冒泡到事务，然后到 db 对象。如果为了简化错误处理，可以直接在 db 对象上添加错误处理： db.onerror = function (e) &#123; // 可以处理这个数据库上所有的错误 console.error('Database error: ', e.target.error)&#125; 2. 创建或更新数据库版本前面已经说过，当创建或者增大数据库版本的时候，会触发 onupgradeneeded 事件。在事件内部，可以拿到 db 对象来创建或更新 object store , 具体如下。 request.onupgradeneeded = function (event) &#123; /** * NOTE: * 1. 创建新的 objectStore * 2. 删除旧的不需要的 objectStore * 3. 如果需要更新已有 objectStore 的结构，需要先删除原有的 objectStore ，然后重新创建 */ // The IDBDatabase interface console.log('onupgradeneeded', event) var db = event.target.result // Create an objectStore for this database const objectStore = db.createObjectStore(OB_NAMES.UseKeyPath, &#123; keyPath: 'time' &#125;) &#125; 3. 构建数据库indexedDB 是以对象存储（object store）而不是以表结构存储的，一个数据库可以存储任意多个存储对象。每当有一个值存储在 object store 里面，就必须和一个 key 关联起来。有几种提供 key 的方法，取决于 object store 使用 key path 还是 key generator. 它们之间区别，借用 MDN 的一个表格来看一下： Key Path (keyPath) Key Generator (autoIncrement) Description No No This object store can hold any kind of value, even primitive values like numbers and strings. You must supply a separate key argument whenever you want to add a new value. Yes No This object store can only hold JavaScript objects. The objects must have a property with the same name as the key path. No Yes This object store can hold any kind of value. The key is generated for you automatically, or you can supply a separate key argument if you want to use a specific key. Yes Yes This object store can only hold JavaScript objects. Usually a key is generated and the value of the generated key is stored in the object in a property with the same name as the key path. However, if such a property already exists, the value of that property is used as key rather than generating a new key. 来自 https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API/Using_IndexedDB 当存储的是不是基础类型而是 js 对象的时候，我们还可以给 object store 创建索引，这样就可以通过索引属性来查找某一个具体的对象。而且， 索引还能再一定程度上约束要存储的对象。当创建索引的时候通过设置唯一标识，可以确保不会存储拥有两个相同索引值的对象。看一个例子，假设我们有如下日志数据需要存储： const TestData = [ &#123; event: 'NE-TEST1', level: 'warning', errorCode: 200, url: 'http://www.example.com', time: '2017/11/8 下午4:53:039', isUploaded: false &#125;, &#123; event: 'NE-TEST2', msg: '测试2', level: 'error', errorCode: 1000, url: 'http://www.example.com', time: '2017/11/8 下午4:53:042', isUploaded: false &#125;, &#123; event: 'NE-TEST3', msg: '测试3', level: 'info', errorCode: 3000, url: 'http://www.example.com', time: '2017/11/8 下午4:53:043', isUploaded: false &#125;, &#123; event: 'NE-TEST4', mgs: '测试4', level: 'info', url: 'http://www.example.com', time: '2017/11/8 下午4:53:0423', isUploaded: false &#125;] 这里有两种存储方式，分别是通过 key path 和 key generator. function obUseKeypath (db) &#123; const objectStore = db.createObjectStore(OB_NAMES.UseKeyPath, &#123; keyPath: 'time' &#125;) objectStore.createIndex('errorCode', 'errorCode', &#123; unique: false &#125;) objectStore.createIndex('level', 'level', &#123; unique: false &#125;)&#125;function obUseKeyGenerator (db) &#123; const objectStore = db.createObjectStore(OB_NAMES.UseKeyGenerator, &#123; autoIncrement: true &#125;) objectStore.createIndex('errorCode', 'errorCode', &#123; unique: false &#125;) objectStore.createIndex('time', 'time', &#123; unique: true &#125;) objectStore.createIndex('level', 'level', &#123; unique: false &#125;)&#125; 4. 增删改查为了方便介绍这部分的内容，我们先把上一节的代码包装一下，为了方便后续例子的讲解： function openindexedDB () &#123; // The call to the open() function returns an IDBOpenDBRequest object with a result (success) or error value that you handle as an event. return new Promise((resolve, reject) =&gt; &#123; /** * NOTE: * 1. 第一次打开可能会提示用户获取 indexedDB 的权限 * 2. 浏览器隐身模式不会存在本地，只会存储在内存中 */ const request = window.indexedDB.open(DB_NAME, DB_VERSION) request.onerror = function (event) &#123; // Do something with request.errorCode! console.log('open request failed', event) console.error(event.target.error) &#125; request.onsuccess = function (event) &#123; // Do something with request.result! // console.log('open request success', event) var db = event.target.result db.onerror = function (e) &#123; console.error('Database error: ', e.target.error) reject(e.target.error) &#125; db.onclose = e =&gt; &#123; console.error('Database close:', e.target.error) reject(e.target.error) &#125; resolve(db) &#125; request.onupgradeneeded = function (event) &#123; /** * NOTE: * 1. 创建新的 objectStore * 2. 删除旧的不需要的 objectStore * 3. 如果需要更新已有 objectStore 的结构，需要先删除原有的 objectStore ，然后重新创建 */ // The IDBDatabase interface console.log('onupgradeneeded', event) var db = event.target.result // Create an objectStore for this database obUseKeypath(db) obUseKeyGenerator(db) /** * NOTE: * transaction * 三个事件： * 1. error * 2. abort * 3. complete * 两个方法： * 1. abort * Rolls back all the changes to objects in the database associated with this transaction. If this transaction has been aborted or completed, then this method throws an error event. * 2. objectStore * Returns an IDBObjectStore object representing an object store that is part of the scope of this transaction. */ db.transaction.oncomplete = function (e) &#123; console.log('obj create success', e) &#125; &#125; &#125;)&#125;function obUseKeypath (db) &#123; const objectStore = db.createObjectStore(OB_NAMES.UseKeyPath, &#123; keyPath: 'time' &#125;) objectStore.createIndex('errorCode', 'errorCode', &#123; unique: false &#125;) objectStore.createIndex('level', 'level', &#123; unique: false &#125;)&#125;function obUseKeyGenerator (db) &#123; const objectStore = db.createObjectStore(OB_NAMES.UseKeyGenerator, &#123; autoIncrement: true &#125;) objectStore.createIndex('errorCode', 'errorCode', &#123; unique: false &#125;) objectStore.createIndex('time', 'time', &#123; unique: true &#125;) objectStore.createIndex('level', 'level', &#123; unique: false &#125;)&#125; 这样每次我们需要对数据库做操作的话只需要调用 openindexedDB 方法就可以了。 事务所有对数据库的操作都是建立在事务(transaction)上的，有三种模式(mode)：readonly, readewrite, versionchange.要修改数据库结构的 schema ，必须在 versionchange 模式下。读取和修改对应另外两种模式。通过 IDBDatabase.transaction 打开一个 transaction, 接收两个参数：storeNames, mode.所有对数据库的操作都遵循以下流程： Get database object Open transaction on database Open object store on transaction Perform operation on object store 加速事务操作： 当定义作用域时（scope）， 只定义需要的 object stores. 这样，就可以在不重叠的作用域上并行的执行多个事务。 只有在需要的时候才开启一个 readwrite 事务。因为在重叠的作用域上可以并发执行多个 readonly 事务，但只能有一个 readwrite 事务。 增方法如下： 首先拿到 db 对象 然后打开一个 readwrite 事务 通过事务拿到 object store 对象 执行添加数据操作 /*** 添加数据* @param &#123;array&#125; docs 要添加数据* @param &#123;string&#125; objName 仓库名称*/function addData (docs, objName) &#123; if (!(docs &amp;&amp; docs.length)) &#123; throw new Error('docs must be a array!') &#125; return openindexedDB().then(db =&gt; &#123; const tx = db.transaction([objName], 'readwrite') tx.oncomplete = e =&gt; &#123; console.log('tx:addData onsuccess', e) return Promise.resolve(docs) &#125; tx.onerror = e =&gt; &#123; e.stopPropagation() console.error('tx:addData onerror', e.target.error) return Promise.reject(e.target.error) &#125; tx.onabort = e =&gt; &#123; console.warn('tx:addData abort', e.target) return Promise.reject(e.target.error) &#125; const obj = tx.objectStore(objName) docs.forEach(doc =&gt; &#123; const req = obj.add(doc) /** * NOTE: * request * 两个事件： * 1. success * 2. error */ // req.onsuccess = e =&gt; console.log('obj:addData onsuccess', e.target) req.onerror = e =&gt; &#123; console.error('obj:addData onerror', e.target.error) &#125; &#125;) &#125;)&#125; 如果要把上面的 TestData 同时使用 key generator 和 key path 方式保存到数据库中，那么方法： addData(TestData, OB_NAMES.UseKeyGenerator).then(() =&gt; addData(TestData, OB_NAMES.UseKeyPath)) 删流程和添加一样： /*** 删除指定 key 的数据* @param &#123;string&#125; objName 仓库名称* @param &#123;*&#125; key 要删除数据的 primary key 值*/function deleteData (objName, key) &#123; return openindexedDB().then(db =&gt; &#123; const tx = db.transaction([objName], 'readwrite') const obj = tx.objectStore(objName) const req = obj.delete(key) req.onsuccess = e =&gt; &#123; console.log(`readData success. key:$&#123;key&#125;,result:`, e.target.result) return Promise.resolve(e.target.result) &#125; req.onerror = e =&gt; &#123; console.error(`readData error. key:$&#123;key&#125;,error: $&#123;e.target.errorCode&#125;`) return Promise.reject(e.target.error) &#125; &#125;)&#125; 假如要删除 UserKeyGenerator 里 key 为 1 值，那么： deleteData(OB_NAMES.UseKeyGenerator, 1) .then(doc =&gt; console.log(doc)) 查方法： /*** 读取给定 key 的数据* @param &#123;string&#125; objName 仓库名称* @param &#123;*&#125; key 要读取数据的 primary key 值*/function readData (objName, key) &#123; return openindexedDB().then(db =&gt; &#123; const tx = db.transaction([objName]) const obj = tx.objectStore(objName) const req = obj.get(key) req.onsuccess = e =&gt; &#123; console.log(`readData success. key:$&#123;key&#125;,result:`, e.target.result) return Promise.resolve(e.target.result) &#125; req.onerror = e =&gt; &#123; console.error(`readData error. key:$&#123;key&#125;,error: $&#123;e.target.errorCode&#125;`) return Promise.reject(e.target.error) &#125; &#125;)&#125; 例子： readData(OB_NAMES.UseKeyGenerator, 1) 改方法： /*** 更新指定 key 的数据* @param &#123;string&#125; objName 仓库名称* @param &#123;*&#125; key 指定的 key* @param &#123;object&#125; changes 要修改的属性值*/function updateData (objName, key, changes) &#123; return openindexedDB().then(db =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; const tx = db.transaction([objName], 'readwrite') const obj = tx.objectStore(objName) const req = obj.get(key) req.onsuccess = e =&gt; &#123; let doc = e.target.result let newDoc = Object.assign(doc, changes) const req = obj.put(newDoc) req.onsuccess = e =&gt; &#123; console.log(`updateData success, newDoc:`, newDoc, e) resolve(e.target.result) &#125; req.onerror = e =&gt; &#123; resolve(e.target.result) &#125; &#125; req.onerror = e =&gt; &#123; reject(e.target.error) &#125; &#125;) &#125;)&#125; 例子： updateData(OB_NAMES.UseKeyGenerator, 1, &#123;time: '123'&#125;) .then(doc =&gt; console.log(doc)) .catch(console.error) 使用游标 (cursor)使用 get 方法需要预先知道一个 key. 如果需要步进整个 object store 的值，那么可以使用 cursor. /*** 通过 cursor 获取制定仓库下的所有数据* @param &#123;string&#125; objName 仓库名称* @param &#123;function&#125; [cb] 回调函数，对每次得到的 cursor 进行操作* @returns &#123;Promise.&lt;array.&lt;object&gt;&#125; 包含所有数据的数组*/function getAllByCursor (objName, cb) &#123; return openindexedDB().then(db =&gt; &#123; const arr = [] const tx = db.transaction([objName]) const obj = tx.objectStore(objName) return new Promise(resolve =&gt; &#123; obj.openCursor().onsuccess = e =&gt; &#123; const cursor = e.target.result if (cursor) &#123; arr.push(cursor.value) cb &amp;&amp; cb(cursor) cursor.continue() &#125; else &#123; return resolve(arr) &#125; &#125; &#125;) &#125;)&#125; openCursor() 方法接收多个参数。 第一个参数，可以传入一个 key range 对象来限制需要获取值的范围。 第二个参数，可以设置迭代的方向。 成功回调函数的 result 值就是 cursor 本身，当前遍历值可以通过 cursor 对象的 key 和 value 值获取。如果要继续往下遍历，那么调用 cursor 的 continue() 方法，当遍历结束时， cursor 也就是 event.target.result 的值为 undefined.如果要获取 UseKeyGenerator 仓库下所有的值，那么可以这样： getAllByCursor(OB_NAMES.UseKeyGenerator).then(console.log) 除了 openCursor() 外，还可以使用 openKeyCursor() 来获取所有存储对象的主键值，使用方法和 openCursor 一样， 使用索引 (index)在建立 object store 时，如果我们给它创建了索引。这时，就可以使用索引来查找某个特定属性的值： function getByIndex (objName, indexName, key) &#123; return openindexedDB().then(db =&gt; &#123; const index = db.transaction(objName).objectStore(objName).index(indexName) return new Promise(resolve =&gt; &#123; index.get(key).onsuccess = e =&gt; &#123; console.log('getByIndex', e.target.result) return resolve(e.target.result) &#125; &#125;) &#125;)&#125; 比如，我们要查找 level 为 info 的日志，那么可以这样: getByIndex(OB_NAMES.UseKeyGenerator, 'level', 'info').then(doc =&gt; console.log(doc)) 设置范围 (range) 和游标 (cursors) 的方向如果需要设置 cursor 遍历的范围，可以使用 IDBKeyRange 对象并把作为第一个参数给 openCursor() 或者 openKeyCursor() .一个 key range 的值，可以认为是一个区间，区间的类型可以是开区间也可以是闭区间。看一些例子： /*** NOTE:* 只包括给定的值*/getWithRangeByCursor( OB_NAMES.UseKeyGenerator,'errorCode', IDBKeyRange.only(1000)) .then(console.log) .catch(console.error)/*** NOTE:* 默认是闭区间*/getWithRangeByCursor( OB_NAMES.UseKeyGenerator,'errorCode', IDBKeyRange.lowerBound(1000)) .then(console.log) .catch(console.error)/*** NOTE:* 设置第二个可选参数为 true，则为开区间*/getWithRangeByCursor(OB_NAMES.UseKeyGenerator,'errorCode', IDBKeyRange.lowerBound(1000, true)) .then(console.log) .catch(console.error)/*** NOTE:* 闭区间，如果索引是数字，那么按照数字大小决定升序*/getWithRangeByCursor(OB_NAMES.UseKeyGenerator,'errorCode', IDBKeyRange.bound(1000, 2000)) .then(console.log) .catch(console.error)/*** NOTE:* 左闭右开区间：如果索引是字符串，那么安装 array.sort() 的方式决定升序*/getWithRangeByCursor(OB_NAMES.UseKeyGenerator,'time', IDBKeyRange.bound('2017/11/8 下午4:53:042', '2017/11/8 下午4:53:043', false, true)) .then(console.log) .catch(console.error) 降序迭代默认情况下，迭代的方向是升序的。如果需要按照降序规则迭代，那么只要把 prev 作为 openCursor() 的第二个参数就可以了： getWithDescendingByCursor(OB_NAMES.UseKeyGenerator, 'time') .then(console.log) .catch(console.error)]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Redux 源码解读（长文慎入）]]></title>
    <url>%2F2017%2F10%2F14%2Fredux-source-code-read%2F</url>
    <content type="text"><![CDATA[Redux 的源码非常的精炼，短短几百行代码，去提供了强大的功能。今天，我们就来一探究竟。 看源码最简单的方式，就是从入口文件来看，看它依赖哪些模块，然后在依次看这些模块的内容，最后也就对整个代码有个清晰的认识了。 所以我们就从入口文件开始来看： import createStore from './createStore'import combineReducers from './combineReducers'import bindActionCreators from './bindActionCreators'import applyMiddleware from './applyMiddleware'import compose from './compose'import warning from './utils/warning'/** This is a dummy function to check if the function name has been altered by minification.* If the function has been minified and NODE_ENV !== 'production', warn the user.*/function isCrushed() &#123;&#125;// 就是根据 isCrushed 是否被压缩了，来警告开发者正在非生产环境使用一个压缩过的代码。if ( process.env.NODE_ENV !== 'production' &amp;&amp; typeof isCrushed.name === 'string' &amp;&amp; isCrushed.name !== 'isCrushed') &#123; warning( 'You are currently using minified code outside of NODE_ENV === \'production\'. ' + 'This means that you are running a slower development build of Redux. ' + 'You can use looseenvify (https://github.com/zertosh/looseenvify) for browserify ' + 'or DefinePlugin for webpack (http://stackoverflow.com/questions/30030031) ' + 'to ensure you have the correct code for your production build.' )&#125;export &#123; createStore, combineReducers, bindActionCreators, applyMiddleware, compose&#125; 可以看到它依赖了下面这几个模块： createStore combineReducers bindActionCreators applyMiddleware compose warning 其他没什么说的，就是把一些 API 暴露出去。那我们就先按照这个模块依赖顺序，依次进行解读。 createStore 首先是createStore， 用来创建整个应用的 store .它的依赖模块，都是些工具函数。 isPlainObject $$observable export default function createStore(reducer, preloadedState, enhancer) &#123; if (typeof preloadedState === 'function' &amp;&amp; typeof enhancer === 'undefined') &#123; enhancer = preloadedState preloadedState = undefined &#125; if (typeof enhancer !== 'undefined') &#123; if (typeof enhancer !== 'function') &#123; throw new Error('Expected the enhancer to be a function.') &#125; return enhancer(createStore)(reducer, preloadedState) &#125; if (typeof reducer !== 'function') &#123; throw new Error('Expected the reducer to be a function.') &#125; 这里逻辑很简单： 第一个 if 语句的意思就是说，如果只传入了两个参数，且第二个参数 preloadedState 为函数，那么就认为第二个参数为 enhancer . 第二个 if 语句确保 enhancer 是一个函数，并且当 enhancer 作为参数传入的时候，返回 enhancer(createStore)(reucer, preloadedState) 作为 createStore 的返回，也就是我们要的 store. 第三个 if 语句确保 reducer 是一个函数。 接着往下看： let currentReducer = reducerlet currentState = preloadedStatelet currentListeners = []let nextListeners = currentListenerslet isDispatching = falsefunction ensureCanMutateNextListeners() &#123; if (nextListeners === currentListeners) &#123; nextListeners = currentListeners.slice() &#125;&#125;/** * Reads the state tree managed by the store. * * @returns &#123;any&#125; The current state tree of your application. */function getState() &#123; return currentState&#125; 这里，把 preloadState 赋值给 currentState ，可以使应用直接重现某一个状态，也可以用来做服务端渲染时直接由后台计算出来作为应用的初始状态。 ensureCanMutateNextListeners 这个函数在 nextListeners === currentListeners 成立时把 currentListeners 复制了一份赋值给了 nextListeners . 用来做什么还不太清楚，先放着。 然后定义了一个获取当前 state 的方法。 subscribe接下来是一个subscribe 方法。 /** * Adds a change listener. It will be called any time an action is dispatched, * and some part of the state tree may potentially have changed. You may then * call `getState()` to read the current state tree inside the callback. * * You may call `dispatch()` from a change listener, with the following * caveats: * * 1. The subscriptions are snapshotted just before every `dispatch()` call. * If you subscribe or unsubscribe while the listeners are being invoked, this * will not have any effect on the `dispatch()` that is currently in progress. * However, the next `dispatch()` call, whether nested or not, will use a more * recent snapshot of the subscription list. * * 2. The listener should not expect to see all state changes, as the state * might have been updated multiple times during a nested `dispatch()` before * the listener is called. It is, however, guaranteed that all subscribers * registered before the `dispatch()` started will be called with the latest * state by the time it exits. * * @param &#123;Function&#125; listener A callback to be invoked on every dispatch. * @returns &#123;Function&#125; A function to remove this change listener. */ function subscribe(listener) &#123; if (typeof listener !== 'function') &#123; throw new Error('Expected listener to be a function.') &#125; let isSubscribed = true ensureCanMutateNextListeners() nextListeners.push(listener) return function unsubscribe() &#123; if (!isSubscribed) &#123; return &#125; isSubscribed = false ensureCanMutateNextListeners() const index = nextListeners.indexOf(listener) nextListeners.splice(index, 1) &#125; &#125; 注释已经说的非常明白了，注册一个 listener 监听函数，把他 push 到当前的监听里列表 nextListener 里面，并返回一个 unsubscribe 方法用来注销当前这个监听函数。 dispatchfunction dispatch(action) &#123; if (!isPlainObject(action)) &#123; throw new Error( 'Actions must be plain objects. ' + 'Use custom middleware for async actions.' ) &#125; if (typeof action.type === 'undefined') &#123; throw new Error( 'Actions may not have an undefined "type" property. ' + 'Have you misspelled a constant?' ) &#125; if (isDispatching) &#123; throw new Error('Reducers may not dispatch actions.') &#125; try &#123; isDispatching = true currentState = currentReducer(currentState, action) &#125; finally &#123; isDispatching = false &#125; const listeners = currentListeners = nextListeners for (let i = 0; i &lt; listeners.length; i++) &#123; const listener = listeners[i] listener() &#125; return action&#125; 用来分发一个 action 来改变当前的 state . 也是唯一的改变 state 的方法。接受一个用来描述动作的 action 为参数，并且把这个 action 作为函数的返回值。 从代码前面的判断可以看到，action 必须是一个字面量对象，并且必须包含一个 type 的属性。 if (isDispatching) &#123; throw new Error('Reducers may not dispatch actions.')&#125; 从这里可以看到，如果当前正处于上一个 action 的分发阶段，那么当前这个 action 有可能会分发失败。 后面进行当前 state 的计算，并且按顺序去触发 nextListeners 里面的监听函数。 replaceReducer/** * Replaces the reducer currently used by the store to calculate the state. * * You might need this if your app implements code splitting and you want to * load some of the reducers dynamically. You might also need this if you * implement a hot reloading mechanism for Redux. * * @param &#123;Function&#125; nextReducer The reducer for the store to use instead. * @returns &#123;void&#125; */function replaceReducer(nextReducer) &#123; if (typeof nextReducer !== 'function') &#123; throw new Error('Expected the nextReducer to be a function.') &#125; currentReducer = nextReducer dispatch(&#123; type: ActionTypes.INIT &#125;)&#125; 替换掉当前的 reducer 并且分发一个用来初始化的内部 action. export const ActionTypes = &#123; INIT: '@@redux/INIT'&#125; observable/** * Interoperability point for observable/reactive libraries. * @returns &#123;observable&#125; A minimal observable of state changes. * For more information, see the observable proposal: * https://github.com/tc39/proposalobservable */function observable() &#123; const outerSubscribe = subscribe return &#123; /** * The minimal observable subscription method. * @param &#123;Object&#125; observer Any object that can be used as an observer. * The observer object should have a `next` method. * @returns &#123;subscription&#125; An object with an `unsubscribe` method that can * be used to unsubscribe the observable from the store, and prevent further * emission of values from the observable. */ subscribe(observer) &#123; if (typeof observer !== 'object') &#123; throw new TypeError('Expected the observer to be an object.') &#125; function observeState() &#123; if (observer.next) &#123; observer.next(getState()) &#125; &#125; observeState() const unsubscribe = outerSubscribe(observeState) return &#123; unsubscribe &#125; &#125;, [$$observable]() &#123; return this &#125; &#125;&#125; 用来把一个对象变成可 observe 的方法，一般情况下用不到。 最后// When a store is created, an "INIT" action is dispatched so that every// reducer returns their initial state. This effectively populates// the initial state tree.dispatch(&#123; type: ActionTypes.INIT &#125;)return &#123; dispatch, subscribe, getState, replaceReducer, [$$observable]: observable&#125; 分发一个 INIT 的初始化 action ，用来让所有的 reducer 来返回默认的初始化 state. 然后把上面的函数返回出来，作为通过 createStore 创建出来的 store 的 api. combineReducers这个模块用来合并多个 reducers 到一个 reducer，它的依赖模块： ActionTypes isPlainObject warning 我们依次来看看 combineReducers 里面的内容。 getUndefinedStateErrorMessagefunction getUndefinedStateErrorMessage(key, action) &#123; const actionType = action &amp;&amp; action.type const actionName = (actionType &amp;&amp; `"$&#123;actionType.toString()&#125;"`) || 'an action' return ( `Given action $&#123;actionName&#125;, reducer "$&#123;key&#125;" returned undefined. ` + `To ignore an action, you must explicitly return the previous state. ` + `If you want this reducer to hold no value, you can return null instead of undefined.` )&#125; 定义一个用来生成当 reducer 返回 undefined 时错误内容的函数，没什么好说的。 getUnexpectedStateShapeWarningMessagefunction getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) &#123; const reducerKeys = Object.keys(reducers) const argumentName = action &amp;&amp; action.type === ActionTypes.INIT ? 'preloadedState argument passed to createStore' : 'previous state received by the reducer' if (reducerKeys.length === 0) &#123; return ( 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.' ) &#125; if (!isPlainObject(inputState)) &#123; return ( `The $&#123;argumentName&#125; has unexpected type of "` + (&#123;&#125;).toString.call(inputState).match(/\s([az|AZ]+)/)[1] + `". Expected argument to be an object with the following ` + `keys: "$&#123;reducerKeys.join('", "')&#125;"` ) &#125; const unexpectedKeys = Object.keys(inputState).filter(key =&gt; !reducers.hasOwnProperty(key) &amp;&amp; !unexpectedKeyCache[key] ) unexpectedKeys.forEach(key =&gt; &#123; unexpectedKeyCache[key] = true &#125;) if (unexpectedKeys.length &gt; 0) &#123; return ( `Unexpected $&#123;unexpectedKeys.length &gt; 1 ? 'keys' : 'key'&#125; ` + `"$&#123;unexpectedKeys.join('", "')&#125;" found in $&#123;argumentName&#125;. ` + `Expected to find one of the known reducer keys instead: ` + `"$&#123;reducerKeys.join('", "')&#125;". Unexpected keys will be ignored.` ) &#125;&#125; 从函数名 “获取未期望State结构错误信息” 可以看出这个函数用来生成当传入的 inputState 组成结构错误时的错误信息。 Reducer 必须有 key 值（这不废话），inputState 必须是一个字面量对象。且inputState 的 key 都应该在 reducer 的自身属性（OwnProperty, 非原型链上的）中，并且不能在传入的 unexpectedKeyCache 中。 assertReducerShapefunction assertReducerShape(reducers) &#123; Object.keys(reducers).forEach(key =&gt; &#123; const reducer = reducers[key] const initialState = reducer(undefined, &#123; type: ActionTypes.INIT &#125;) if (typeof initialState === 'undefined') &#123; throw new Error( `Reducer "$&#123;key&#125;" returned undefined during initialization. ` + `If the state passed to the reducer is undefined, you must ` + `explicitly return the initial state. The initial state may ` + `not be undefined. If you don't want to set a value for this reducer, ` + `you can use null instead of undefined.` ) &#125; const type = '@@redux/PROBE_UNKNOWN_ACTION_' + Math.random().toString(36).substring(7).split('').join('.') if (typeof reducer(undefined, &#123; type &#125;) === 'undefined') &#123; throw new Error( `Reducer "$&#123;key&#125;" returned undefined when probed with a random type. ` + `Don't try to handle $&#123;ActionTypes.INIT&#125; or other actions in "redux/*" ` + `namespace. They are considered private. Instead, you must return the ` + `current state for any unknown actions, unless it is undefined, ` + `in which case you must return the initial state, regardless of the ` + `action type. The initial state may not be undefined, but can be null.` ) &#125; &#125;)&#125; 用来保证传入的 reducers 的结构正确，也就说说每个 reducer 都必须在收到 INIT action 后返回一个不为 undefined 的 initState ，并且这个 action 不能在 reducer 中专门去处理。这也是为什么我们在 reducer 里面一定要指定默认返回的 state 的原因. combineReducers/** * Turns an object whose values are different reducer functions, into a single * reducer function. It will call every child reducer, and gather their results * into a single state object, whose keys correspond to the keys of the passed * reducer functions. * * @param &#123;Object&#125; reducers An object whose values correspond to different * reducer functions that need to be combined into one. One handy way to obtain * it is to use ES6 `import * as reducers` syntax. The reducers may never return * undefined for any action. Instead, they should return their initial state * if the state passed to them was undefined, and the current state for any * unrecognized action. * * @returns &#123;Function&#125; A reducer function that invokes every reducer inside the * passed object, and builds a state object with the same shape. */export default function combineReducers(reducers) &#123; const reducerKeys = Object.keys(reducers) const finalReducers = &#123;&#125; for (let i = 0; i &lt; reducerKeys.length; i++) &#123; const key = reducerKeys[i] if (process.env.NODE_ENV !== 'production') &#123; if (typeof reducers[key] === 'undefined') &#123; warning(`No reducer provided for key "$&#123;key&#125;"`) &#125; &#125; if (typeof reducers[key] === 'function') &#123; finalReducers[key] = reducers[key] &#125; &#125; const finalReducerKeys = Object.keys(finalReducers) let unexpectedKeyCache if (process.env.NODE_ENV !== 'production') &#123; unexpectedKeyCache = &#123;&#125; &#125; let shapeAssertionError try &#123; assertReducerShape(finalReducers) &#125; catch (e) &#123; shapeAssertionError = e &#125; return function combination(state = &#123;&#125;, action) &#123; if (shapeAssertionError) &#123; throw shapeAssertionError &#125; if (process.env.NODE_ENV !== 'production') &#123; const warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache) if (warningMessage) &#123; warning(warningMessage) &#125; &#125; let hasChanged = false const nextState = &#123;&#125; for (let i = 0; i &lt; finalReducerKeys.length; i++) &#123; const key = finalReducerKeys[i] const reducer = finalReducers[key] const previousStateForKey = state[key] const nextStateForKey = reducer(previousStateForKey, action) if (typeof nextStateForKey === 'undefined') &#123; const errorMessage = getUndefinedStateErrorMessage(key, action) throw new Error(errorMessage) &#125; nextState[key] = nextStateForKey hasChanged = hasChanged || nextStateForKey !== previousStateForKey &#125; return hasChanged ? nextState : state &#125;&#125; combineReducer 接收一个用来合并成一个 reducer 的对象，执行后返回一个函数，也即是我们的 rootReducer . 首先把传入的 reducers 按 key 遍历后赋值给 finalReducers . 然后进行一堆错误判断，最后返回一个函数 combination. 也就是合并后的 reducer : let hasChanged = falseconst nextState = &#123;&#125;// 遍历 finalReducerKeysfor (let i = 0; i &lt; finalReducerKeys.length; i++) &#123;// 拿到当前的 reducer key const key = finalReducerKeys[i]// 根据 reducer key 拿到具体的 reducer 函数 const reducer = finalReducers[key]// 获取之前的 key 对应的 state const previousStateForKey = state[key]// 计算下一个当前 key 对应的 state const nextStateForKey = reducer(previousStateForKey, action)// 如果计算出来的 state 为 undefined 那么报错 if (typeof nextStateForKey === 'undefined') &#123; const errorMessage = getUndefinedStateErrorMessage(key, action) throw new Error(errorMessage) &#125;// 把当前 key 对应的 state 赋值到下一个全局 state nextState[key] = nextStateForKey// 只要有一个 key 对应的 state 发生了变化，那么就认为整个 state 发生了变化 hasChanged = hasChanged || nextStateForKey !== previousStateForKey&#125;// 根据 state 是否发生变化，返回下一个 state 或者上一个 state return hasChanged ? nextState : state &#125; bindActionCreators这个函数非常简单，是一个辅助函数。用来把 dispatch 绑定到一个 actionCreator 上，这样当就可以通过直接调用绑定后的函数来分发一个 action ，而不需要 dispatch(actionCreator(…)) 了。 applyMiddleware这里是重点，也是一般初学者难以理解的地方，我们仔细看看。import compose from './compose'/** * Creates a store enhancer that applies middleware to the dispatch method * of the Redux store. This is handy for a variety of tasks, such as expressing * asynchronous actions in a concise manner, or logging every action payload. * * See `reduxthunk` package as an example of the Redux middleware. * * Because middleware is potentially asynchronous, this should be the first * store enhancer in the composition chain. * * Note that each middleware will be given the `dispatch` and `getState` functions * as named arguments. * * @param &#123;...Function&#125; middlewares The middleware chain to be applied. * @returns &#123;Function&#125; A store enhancer applying the middleware. */export default function applyMiddleware(...middlewares) &#123; return (createStore) =&gt; (reducer, preloadedState, enhancer) =&gt; &#123; const store = createStore(reducer, preloadedState, enhancer) let dispatch = store.dispatch let chain = [] const middlewareAPI = &#123; getState: store.getState, dispatch: (action) =&gt; dispatch(action) &#125; chain = middlewares.map(middleware =&gt; middleware(middlewareAPI)) dispatch = compose(...chain)(store.dispatch) return &#123; ...store, dispatch &#125; &#125;&#125; 代码量非常短，依赖了模块 compose . applyMiddleware 函数接受一系列中间件函数作为参数，返回了一个拥有 createStore 方法的闭包函数。这个函数，接收 reducer ，preloadedState 和 enhancer 为参数。配合 createStore 函数来看：export default function createStore(reducer, preloadedState, enhancer) &#123; if (typeof preloadedState === 'function' &amp;&amp; typeof enhancer === 'undefined') &#123; enhancer = preloadedState preloadedState = undefined &#125; if (typeof enhancer !== 'undefined') &#123; if (typeof enhancer !== 'function') &#123; throw new Error('Expected the enhancer to be a function.') &#125; return enhancer(createStore)(reducer, preloadedState) &#125; 当我们这样创建 store 的时候：const store = createStore( reducer, applyMiddleware(...middleware)) createStore 的第二个参数是个函数，所以就会走到return enhancer(createStore)(reducer, preloadedState) 也就是由 applyMiddleware(…middleware) 的结果接管了 createStore ,实际的 store 是在 applyMiddleware 里面再次调用 createStore 创建的，此时传入的 preloadedState, enhancer 都是 undefined.// applyMiddlewareconst store = createStore(reducer, preloadedState, enhancer) 回过头来继续往下看，//applyMiddlewaredispatch = compose(...chain)(store.dispatch) 这里需要先看一下 compose 这个模块，它的作用就是达到 compose(f, g, h) &gt; (...args) =&gt; f(g(h(...args))) 这么一个目的。 那么这里的 dispatch 就是在 store.dispatch 基础上经过 middleware 加强封装后的 dispatch.const middlewareAPI = &#123; getState: store.getState, dispatch: (action) =&gt; dispatch(action)&#125;// 把 middlewareAPI 传入到每个中间件中chain = middlewares.map(middleware =&gt; middleware(middlewareAPI)) 这里的 dispatch: (action) =&gt; dispatch(action) ，说明每个中间件中的 dispatch 都是独立互不影响的，以免某个中间件中修改了 dispatch 的行为。然后给每个中间件都传入 getState 和 dispatch 作为他们的参数。return &#123; ...store, dispatch&#125; 最后用加强后的 dispatch 覆盖掉原有 store 中的 dispatch. 整个中间件的代码看下来，可能比较抽象，我们结合一个例子来看一下： errorMiddlewareexport default (&#123;dispatch, getState&#125;) =&gt; next =&gt; action =&gt; &#123; const &#123;error, payload&#125; = action if (error) &#123; dispatch(showToast(payload.message || payload.toString())) &#125; return next(action)&#125; 这是我们的一个错误处理中间件。它也是一个高阶函数，首先接受 dispatch, getState 为参数，返回一个接受 next 为参数的函数。dispatch, getState 就是在上面代码里通过 middlewareAPI 传入了中间件中。 然后我们继续看 errorMiddleware 执行后返回的接受 next 为参数的函数，而 next 其实就是下一个要执行的 middleware . 然后我们需要了解一下中间件的执行顺序，那么为了更清楚的描述一个 action 在中间件中的传播过程，我们假设有以下三个中间件： const mid1 = () =&gt; next =&gt; action =&gt; &#123; console.log('mid1 before') next(action) console.log('mid1 after')&#125;const mid2 = () =&gt; next =&gt; action =&gt; &#123; console.log('mid2 before') next(action) console.log('mid2 after')&#125;const mid3 = () =&gt; next =&gt; action =&gt; &#123; console.log('mid3 before') next(action) console.log('mid3 after')&#125; 执行 applyMiddleware( mid1, mid2, mid3 ), 那么经过下面代码后dispatch = compose(...chain)(store.dispatch) 就可以得到： dispatch = (store.dispatch) =&gt; mid1(mid2(mid3(store.dispatch))) 其中的 midx 都是已经执行了 middleware(middlewareAPI) 后返回的结果。所以 mid3 的 next 的值就是 store.dispatch 。而 mid2 的 next 则是 mid3(store.dispatch) ，以此类推，mid1 的 next 就是 mid2(mid3(store.dispatch)) , 这也就是在 middleware 调用 next 能够让 action 转到下一个 middleware 的原因。 当我们分发一个 action 时，控制台打印出来的顺序是这样的： mid1 beforemid2 beforemid3 beforemid3 aftermid2 aftermid1 after 可以看到它的流程是这样的： 执行 mid1 中 next 方法调用之前的代码 执行 mid2 中 next 方法调用之前的代码 执行 mid3 中 next 方法调用之前的代码 执行 dispatch 来分发 action 执行 mid3 中 next 方法调用之后的代码 执行 mid2 中 next 方法调用之后的代码 执行 mid1 中 next 方法调用之后的代码 看一张图，会更明白一点： 其中红色的路径就是我们刚才描述的流程。可以看到其中还有一条黑色路径，也就是如果我们直接在 mid2 中调用 dispatch 会怎么样？我们来改一下 mid2 const mid2 = (&#123; dispatch, getStore &#125;) =&gt; next =&gt; action =&gt; &#123; console.log('mid2 before') dispatch(action) console.log('mid2 after')&#125; 改成这样，猜猜会怎样？ 答案是，会一直在 mid1 before 和 mid2 before 中死循环，因为调用的 dispatch 会让这个 action 重新走一遍所有的中间件，也就是图中的黑色路径。那么当我们需要在一个中间件中调用 dispatch 的时候，是要对 action 做判断的，只有满足某个条件的时候才调用 dispatch 以免出现死循环。改造一下 mid2 const mid2 = (&#123; dispatch, getStore &#125;) =&gt; next =&gt; action =&gt; &#123; console.log('mid2 before') if(action.isApi) &#123; dispatch(&#123; isApi: false, ... &#125;) &#125; dispatch(action) console.log('mid2 after')&#125; 这样，就只有在 action 满足 isApi 条件的时候才会取分发一个不满足 isApi 条件的 action ，这样就不会死循环。一般在异步分发 action 的时候会经常用这个方法。比如我们生产环境用来请求数据的 callAPIMiddleware : export default (&#123;dispatch, getState&#125;) =&gt; &#123;return next =&gt; action =&gt; &#123; const &#123; types, api, callType, meta, body, shouldCallAPI &#125; = action const state = getState() const callTypeList = ['get', 'post'] if (!api) &#123; return next(action) &#125; if (!(types.start &amp;&amp; types.success &amp;&amp; types.failure)) &#123; throw new Error('Expected types has start &amp;&amp; success &amp;&amp; failure keys.') &#125; if (callTypeList.indexOf(callType) === 1) &#123; throw new Error(`API callType Must be one of $&#123;callTypeList&#125;`) &#125; const &#123;start, success, failure&#125; = types if (!shouldCallAPI(state)) &#123; return false &#125; dispatch(&#123; type: start, payload: &#123; ...body &#125;, meta &#125;) const mapCallTypeToFetch = &#123; post: () =&gt; fetch(api, &#123; method: 'post', // credentials 设置为每次请求都带上 cookie credentials: 'include', headers: &#123; 'Accept': 'application/json', 'Content-Type': 'application/json' &#125;, body: JSON.stringify(bodyWithSource) &#125;), get: () =&gt; &#123; const toString = Object.keys(bodyWithSource).map(function (key, index) &#123; return encodeURIComponent(key) + '=' + encodeURIComponent(bodyWithSource[key]) &#125;).join('&amp;') return fetch(`$&#123;api&#125;?$&#123;toString&#125;`, &#123; method: 'get', credentials: 'include', headers: &#123; 'Accept': 'application/json' &#125; &#125;) &#125; &#125; const fetching = mapCallTypeToFetch[callType]()... 省略一堆业务逻辑 return fetching.then(res =&gt; &#123; clearTimeout(loadingTimer) dispatch(hideLoading()) if (res.ok) &#123; try &#123; return res.json() &#125; catch (err) &#123; throw new Error(err) &#125; &#125; else &#123; dispatch(showToast('请求出错')) return Promise.reject(res.text()) &#125; &#125;) .then(res =&gt; resBehaviour(res)) .then(res =&gt; &#123; dispatch(&#123; type: success, meta, payload: &#123; ...res.data &#125; &#125;) return Promise.resolve(res) &#125;) .catch(err =&gt; &#123; console.error(`接口请求出错,$&#123;err&#125;`) return Promise.reject(err) &#125;)&#125; 关于中间件就说这么多，大家应该也能理解了。 总结总体上看， Redux 的源码非常短，但是各种实现都非常的精巧。 而且作者非常重视对开发者的体验，注释非常的详细，整体上读起来比较轻松。错误处理也非常详细，可以帮助开发者更容易的定位错误。 最后，由于本人能力有限，文中如果有错误的地方，还请指出一起讨论。]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ReactDOM 是如何把组件渲染到 DOM 中的？]]></title>
    <url>%2F2017%2F09%2F20%2Fhow-react-render-component-to-dom%2F</url>
    <content type="text"><![CDATA[当我们在开发 React 项目中，第一次调用 ReactDOM.render 的时候都发生了什么呢？今天就从源码角度来追踪一下这个问题（主要看流程， 而不纠结与细节）。 ReactDOMStackEntry首先我们可以从 ReactDOM 的入口文件 ReactDOMStackEntry.js 中找到 render 方法。可以看到，render 方法是 ReactMount 组件提供的。var ReactDOMStack = &#123; findDOMNode: findDOMNode, render: ReactMount.render, unmountComponentAtNode: ReactMount.unmountComponentAtNode, version: ReactVersion, /* eslint-disable camelcase */ unstable_batchedUpdates: ReactGenericBatching.batchedUpdates, unstable_renderSubtreeIntoContainer: ReactMount.renderSubtreeIntoContainer, /* eslint-enable camelcase */ __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: &#123; // For TapEventPlugin which is popular in open source EventPluginHub: require('EventPluginHub'), // Used by test-utils EventPluginRegistry: require('EventPluginRegistry'), EventPropagators: require('EventPropagators'), ReactControlledComponent: require('ReactControlledComponent'), ReactDOMComponentTree, ReactDOMEventListener: require('ReactDOMEventListener'), ReactUpdates: ReactUpdates, &#125;,&#125;; ReactMount.renderrender: function(nextElement, container, callback) &#123; return ReactMount._renderSubtreeIntoContainer( null, nextElement, container, callback, );&#125;, 又调到了 _renderSubtreeIntoContainer 方法, 这个方法核心内容如下： ReactMount._renderSubtreeIntoContainer_renderSubtreeIntoContainer: function( parentComponent, nextElement, container, callback, ) &#123; callback = callback === undefined ? null : callback; if (!React.isValidElement(nextElement)) &#123; ... &#125; // 创建下一个 wrapped 元素 var nextWrappedElement = React.createElement(TopLevelWrapper, &#123; child: nextElement, &#125;); var nextContext = getContextForSubtree(parentComponent); // 拿到当前的顶层容器组件 var prevComponent = getTopLevelWrapperInContainer(container); // 对于第一次 render 来说，prevComponent 为 null if (prevComponent) &#123; var prevWrappedElement = prevComponent._currentElement; var prevElement = prevWrappedElement.props.child; if (shouldUpdateReactComponent(prevElement, nextElement)) &#123; var publicInst = prevComponent._renderedComponent.getPublicInstance(); var updatedCallback = callback &amp;&amp; function() &#123; validateCallback(callback); callback.call(publicInst); &#125;; ReactMount._updateRootComponent( prevComponent, nextWrappedElement, nextContext, container, updatedCallback, ); return publicInst; &#125; else &#123; ReactMount.unmountComponentAtNode(container); &#125; &#125; var reactRootElement = getReactRootElementInContainer(container); var containerHasReactMarkup = reactRootElement &amp;&amp; !!internalGetID(reactRootElement); var containerHasNonRootReactChild = hasNonRootReactChild(container); var shouldReuseMarkup = containerHasReactMarkup &amp;&amp; !prevComponent &amp;&amp; !containerHasNonRootReactChild; var component = ReactMount._renderNewRootComponent( nextWrappedElement, container, shouldReuseMarkup, nextContext, callback, )._renderedComponent.getPublicInstance(); return component; &#125;, 这里有几个方法，分别是： getTopLevelWrapperInContainer shouldUpdateReactComponent _renderNewRootComponent getTopLevelWrapperInContainer这个方法用来拿到现有的顶层容器组件，相关代码如下。function getTopLevelWrapperInContainer(container) &#123; var root = getHostRootInstanceInContainer(container); return root ? root._hostContainerInfo._topLevelWrapper : null;&#125;function getHostRootInstanceInContainer(container) &#123; var rootEl = getReactRootElementInContainer(container); var prevHostInstance = rootEl &amp;&amp; ReactDOMComponentTree.getInstanceFromNode(rootEl); return prevHostInstance &amp;&amp; !prevHostInstance._hostParent ? prevHostInstance : null;&#125; 调用了两个方法，getReactRootElementInContainer 和 ReactDOMComponentTree.getInstanceFromNode. getReactRootElementInContainerfunction getReactRootElementInContainer(container) &#123; if (!container) &#123; return null; &#125; if (container.nodeType === DOCUMENT_NODE) &#123; return container.documentElement; &#125; else &#123; return container.firstChild; &#125;&#125; ReactDOMComponentTree 这个模块有三个方法，分别是： precacheChildNodes 在 DOM 节点上存储相应的 React 实例 getNodeFromInstance 从一个实例上获取到对应的 DOM 节点 getInstanceFromNode 从一个 DOM 节点上获取到对应的实例 shouldUpdateReactComponent判断是否需要更新组件。function shouldUpdateReactComponent(prevElement, nextElement) &#123; var prevEmpty = prevElement === null || prevElement === false; var nextEmpty = nextElement === null || nextElement === false; if (prevEmpty || nextEmpty) &#123; return prevEmpty === nextEmpty; &#125; var prevType = typeof prevElement; var nextType = typeof nextElement; if (prevType === 'string' || prevType === 'number') &#123; return nextType === 'string' || nextType === 'number'; &#125; else &#123; return ( nextType === 'object' &amp;&amp; prevElement.type === nextElement.type &amp;&amp; prevElement.key === nextElement.key ); &#125;&#125; 可以看到逻辑是这样的： 前后两次元素都为 null 返回 true 如果是 textComponent，那么直接更新 否则当为 DOM 元素或者 React 元素时，且 type 和 key 都相同时返回 true, 执行 update ReactMount._renderNewRootComponent这个方法是 _renderSubtreeIntoContainer 的核心，用来把一个新的组件挂载到 DOM 中。_renderNewRootComponent: function( nextElement, container, shouldReuseMarkup, context, callback,) &#123; // 通过 instantiateReactComponent 拿到 React Component 组件实例 var componentInstance = instantiateReactComponent(nextElement, false); if (callback) &#123; componentInstance._pendingCallbacks = [ function() &#123; validateCallback(callback); callback.call( componentInstance._renderedComponent.getPublicInstance(), ); &#125;, ]; &#125; // The initial render is synchronous but any updates that happen during // rendering, in componentWillMount or componentDidMount, will be batched // according to the current batching strategy. ReactUpdates.batchedUpdates( batchedMountComponentIntoNode, componentInstance, container, shouldReuseMarkup, context, ); var wrapperID = componentInstance._instance.rootID; instancesByReactRootID[wrapperID] = componentInstance; return componentInstance;&#125;, instantiateReactComponent根据传入的参数来生成不同的 React Component, 核心代码：if (node === null || node === false) &#123; instance = ReactEmptyComponent.create(instantiateReactComponent);&#125; else if (typeof node === 'object') &#123; var element = node; var type = element.type; if (typeof type !== 'function' &amp;&amp; typeof type !== 'string') &#123; ... &#125; // Special case string values if (typeof element.type === 'string') &#123; instance = ReactHostComponent.createInternalComponent(element); &#125; else if (isInternalComponentType(element.type)) &#123; // This is temporarily available for custom components that are not string // representations. I.e. ART. Once those are updated to use the string // representation, we can drop this code path. instance = new element.type(element); // We renamed this. Allow the old name for compat. :( if (!instance.getHostNode) &#123; instance.getHostNode = instance.getNativeNode; &#125; &#125; else &#123; instance = new ReactCompositeComponentWrapper(element); &#125;&#125; else if (typeof node === 'string' || typeof node === 'number') &#123; instance = ReactHostComponent.createInstanceForText(node);&#125; else &#123; invariant(false, 'Encountered invalid React node of type %s', typeof node);&#125; 从代码中可以看到，根据 element.type 的不同，有三个方法来生成三种不同 React 组件实例，分别为： ReactHostComponent.createInternalComponent(element) new ReactCompositeComponentWrapper(element) ReactHostComponent.createInstanceForText(node); 可能读者会注意到，当 isInternalComponentType(element.type) 成立时， instance = new element.type(element); 的这段代码被我忽略了，那是因为这个是 React 封装的内部组件不是由字符串表达时的解决方法，我们是不用关心的。我们来看上面的三个方法，其中两个方法都调用了 ReactHostComponent 模块。 ReactHostComponent核心代码:var ReactHostComponentInjection = &#123; // This accepts a class that receives the tag string. This is a catch all // that can render any kind of tag. injectGenericComponentClass: function(componentClass) &#123; genericComponentClass = componentClass; &#125;, // This accepts a text component class that takes the text string to be // rendered as props. injectTextComponentClass: function(componentClass) &#123; textComponentClass = componentClass; &#125;,&#125;;function createInternalComponent(element) &#123; invariant( genericComponentClass, 'There is no registered component for the tag %s', element.type, ); return new genericComponentClass(element);&#125;/** * @param &#123;ReactText&#125; text * @return &#123;ReactComponent&#125; */function createInstanceForText(text) &#123; return new textComponentClass(text);&#125; 就是提供了两个方法来创建组件，而其中两个组件 class 的实现是通过其他模块注入进来的，那到底是从哪里注入进来的呢。经过一番查找，发现是在 ReactDOMStackInjection.js 中注入的，我们看一下代码： var ReactComponentEnvironment = require('ReactComponentEnvironment');var ReactComponentBrowserEnvironment = require('ReactComponentBrowserEnvironment');var ReactDOMComponent = require('ReactDOMComponent');var ReactDOMComponentTree = require('ReactDOMComponentTree');var ReactDOMEmptyComponent = require('ReactDOMEmptyComponent');var ReactDOMTextComponent = require('ReactDOMTextComponent');var ReactDefaultBatchingStrategy = require('ReactDefaultBatchingStrategy');var ReactEmptyComponent = require('ReactEmptyComponent');var ReactGenericBatching = require('ReactGenericBatching');var ReactHostComponent = require('ReactHostComponent');var ReactReconcileTransaction = require('ReactReconcileTransaction');var ReactUpdates = require('ReactUpdates');var findDOMNode = require('findDOMNode');var getHostComponentFromComposite = require('getHostComponentFromComposite');ReactGenericBatching.injection.injectStackBatchedUpdates( ReactUpdates.batchedUpdates,);ReactHostComponent.injection.injectGenericComponentClass(ReactDOMComponent);ReactHostComponent.injection.injectTextComponentClass(ReactDOMTextComponent);ReactEmptyComponent.injection.injectEmptyComponentFactory(function( instantiate,) &#123; return new ReactDOMEmptyComponent(instantiate);&#125;);ReactUpdates.injection.injectReconcileTransaction(ReactReconcileTransaction);ReactUpdates.injection.injectBatchingStrategy(ReactDefaultBatchingStrategy);ReactComponentEnvironment.injection.injectEnvironment( ReactComponentBrowserEnvironment,);findDOMNode._injectStack(function(inst) &#123; inst = getHostComponentFromComposite(inst); return inst ? ReactDOMComponentTree.getNodeFromInstance(inst) : null;&#125;); 可以看到，这个模块通过 ReactHostComponent.injection 注入了 ReactDOMComponent 和 ReactDOMTextComponent. 同时也注入了一些其他模块，这个我们后面还会用到。 这里 ReactDOMComponent 和 ReactDOMTextComponent 才是真是的生成 DOM 标记的模块，它们的内容过多，但是代码比较简单了，这里就不细说了。总之调用这两个模块的 mountComponent 方法都会生成 DOM Markup. 不同的地方在于， ReactDOMComponent 会如下结构的 Markup&#123; node: node, children: [], html: null, text: null, toString&#125; 而 ReactDOMTextComponent 会直接生成要渲染在 DOM 里面的 String 类型的文本。 ReactCompositeComponent最后一类组件应该是 ReactCompositeComponentWrapper, 但查看 instantiateReactComponent 里面的这两段代码：var ReactCompositeComponentWrapper = function(element) &#123; this.construct(element);&#125;;Object.assign( ReactCompositeComponentWrapper.prototype, ReactCompositeComponent, &#123; _instantiateReactComponent: instantiateReactComponent, &#125;,); 当调用 this.construct 的时候，还是调用到了 ReactCompositeComponent ,这个就是用户自定义的组件。 ReactUpdates.batchedUpdatesfunction batchedUpdates(callback, a, b, c, d, e) &#123; ensureInjected(); return batchingStrategy.batchedUpdates(callback, a, b, c, d, e);&#125; 可以看到 ReactUpdates 里面是 通过 batchingStrategy 调用 batchedUpdate. 而 batchingStrategy 也是前面说到的 ReactDOMStackInjection 来注入进去的。ReactUpdates.injection.injectReconcileTransaction(ReactReconcileTransaction);ReactUpdates.injection.injectBatchingStrategy(ReactDefaultBatchingStrategy); ReactUpdates 共注入了两个模块，分别是 ReactReconcileTransaction 和 ReactDefaultBatchingStrategy. 先来看一下 ReactDefaultBatchingStrategy, ReactReconcileTransaction 后面碰到再说，来看一下它的代码：var ReactUpdates = require('ReactUpdates');var Transaction = require('Transaction');var emptyFunction = require('fbjs/lib/emptyFunction');var RESET_BATCHED_UPDATES = &#123; initialize: emptyFunction, close: function() &#123; ReactDefaultBatchingStrategy.isBatchingUpdates = false; &#125;,&#125;;var FLUSH_BATCHED_UPDATES = &#123; initialize: emptyFunction, close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates),&#125;;var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];function ReactDefaultBatchingStrategyTransaction() &#123; this.reinitializeTransaction();&#125;Object.assign(ReactDefaultBatchingStrategyTransaction.prototype, Transaction, &#123; getTransactionWrappers: function() &#123; return TRANSACTION_WRAPPERS; &#125;,&#125;);var transaction = new ReactDefaultBatchingStrategyTransaction();var ReactDefaultBatchingStrategy = &#123; isBatchingUpdates: false, /** * Call the provided function in a context within which calls to `setState` * and friends are batched such that components aren't updated unnecessarily. */ batchedUpdates: function(callback, a, b, c, d, e) &#123; var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates; ReactDefaultBatchingStrategy.isBatchingUpdates = true; // The code is written this way to avoid extra allocations if (alreadyBatchingUpdates) &#123; // 如果当前 updates 已经完成，那么直接调用 callback return callback(a, b, c, d, e); &#125; else &#123; // 通过事务的方式去调用 callback return transaction.perform(callback, null, a, b, c, d, e); &#125; &#125;,&#125;; 可以看到我们前面调用的 ReactUpdates.batchUpdates 实际上调用到了这里的 batchedUpdates, 里面的逻辑也很简单。 这里面用到了一个 transaction 方法，这里我理解为“事务”。也就是说当如果当前正在进行一次更新，那么就通过事务的方式去调用这个 callback. transactiontransaction 在 React 源码里面使用非常广泛，作用是通过事务的方式去调用一个方法。 用一个或多个 wrapper 把方法包裹起来，在方法调用前和调用之后依次执行。事务会确保 wrapper 的 initialize 和 close 方法都会执行，无论要执行的方法执行成功或失败报错，看看它的源码解释就很明白了：* &lt;pre&gt;* wrappers (injected at creation time)* + +* | |* +-----------------|--------|--------------+* | v | |* | +---------------+ | |* | +--| wrapper1 |---|----+ |* | | +---------------+ v | |* | | +-------------+ | |* | | +----| wrapper2 |--------+ |* | | | +-------------+ | | |* | | | | | |* | v v v v | wrapper* | +---+ +---+ +---------+ +---+ +---+ | invariants* perform(anyMethod) | | | | | | | | | | | | maintained* +-----------------&gt;|-|---|-|---|--&gt;|anyMethod|---|---|-|---|-|--------&gt;* | | | | | | | | | | | |* | | | | | | | | | | | |* | | | | | | | | | | | |* | +---+ +---+ +---------+ +---+ +---+ |* | initialize close |* +-----------------------------------------+* &lt;/pre&gt; 这里我们再回到刚才的 ReactDefaultBatchingStrategy, 代码里面有两个 wrapper.var RESET_BATCHED_UPDATES = &#123; initialize: emptyFunction, close: function() &#123; ReactDefaultBatchingStrategy.isBatchingUpdates = false; &#125;,&#125;;var FLUSH_BATCHED_UPDATES = &#123; initialize: emptyFunction, close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates),&#125;; 它们的 initialize 方法都是一个空函数，close 方法分别是： 把当前的更新状态置为 false flushBatchedUpdates 这个方法比较复杂，这里不展开讲，主要是确保所有组件能够正确更新（flushBatchedUpdates-&gt;ReactUpdates.runBatchedUpdates-&gt;ReactCompositeComponent.performUpdateIfNecessary） 现在回到上面的代码：ReactUpdates.batchedUpdates( batchedMountComponentIntoNode, componentInstance, container, shouldReuseMarkup, context,); 可以知道，这里是调用了 batchedMountComponentIntoNode 进行后续的工作。function batchedMountComponentIntoNode( componentInstance, container, shouldReuseMarkup, context,) &#123; var transaction = ReactUpdates.ReactReconcileTransaction.getPooled( /* useCreateElement */ !shouldReuseMarkup, ); transaction.perform( mountComponentIntoNode, null, componentInstance, container, transaction, shouldReuseMarkup, context, ); ReactUpdates.ReactReconcileTransaction.release(transaction);&#125; 这里第一条赋值语句就用到了上面注入到 ReactUpdates 里面的另一个模块 ReactReconcileTransaction 即 React 的调度事务模块。var SELECTION_RESTORATION = &#123; initialize: ReactInputSelection.getSelectionInformation, close: ReactInputSelection.restoreSelection,&#125;;/** * Suppresses events (blur/focus) that could be inadvertently dispatched due to * high level DOM manipulations (like temporarily removing a text input from the * DOM). */var EVENT_SUPPRESSION = &#123; initialize: function() &#123; var currentlyEnabled = ReactBrowserEventEmitter.isEnabled(); ReactBrowserEventEmitter.setEnabled(false); return currentlyEnabled; &#125;, close: function(previouslyEnabled) &#123; ReactBrowserEventEmitter.setEnabled(previouslyEnabled); &#125;,&#125;;/** * Provides a queue for collecting `componentDidMount` and * `componentDidUpdate` callbacks during the transaction. */var ON_DOM_READY_QUEUEING = &#123; initialize: function() &#123; this.reactMountReady.reset(); &#125;, close: function() &#123; this.reactMountReady.notifyAll(); &#125;,&#125;;...var TRANSACTION_WRAPPERS = [ SELECTION_RESTORATION, EVENT_SUPPRESSION, ON_DOM_READY_QUEUEING,];function ReactReconcileTransaction(useCreateElement) &#123; this.reinitializeTransaction(); this.renderToStaticMarkup = false; this.reactMountReady = CallbackQueue.getPooled(); this.useCreateElement = useCreateElement;&#125;...var Mixin = &#123; getTransactionWrappers: function() &#123; return TRANSACTION_WRAPPERS; &#125;, ...&#125;Object.assign(ReactReconcileTransaction.prototype, Transaction, Mixin);PooledClass.addPoolingTo(ReactReconcileTransaction); 这里也是通过事务的方式去调用，它有三个 wrapper: Selection Restoration 在更新过程中尽可能不打扰用户的选中范围（selection range） Event Suppression 抑制一些不需要的事件分发，比如暂时性删除一个 input 元素而导致的 blur 事件 On DOM Ready Queueing 在事务执行过程中，提供一个 componentDidMount 和 componentDidUpdate 回调函数的队列 而后面的 getPooled 方法，是一个利用实例池来避免不必要的 GC 的方法，不过多解释。 接着用这个事务的方式去调用 mountComponentIntoNode, 详细的看一下这个方法。 mountComponentIntoNodefunction mountComponentIntoNode( wrapperInstance, container, transaction, shouldReuseMarkup, context,) &#123; var markup = ReactReconciler.mountComponent( wrapperInstance, transaction, null, ReactDOMContainerInfo(wrapperInstance, container), context, 0 /* parentDebugID */, ); wrapperInstance._renderedComponent._topLevelWrapper = wrapperInstance; ReactMount._mountImageIntoNode( markup, container, wrapperInstance, shouldReuseMarkup, transaction, );&#125; 这里看到了重点变量 markup 的操作, 这个就是我们最终要往 DOM 里面渲染的对象。通过 ReactReconciler.mountComponent 方法来得到 markup. ReactReconciler.mountComponent 的源码如下：mountComponent: function( internalInstance, transaction, hostParent, hostContainerInfo, context, parentDebugID, // 0 in production and for roots) &#123; var markup = internalInstance.mountComponent( transaction, hostParent, hostContainerInfo, context, parentDebugID, ); if ( internalInstance._currentElement &amp;&amp; internalInstance._currentElement.ref != null ) &#123; transaction.getReactMountReady().enqueue(attachRefs, internalInstance); &#125; return markup;&#125;, 它又调用了 internalInstance.mountComponent, 这里的 internalInstance 其实就是前面说的通过 instantiateReactComponent 得到的 React Component 实例。// _renderNewRootComponentvar componentInstance = instantiateReactComponent(nextElement, false) 这里的 nextElement 是要渲染的 React root 元素。// _renderSubtreeIntoContainer var nextWrappedElement = React.createElement(TopLevelWrapper, &#123; child: nextElement, &#125;); TopLevelWrapper 的实现，需要注意它的 render 方法。var TopLevelWrapper = function() &#123; this.rootID = topLevelRootCounter++;&#125;;TopLevelWrapper.prototype.isReactComponent = &#123;&#125;;TopLevelWrapper.prototype.render = function() &#123; return this.props.child;&#125;;TopLevelWrapper.isReactTopLevelWrapper = true; 它的 render 方法里面返回的 this.props.child 就是 nextElement 也就是我们项目代码里面入口 ReactDOM.render(&lt;App/&gt;,document.getElementById(&#39;root&#39;)) 里面的 &lt;App/&gt;. 回到 ReactReconciler.mountComponent 里面的 internalInstance.mountComponent. 通过前面的讲到的 instantiateReactComponent 我们知道返回的组件有三类： ReactDOMComponent ReactDOMTextComponent ReactCompositeComponent 前两类很简单，都是 DOM 本身的元素，最终会渲染出来它们对应的 Markup. 而 ReactCompositeComponent 比较复杂，我们只看关键代码：//ReactCompositeComponent.mountComponent var Component = this._currentElement.type; var updateQueue = transaction.getUpdateQueue(); // Initialize the public class var doConstruct = shouldConstruct(Component); var inst = this._constructComponent( doConstruct, publicProps, publicContext, updateQueue, ); var renderedElement; if (!doConstruct &amp;&amp; (inst == null || inst.render == null)) &#123; renderedElement = inst; inst = new StatelessComponent(Component); this._compositeType = ReactCompositeComponentTypes.StatelessFunctional; &#125; else &#123; 。... &#125; markup = this.performInitialMount( renderedElement, hostParent, hostContainerInfo, transaction, context, ); 首先得到 inst , 得到 inst 的调用栈是这样的： this._constructComponent -&gt; this._constructComponentWithoutOwner// this._constructComponentWithoutOwner... var Component = this._currentElement.type; if (doConstruct) &#123; if (__DEV__) &#123; return measureLifeCyclePerf( () =&gt; new Component(publicProps, publicContext, updateQueue), this._debugID, 'ctor', ); &#125; else &#123; return new Component(publicProps, publicContext, updateQueue); &#125; &#125;... 根据 _currentElement.type 生成 Component 实例, currentElement.type 即就是继承自 React.Component 的 class 或者纯渲染组件 function.然后声明 renderElement, 对于 stateless (函数声明的纯渲染组件)组件，renderElement = inst, 否则为 undefined. 接着来看 performInitialMount, if (renderedElement === undefined) &#123; renderedElement = this._renderValidatedComponent();&#125;var nodeType = ReactNodeTypes.getType(renderedElement);this._renderedNodeType = nodeType;var child = this._instantiateReactComponent( renderedElement, nodeType !== ReactNodeTypes.EMPTY /* shouldHaveDebugID */,);this._renderedComponent = child;var markup = ReactReconciler.mountComponent( child, transaction, hostParent, hostContainerInfo, this._processChildContext(context), debugID,); 对于非 stateless 组件时，需要对 renderedElement 赋值。调用栈为： this._renderValidatedComponent -&gt; this._renderValidatedComponentWithoutOwnerOrContext_renderValidatedComponentWithoutOwnerOrContext: function() &#123; var inst = this._instance; var renderedElement; if (__DEV__) &#123; renderedElement = measureLifeCyclePerf( () =&gt; inst.render(), this._debugID, 'render', ); &#125; else &#123; renderedElement = inst.render(); &#125; if (__DEV__) &#123; // We allow auto-mocks to proceed as if they're returning null. if (renderedElement === undefined &amp;&amp; inst.render._isMockFunction) &#123; // This is probably bad practice. Consider warning here and // deprecating this convenience. renderedElement = null; &#125; &#125; return renderedElement;&#125;, 最终得到 renderedElement 也就是 inst.render() 后的结果。 再往下走 child = this._instantiateReactComponent(renderedElement) 和 markup = ReactReconciler.mountComponent(child,...) . 可以联想到，这里会不断的循环递归调用 ReactReconciler.mountComponent, 知道 child 不是 ReactCompositeComponent 为止，得到最终的 MarkUp. MarkUp 的数据结构可以在 DOMLazyTree 中找到：// DOMLazyTree&#123; node: node, children: [], html: null, text: null, toString,&#125; 拿到了 MarkUp，就只剩下最后一步了，通过 ReactMount._mountImageIntoNode 来吧 MarkUp 挂载到实际 DOM 中。 ReactMount._mountImageIntoNode_mountImageIntoNode: function( markup, container, instance, shouldReuseMarkup, transaction,) &#123; invariant( isValidContainer(container), 'mountComponentIntoNode(...): Target container is not valid.', ); // 首次渲染，这里为 shouldReuseMarkup = false ，里面都是更新的逻辑 if (shouldReuseMarkup) &#123; ... &#125; // 首次渲染，transaction.useCreateElement = true if (transaction.useCreateElement) &#123; while (container.lastChild) &#123; container.removeChild(container.lastChild); &#125; DOMLazyTree.insertTreeBefore(container, markup, null); &#125; else &#123; setInnerHTML(container, markup); ReactDOMComponentTree.precacheNode(instance, container.firstChild); &#125;&#125;, 逻辑很简单，有两种方式把 markup 渲染到 DOM 中： 清空给定的容器组件，然后把 markup 插入到给定的容器中 调用 setInnerHTML 来把 markup 插入到给定容器中，并缓存虚拟 DOM 到实际的 DOM 节点上 对于初次渲染， 会执行第一种方法，清空容器组件，把 markup 挂载到实际的 DOM 中。调用栈：DOMLazyTree.insertTreeBefore -&gt; insertTreeChildrenfunction insertTreeChildren(tree) &#123; if (!enableLazy) &#123; return; &#125; var node = tree.node; var children = tree.children; if (children.length) &#123; for (var i = 0; i &lt; children.length; i++) &#123; insertTreeBefore(node, children[i], null); &#125; &#125; else if (tree.html != null) &#123; setInnerHTML(node, tree.html); &#125; else if (tree.text != null) &#123; setTextContent(node, tree.text); &#125;&#125; 递归的挂载所有子组件到 DOM 中。 总结那么到这里整个初次渲染的逻辑就算走完了，整体上可以看到 React 和 ReactDOM 的代码抽象程度非常高，以至于代码阅读起来非常的绕。本文也只限于整体的流程，没有深究细节，因为细节太多了。 最后整理了一个 ReactDOM.render 执行后流程关系图，能一定程度上帮助理解它的整过过程：图很大，点击放大后也看不清，建议保存到本地后浏览，会看的清晰点。 相关文章 React 源码浅析之 - 入口文件 React 源码浅析之 - ReactBaseClasses React 源码浅析之 - ReactChildren React 源码浅析之 - ReactElement React 源码浅析之 - onlyChildren]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React 源码浅析之 - onlyChildren]]></title>
    <url>%2F2017%2F09%2F20%2Freact-source-code-analyze-5%2F</url>
    <content type="text"><![CDATA[这个模块的代码非常简单，短短十几行。 var ReactElement = require('ReactElement');var invariant = require('fbjs/lib/invariant');function onlyChild(children) &#123; invariant( ReactElement.isValidElement(children), 'React.Children.only expected to receive a single React element child.', ); return children;&#125;module.exports = onlyChild; 就是判断传入的 children 是不是一个合法的 React 元素，否则就抛错出来。判断的逻辑就在 ReactElement 模块里面：ReactElement.isValidElement = function(object) &#123; return ( typeof object === 'object' &amp;&amp; object !== null &amp;&amp; object.$$typeof === REACT_ELEMENT_TYPE );&#125;; 总结那么到这里为止，所有 React 本身提供的 API 和模块就算是看完了。但是光看 React 本身的这些代码，其实并不能解决什么问题，比如 React Component 的生命周期是怎么实现的， setState 是怎么运作的，以及是如何把 React Component 渲染到浏览器中的，还有很多问题。有机会我会继续寻找这些答案。 相关文章 React 源码浅析之 - 入口文件 React 源码浅析之 - ReactBaseClasses React 源码浅析之 - ReactChildren React 源码浅析之 - ReactElement React 源码浅析之 - onlyChildren]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React 源码浅析之 - ReactElement]]></title>
    <url>%2F2017%2F09%2F20%2Freact-source-code-analyze-4%2F</url>
    <content type="text"><![CDATA[ReactElement这个模块定义了 React 元素的行为和方法，首先看 ReactElement 函数： ReactElementvar ReactElement = function(type, key, ref, self, source, owner, props) &#123; var element = &#123; // This tag allow us to uniquely identify this as a React Element $$typeof: REACT_ELEMENT_TYPE, // Built-in properties that belong on the element type: type, key: key, ref: ref, props: props, // Record the component responsible for creating this element. _owner: owner, &#125;; if (__DEV__) &#123; // The validation flag is currently mutative. We put it on // an external backing store so that we can freeze the whole object. // This can be replaced with a WeakMap once they are implemented in // commonly used development environments. element._store = &#123;&#125;; // To make comparing ReactElements easier for testing purposes, we make // the validation flag non-enumerable (where possible, which should // include every environment we run tests in), so the test framework // ignores it. Object.defineProperty(element._store, 'validated', &#123; configurable: false, enumerable: false, writable: true, value: false, &#125;); // self and source are DEV only properties. Object.defineProperty(element, '_self', &#123; configurable: false, enumerable: false, writable: false, value: self, &#125;); // Two elements created in two different places should be considered // equal for testing purposes and therefore we hide it from enumeration. Object.defineProperty(element, '_source', &#123; configurable: false, enumerable: false, writable: false, value: source, &#125;); if (Object.freeze) &#123; Object.freeze(element.props); Object.freeze(element); &#125; &#125; return element;&#125;; 抛去其中 DEV 里面的内容，其他部分很简单，定义了一个 React 元素应有属性。包括： type, key, ref, self, source, owner, props.还有一个 $$typeof 属性，是一个常量，用来判断这个对象是不是一个 React 元素。var REACT_ELEMENT_TYPE = (typeof Symbol === 'function' &amp;&amp; Symbol.for &amp;&amp; Symbol.for('react.element')) || 0xeac7; ReactElement.createElementReactElement.createElement = function(type, config, children) &#123; var propName; // Reserved names are extracted var props = &#123;&#125;; var key = null; var ref = null; var self = null; var source = null; if (config != null) &#123; // ref 和 key 都属于保留 props key 值，所以这里需要做判断 if (hasValidRef(config)) &#123; ref = config.ref; &#125; if (hasValidKey(config)) &#123; key = '' + config.key; &#125; // __self 和 __source 这两个属性目前没有看到他们的作用，先放着 self = config.__self === undefined ? null : config.__self; source = config.__source === undefined ? null : config.__source; // Remaining properties are added to a new props object // 其他的属性添加到新的 props 对象上，同时需要排除掉保留字段 RESERVED_PROPS // var RESERVED_PROPS = &#123;key: true, ref: true, __self: true, __source: true,&#125;; for (propName in config) &#123; if ( hasOwnProperty.call(config, propName) &amp;&amp; !RESERVED_PROPS.hasOwnProperty(propName) ) &#123; props[propName] = config[propName]; &#125; &#125; &#125; // Children 可以传递一个以上的参数，这些 children 参数都会作为新分配的 props 的属性 var childrenLength = arguments.length - 2; if (childrenLength === 1) &#123; props.children = children; &#125; else if (childrenLength &gt; 1) &#123; var childArray = Array(childrenLength); for (var i = 0; i &lt; childrenLength; i++) &#123; childArray[i] = arguments[i + 2]; &#125; if (__DEV__) &#123; if (Object.freeze) &#123; Object.freeze(childArray); &#125; &#125; props.children = childArray; &#125; // 设置 defaultProps 属性 if (type &amp;&amp; type.defaultProps) &#123; var defaultProps = type.defaultProps; for (propName in defaultProps) &#123; if (props[propName] === undefined) &#123; props[propName] = defaultProps[propName]; &#125; &#125; &#125; // 开发环境下，如果使用了保留字段 key 和 ref ，那么进行控制台报错提醒 if (__DEV__) &#123; if (key || ref) &#123; if ( typeof props.$$typeof === 'undefined' || props.$$typeof !== REACT_ELEMENT_TYPE ) &#123; var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type; if (key) &#123; defineKeyPropWarningGetter(props, displayName); &#125; if (ref) &#123; defineRefPropWarningGetter(props, displayName); &#125; &#125; &#125; &#125; // 返回一个 React 元素， ReactCurrentOwner.current 是指当前正处于构建过程中的组件，这里默认是 null return ReactElement( type, key, ref, self, source, ReactCurrentOwner.current, props, );&#125;; 用给定的参数来创建一个 React 元素，需要注意的是 ref 和 key 属于保留字段，不能作为 props 的属性传递。 ReactElement.createFactory一个简单的工厂函数，用来方便的创建同类型的组件。ReactElement.createFactory = function(type) &#123; var factory = ReactElement.createElement.bind(null, type); // Expose the type on the factory and the prototype so that it can be // easily accessed on elements. E.g. `&lt;Foo /&gt;.type === Foo`. // This should not be named `constructor` since this may not be the function // that created the element, and it may not even be a constructor. // Legacy hook TODO: Warn if this is accessed factory.type = type; return factory;&#125;; ReactElement.cloneAndReplaceKey这个 API 没用过，可以用来替换一个 React 元素的保留属性： key 值。ReactElement.cloneAndReplaceKey = function(oldElement, newKey) &#123; var newElement = ReactElement( oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props, ); return newElement;&#125;; ReactElement.cloneElementcloneElement 方法和 createElement 基本一样，只是前者是通过现有的 React 元素来复制一个新的元素出来。 ReactElement.isValidElement用来判断一个对象是不是一个合法的 React 元素。ReactElement.isValidElement = function(object) &#123; return ( typeof object === 'object' &amp;&amp; object !== null &amp;&amp; object.$$typeof === REACT_ELEMENT_TYPE );&#125;; 用到了上面一开始定义的 $$typeof 属性。 exportmodule.exports = ReactElement; ReactElement 模块就是这么些东西了，主要定义了一个 React 元素应有的属性，以及操作元素的一些方法。 相关文章 React 源码浅析之 - 入口文件 React 源码浅析之 - ReactBaseClasses React 源码浅析之 - ReactChildren React 源码浅析之 - ReactElement React 源码浅析之 - onlyChildren]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React 源码浅析之 - ReactChildren]]></title>
    <url>%2F2017%2F09%2F20%2Freact-source-code-analyze-3%2F</url>
    <content type="text"><![CDATA[引入的模块var ReactElement = require('ReactElement');var emptyFunction = require('fbjs/lib/emptyFunction');var invariant = require('fbjs/lib/invariant'); 我们来看一下 ReactElement 模块，其他两个都是工具函数，不用关心。 Export 的对象var ReactChildren = &#123; forEach: forEachChildren, map: mapChildren, count: countChildren, toArray: toArray,&#125;;module.exports = ReactChildren; 依次来看一下这个四个 API forEachfunction forEachChildren(children, forEachFunc, forEachContext) &#123; if (children == null) &#123; return children; &#125; var traverseContext = getPooledTraverseContext( null, null, forEachFunc, forEachContext, ); traverseAllChildren(children, forEachSingleChild, traverseContext); releaseTraverseContext(traverseContext);&#125; 入参： children, forEachFunc, forEachContext.首先通过 getPooledTraverseContext 拿到一个遍历的上下文对象 traverseContext，然后调用 traverseAllChildren 方法来遍历所有传入 children 的后代节点。最后释放当前的 traverseContext. getPooledTraverseContextvar POOL_SIZE = 10;var traverseContextPool = [];function getPooledTraverseContext( mapResult, keyPrefix, mapFunction, mapContext,) &#123; if (traverseContextPool.length) &#123; var traverseContext = traverseContextPool.pop(); traverseContext.result = mapResult; traverseContext.keyPrefix = keyPrefix; traverseContext.func = mapFunction; traverseContext.context = mapContext; traverseContext.count = 0; return traverseContext; &#125; else &#123; return &#123; result: mapResult, keyPrefix: keyPrefix, func: mapFunction, context: mapContext, count: 0, &#125;; &#125;&#125; 定义了一个 traverseContextPool 以避免每次重新创建新对象的成本，大小为 10. getPooledTraverseContext 方法接收四个参数，mapResult, keyPrefix, mapFunction, mapContext.然后赋值到 traverseContext 上，除此之外还添加了一个计数器属性 count. traverseAllChildrenfunction traverseAllChildren(children, callback, traverseContext) &#123; if (children == null) &#123; return 0; &#125; return traverseAllChildrenImpl(children, '', callback, traverseContext);&#125; `traverseAllChildren` 只是个空壳，里面的 `traverseAllChildrenImpl` 才是真正的实现。** traverseAllChildrenImpl ** function traverseAllChildrenImpl( children, nameSoFar, callback, traverseContext,) &#123; var type = typeof children; if (type === 'undefined' || type === 'boolean') &#123; // All of the above are perceived as null. children = null; &#125; if ( children === null || type === 'string' || type === 'number' || // The following is inlined from ReactElement. This means we can optimize // some checks. React Fiber also inlines this logic for similar purposes. (type === 'object' &amp;&amp; children.$$typeof === REACT_ELEMENT_TYPE) ) &#123; callback( traverseContext, children, // If it's the only child, treat the name as if it was wrapped in an array // so that it's consistent if the number of children grows. nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar, ); return 1; &#125; 接收四个参数，首先判断 children 参数的 type ，不合法都认为 children 是 null.紧接着的一堆判断，就是说当 children 是单个合法 React 元素的时候，执行 callback 函数，并返回 1，因为后面会递归的调用当前这个函数，所以这里也是递归调用的出口。var child;var nextName;var subtreeCount = 0; // Count of children found in the current subtree.var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;if (Array.isArray(children)) &#123; for (var i = 0; i &lt; children.length; i++) &#123; child = children[i]; nextName = nextNamePrefix + getComponentKey(child, i); subtreeCount += traverseAllChildrenImpl( child, nextName, callback, traverseContext, ); &#125;&#125; else &#123; 当传入的 children 是一个 Array 的时候，遍历这个 Children Array ， 并对里面的每个元素调用当前的函数 traverseAllChildrenImpl.传入的参数中需要注意， nextName 用来给要遍历的 React 元素添加 key 值，callback 和 traverseContext 和当前函数的值都是一样的，保证了每个子元素也能应用当前的 callback 且能访问到原始的 traverseContext.&#125; else &#123; var iteratorFn = (ITERATOR_SYMBOL &amp;&amp; children[ITERATOR_SYMBOL]) || children[FAUX_ITERATOR_SYMBOL]; if (typeof iteratorFn === 'function') &#123; if (__DEV__) &#123; // Warn about using Maps as children if (iteratorFn === children.entries) &#123; warning( didWarnAboutMaps, 'Using Maps as children is unsupported and will likely yield ' + 'unexpected results. Convert it to a sequence/iterable of keyed ' + 'ReactElements instead.%s', getStackAddendum(), ); didWarnAboutMaps = true; &#125; &#125; var iterator = iteratorFn.call(children); var step; var ii = 0; while (!(step = iterator.next()).done) &#123; child = step.value; nextName = nextNamePrefix + getComponentKey(child, ii++); subtreeCount += traverseAllChildrenImpl( child, nextName, callback, traverseContext, ); &#125; &#125; else if (type === 'object') &#123; var addendum = ''; if (__DEV__) &#123; addendum = ' If you meant to render a collection of children, use an array ' + 'instead.' + getStackAddendum(); &#125; var childrenString = '' + children; invariant( false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys &#123;' + Object.keys(children).join(', ') + '&#125;' : childrenString, addendum, ); &#125;&#125; 当不是 Array 但是一个可迭代的对象的时候，和上面一样，递归调用 traverseAllChildrenImpl 方法。对于其他情况，认为 child 不合法，进行报错。 return subtreeCount;&#125; 最后返回所有后代元素的数量。整体上来看 traverseAllChildrenImpl 方法的作用就是，遍历给定 children 的所有后代元素，在每个后代元素上调用 callback 方法，并给每个元素分配一个当前上下文下唯一的 key 值作为参数要传入的参数。 回到 forEach 方法：traverseAllChildren(children, forEachSingleChild, traverseContext); 这一句就是说遍历给定 children 的所有后代元素，并给它们调用 forEachSingleChild 方法。function forEachSingleChild(bookKeeping, child, name) &#123; var &#123;func, context&#125; = bookKeeping; func.call(context, child, bookKeeping.count++);&#125; 这个传入的 callback 方法 forEachSingleChild 就是从入参 bookKeeping 也就是 traverseContext 中拿到 func 和 context，把 context 作为 func 的上下文， child 和计数器 count 作为参数进行调用。这里的 func 就是 forEachChildren 的入参 forEachFunc，也就是需用最终用户提供的函数。releaseTraverseContext(traverseContext); 释放当前的 traverseContext 也就是把 traverseContext 的属性都置为 null 并放入 traverseContextPool 中供后续使用，提高使用效率。function releaseTraverseContext(traverseContext) &#123; traverseContext.result = null; traverseContext.keyPrefix = null; traverseContext.func = null; traverseContext.context = null; traverseContext.count = 0; if (traverseContextPool.length &lt; POOL_SIZE) &#123; traverseContextPool.push(traverseContext); &#125;&#125; mapfunction mapChildren(children, func, context) &#123; if (children == null) &#123; return children; &#125; var result = []; mapIntoWithKeyPrefixInternal(children, result, null, func, context); return result;&#125; 给传入 children 的后代元素调用 func 并返回调用 func 的结果集合。 mapIntoWithKeyPrefixInternalfunction mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) &#123; var escapedPrefix = ''; if (prefix != null) &#123; escapedPrefix = escapeUserProvidedKey(prefix) + '/'; &#125; var traverseContext = getPooledTraverseContext( array, escapedPrefix, func, context, ); traverseAllChildren(children, mapSingleChildIntoContext, traverseContext); releaseTraverseContext(traverseContext);&#125; 首先，如果传入了 prefix ，那么转义 prefix 作为 traverseContext 的 prefix key.然后拿到一个 traverseContext 对象，接着和 forEachChildren 一样，遍历所有 children 的后代元素并执行给定的 callback 函数，最后对 traverseContext 进行释放。 唯一的不同就是这个 callback 方法：mapSingleChildIntoContext . mapSingleChildIntoContextfunction mapSingleChildIntoContext(bookKeeping, child, childKey) &#123; var &#123;result, keyPrefix, func, context&#125; = bookKeeping; var mappedChild = func.call(context, child, bookKeeping.count++); if (Array.isArray(mappedChild)) &#123; mapIntoWithKeyPrefixInternal( mappedChild, result, childKey, emptyFunction.thatReturnsArgument, ); &#125; else if (mappedChild != null) &#123; if (ReactElement.isValidElement(mappedChild)) &#123; mappedChild = ReactElement.cloneAndReplaceKey( mappedChild, // Keep both the (mapped) and old keys if they differ, just as // traverseAllChildren used to do for objects as children keyPrefix + (mappedChild.key &amp;&amp; (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey, ); &#125; result.push(mappedChild); &#125;&#125; 这个方法和上面的 forEachSingleChildren 很像。从 bookKeeping 上拿到 result , keyPrefix, func, context.Result 其实就是 mapChildren 里面一开始定义的空数组， keyPrefix 就是 mapIntoWithKeyPrefixInternal 里面 escapedPrefix ， func 和 context 都是 mapChildren 对应的入参。 首先定义 mappedChild 为用户传入的 mapFunc 函数调用的返回值，然后判断这个返回值 mappedChild 是不是一个 Array.如果是，那么循环调用 mapIntoWithKeyPrefixInternal 方法；否则在不为 null 的情况且是一个合法 React 元素的时候，用一个通过 keyPrefix , 用户分配的 key 即 mappedChild.key 和原有的 childkey 组成新 key 值的 mappedChild 的克隆元素作为 map 的结果，push 到 result 中。 整个 mapChildren 方法，就是对提供的 children 的每个后代元素调用 mapFunc 方法，给返回的结果设置新的 key ，最后把每一个执行的结果 mappedChild 放入到一个列表中返回给用户。 countChildrenfunction countChildren(children, context) &#123; return traverseAllChildren(children, emptyFunction.thatReturnsNull, null);&#125; 这个就很简单了，只是通过遍历返回所有后代节点的个数。emptyFunction.thatReturnsNull就是一个返回为 null 的函数。 toArrayfunction toArray(children) &#123; var result = []; mapIntoWithKeyPrefixInternal( children, result, null, emptyFunction.thatReturnsArgument, ); return result;&#125; 理解了上面的 mapIntoWithKeyPrefixInternal ，那么这里也很简单了。emptyFunction.thatReturnsArgument, 是一个函数，会返回它的第一个参数。 mapSingleChildIntoContext var mappedChild=func.call(context,child,bookKeeping.count++); 那么这句也就是返回 child 本身了。并将结果放入到 result 里面, 最后把所有的 result 返回给调用方。 总结ReactChildren 有四个 API ，而这四个 API 主要依赖与两个方法，traverseAllChildrenImpl 和 mapSingleChildIntoContext 其他方法都是在此之上的组合调用。还有一个值得注意的地方，就是用到对象池 traverseContextPool 。个人认为是因为在这里经常会递归调用而频繁的需要新建 traverseContext 对象，而每次都重新新建对象需要在堆里面重新分配内存，成本比较高，所以引入了对象池，以提高性能。 相关文章 React 源码浅析之 - 入口文件 React 源码浅析之 - ReactBaseClasses React 源码浅析之 - ReactChildren React 源码浅析之 - ReactElement React 源码浅析之 - onlyChildren]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React 源码浅析之 - ReactBaseClasses]]></title>
    <url>%2F2017%2F09%2F20%2Freact-source-code-analyze-2%2F</url>
    <content type="text"><![CDATA[引入的模块var ReactNoopUpdateQueue = require('ReactNoopUpdateQueue');var emptyObject = require('fbjs/lib/emptyObject');var invariant = require('fbjs/lib/invariant');var lowPriorityWarning = require('lowPriorityWarning'); 其中， ReactNoopUpdateQueue 是默认的 updater ，用来提供 update, replaceState, setState 的入队操作，但可能是由于是默认 updater 的原因，只提供了 API 和对入参的校验，但没有提供实际的功能。比如：enqueueSetState: function( // 需要 render 的实例 publicInstance, // 接下来要 merge 的 state partialState, // 可选参数，setState 组件 update 后的回调 callback, // 可选参数，调用函数的的名字 callerName,) &#123; warnNoop(publicInstance, 'setState');&#125;, 其余几个模块是一些通用辅助模块，就不细说了。 Export 的对象module.exports = &#123; Component: ReactComponent, PureComponent: ReactPureComponent, AsyncComponent: ReactAsyncComponent,&#125;; 我们依次来看这几个 Component . ReactComponent/** * Base class helpers for the updating state of a component. */function ReactComponent(props, context, updater) &#123; this.props = props; this.context = context; this.refs = emptyObject; // We initialize the default updater but the real one gets injected by the // renderer. this.updater = updater || ReactNoopUpdateQueue;&#125;ReactComponent.prototype.isReactComponent = &#123;&#125;; 用来创建基础组件的构造函数，其中 refs 默认是一个空对象，而 updater 默认就是我们上面说的 ReactNoopUpdateQueue. setStateReactComponent.prototype.setState = function(partialState, callback) &#123; invariant( typeof partialState === 'object' || typeof partialState === 'function' || partialState == null, 'setState(...): takes an object of state variables to update or a ' + 'function which returns an object of state variables.', ); this.updater.enqueueSetState(this, partialState, callback, 'setState');&#125;; 给它添加 setState 方法，实际操作就是把下一个要设置的 state 放入到更新队列里面。注释中提到： 永远使用 setState 这个方法去更改 state ，你应该认为 this.state 是不可变的 不保证 this.state 会及时更新，也就是说调用 this.state 可能拿到的还是旧的 state 不保证 setState 会同步调用，有可能会把几个 setState 的调用一次性批量更新掉，一定要在某个 setState 的调用完成后执行-操作，可以提供可选的 callback 函数。 当一个 callback 函数传入给 setState 的时候，它会在未来的某个时机调用。会用最新的组件参数 (state, props, context). 而这些参数和此时组件本身的 this.* 上的参数值可能会不一样，应为 callback 函数有可能在 receiveProps 之后 shouldComponentUpdate 之前调用，而此时这个新的 state, props 和 context 还没有赋值给 this. 其核心思想就是说， setState 的调用是异步的，从代码 this.updater.enqueueSetState(this, partialState, callback, &#39;setState&#39;); 中可以看到，只是把要更新的 state 放入到了更新队列里面，而不是直接进行 state 的更新。 forceUpdateReactComponent.prototype.forceUpdate = function(callback) &#123; this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');&#125;; 一个强制更新的方法，这个方法不会触发 shoudleComponentUpdate ，但是会正常调用 componentWillUpdate 和 componentDidUpdate .要确保调用这个方法的时候，所有的 DOM 事务操作已经完成。只有在当你知道一个组件的深层次的 state 变化了，但是并没有调用 setState 的时候才需要调用这个方法。 不推荐的方法/** * Deprecated APIs. These APIs used to exist on classic React classes but since * we would like to deprecate them, we're not going to move them over to this * modern base class. Instead, we define a getter that warns if it's accessed. */if (__DEV__) &#123; var deprecatedAPIs = &#123; isMounted: [ 'isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.', ], replaceState: [ 'replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).', ], &#125;; var defineDeprecationWarning = function(methodName, info) &#123; Object.defineProperty(ReactComponent.prototype, methodName, &#123; get: function() &#123; lowPriorityWarning( false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1], ); return undefined; &#125;, &#125;); &#125;; for (var fnName in deprecatedAPIs) &#123; if (deprecatedAPIs.hasOwnProperty(fnName)) &#123; defineDeprecationWarning(fnName, deprecatedAPIs[fnName]); &#125; &#125;&#125; 这里可以看到 isMounted 和 replaceState 这两个方法，已经被官方认为将要废弃的 API ，在开发过程中应该尽量避免使用它们。 PureComponentfunction ReactPureComponent(props, context, updater) &#123; // Duplicated from ReactComponent. this.props = props; this.context = context; this.refs = emptyObject; // We initialize the default updater but the real one gets injected by the // renderer. this.updater = updater || ReactNoopUpdateQueue;&#125;function ComponentDummy() &#123;&#125;ComponentDummy.prototype = ReactComponent.prototype;var pureComponentPrototype = (ReactPureComponent.prototype = new ComponentDummy());pureComponentPrototype.constructor = ReactPureComponent;// Avoid an extra prototype jump for these methods.Object.assign(pureComponentPrototype, ReactComponent.prototype);pureComponentPrototype.isPureReactComponent = true; 一个典型 js 实现继承的方式，可以看到 PureComponent 继承自 ReactComponent ，PureComponent 拥有 ReactComponent 的所有属性和方法，并在此基础上多了一个属性：pureComponentPrototype.isPureReactComponent = true; 后面在组件更新部分会用到这个属性。 AsyncComponent这个组件在我实际开发过程中还没有用到过，我们来看一下：function ReactAsyncComponent(props, context, updater) &#123; // Duplicated from ReactComponent. this.props = props; this.context = context; this.refs = emptyObject; // We initialize the default updater but the real one gets injected by the // renderer. this.updater = updater || ReactNoopUpdateQueue;&#125;var asyncComponentPrototype = (ReactAsyncComponent.prototype = new ComponentDummy());asyncComponentPrototype.constructor = ReactAsyncComponent;// Avoid an extra prototype jump for these methods.Object.assign(asyncComponentPrototype, ReactComponent.prototype);asyncComponentPrototype.unstable_isAsyncReactComponent = true;asyncComponentPrototype.render = function() &#123; return this.props.children;&#125;; 和 PureComponent 一样，同样继承自 ReactComponent. 再次基础上添加了unstable_isAsyncReactComponent 属性，并设置了 render 方法为直接返回它的 children. 从新添加的属性名可以看到，这是一个还没有稳定下来的特性组件。从名字和内容初步判断是用来创建异步的组件，先用一个 React 组件占位，当 props 传入 children 的时候，在进行渲染，从 render 方法直接 return 可以猜到这样可以实现无多余嵌套 html 标签的组件。 总结这个模块定义了 React 中会用到的三个基础组件类，需要注意的是： 1. State 应该被看作是 immutable 的，所有的对 state 的修改只能通过 setState 来完成，不能使用 `this.state = **` 来进行 state 的更新 2. setState 是一个异步的操作，所以在调用 setState 后从 this.state 上直接取值可能不是你期望的结果，读取的结果有可能依旧是老的 state 而组件内部的 updater 逻辑，这个模块里面并没有定义具体的执行逻辑。比如调用 setState 后会对要更新的 state 进行入队操作，那么这个操作过程中发生了什么，究竟是如何进行批量的更新的，以及什么时候 state 才会更新完毕，那就需要从其他的模块里来寻找答案了。 相关文章 React 源码浅析之 - 入口文件 React 源码浅析之 - ReactBaseClasses React 源码浅析之 - ReactChildren React 源码浅析之 - ReactElement React 源码浅析之 - onlyChildren]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React 源码浅析之 - 入口文件]]></title>
    <url>%2F2017%2F09%2F20%2Freact-source-code-analyze-1%2F</url>
    <content type="text"><![CDATA[本系列文章以 react 最新的版本： 16.0.0-beta.5 为准。首先我们入口文件 ReactEntry.js 来看，var ReactBaseClasses = require('ReactBaseClasses');var ReactChildren = require('ReactChildren');var ReactElement = require('ReactElement');var ReactVersion = require('ReactVersion');var onlyChild = require('onlyChild'); 依赖模块： • ReactBaseClasses • ReactChildren • ReactElement • onlyChild • ReactElementValidator接着:var createElement = ReactElement.createElement;var createFactory = ReactElement.createFactory;var cloneElement = ReactElement.cloneElement;if (__DEV__) &#123; var ReactElementValidator = require('ReactElementValidator'); createElement = ReactElementValidator.createElement; createFactory = ReactElementValidator.createFactory; cloneElement = ReactElementValidator.cloneElement;&#125; 可以看到在开发环境下提供了对组件的验证。var React = &#123; Children: &#123; map: ReactChildren.map, forEach: ReactChildren.forEach, count: ReactChildren.count, toArray: ReactChildren.toArray, only: onlyChild, &#125;, Component: ReactBaseClasses.Component, PureComponent: ReactBaseClasses.PureComponent, unstable_AsyncComponent: ReactBaseClasses.AsyncComponent, createElement: createElement, cloneElement: cloneElement, isValidElement: ReactElement.isValidElement, createFactory: createFactory, version: ReactVersion, __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: &#123; ReactCurrentOwner: require('ReactCurrentOwner'), &#125;,&#125;; 上面这些就是 React 提供的所有 API 了。我会在后续的文章依次对这些 API 的实现进行解读。 相关文章 React 源码浅析之 - 入口文件 React 源码浅析之 - ReactBaseClasses React 源码浅析之 - ReactChildren React 源码浅析之 - ReactElement React 源码浅析之 - onlyChildren]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网易一年工作总结]]></title>
    <url>%2F2017%2F08%2F11%2Ffirst-year-summary-for-netease-work-experience%2F</url>
    <content type="text"><![CDATA[做了哪些事情说是一年，其实也一年多了，不过这倒不重要。主要看看做了哪些事吧： 1. 改造发布流程刚来公司的时候，白领贷的前端是基于 Riot 框架开发的系统。语言层面，使用 ES6 和 Less 开发，发布到线上是需要一个构建打包和编译的过程，不能直接部署到线上服务器。 所以项目的开发流程就是，功能开发，提交代码，本地打包，打包后的代码跟源代码一起提交测试，而后合并代码到 master 然后再在本地打包，然后上线。 这个流程非常的不合理，因为源代码和编译打包后的代码放到一块管理，本身就不合理。经常会出现，你一打包测试，我这边代码推上去就一堆冲突。所以我就想怎么来改进这个流程。 改进方案一网易内部是有一个 omad 系统（自动部署平台）的，想着说看能不能借助这个平台干点事情。因为初来乍到，对这个部署平台不是很熟悉，就问了和这个平台接触最多的测试同学，测试同学告诉我说 omad 没有提供任何对外的接口，所以我想的可能没法实现。 这样就尴尬了，没法做线上打包发布，那么打包这个过程就必然得放在本地来做。所以我就搞了一套现在看来很蠢的方案。那就是，用两个仓库来分别管理源代码和打包后的代码。 那么，如果需要发布的话，就需要在源代码仓库先进行打包编译，然后把打包编译的结果复制到管理要发布的代码的仓库。 一张示意图： 很明显，上面这种方式也只是临时解决方案，需要两个仓库来管理一份代码。每次提交代码都需要额外执行一个 run build 命令。 改进方案二：由于上面的方案太蠢了，所以有了改进方案二，也是我们现在一直在用的方案：那就是直接线上打包。具体如下：本地代码开发 -&gt; 提交 -&gt; 推送到远端 -&gt; omad 部署 -&gt; omad 专用打包机执行一段脚本来进行打包编译操作 -&gt; 把打包编译后的结果拷贝到目标机器。 一张示意图： 其实，本来第一次改造就应该改成这样的。但是因为一开始对内部的部署平台 omad 并不熟悉，所以不知道 omad 部署到目标机器前还可以执行一段脚本的。以至于有了第一种非常蠢的解决方案。 现在这套方案就比较完善了， 我们只关注源代码就可以了，发布的时候又 omad 去做构建和打包部署的事情。非常舒心，这套方案也一直用到了现在。 2. 搭建了一套完善的开发环境原有的白领贷开发环境是基于 express 和 webpack 配合搭建起来的，但是功能比较简陋，只支持开发和打包两个命令，而且打包的配置文件是完全服务于多页面的工程。 后来我们开发来钱系统的时候，我就在原有的基础上重新搭建了一套完善的开发环境。从开发、联调、测试、打包到上线，该有的功能都有了。放一张图，具体可以 看这里 3. 主导并推动了移动端组件 ne-rc 的开发再开发来钱的时候，积累了一套 react 的基础组件，但是跟业务耦合度比较高。考虑到以后可能还要做其他项目，就和一伙伴一起商量着把基础组件从业务中抽离出来，作为一个第三方组件库在接入到项目中。 于是就有了: ne-rc,我们的移动端组件库，索然还在为 1.0 版本的发布继续努力，但已经成功接入了三个内部的项目。 效果显著，大大降低了重复开发成本，同时也降低了未来维护的成本。由此可见，一个稳定发展的团队，还是需要一套自己的内部组件库的。 4. 团队工作改进由于原有业务线前端负责人在我入职后不久就离职了， 前端技术部派我临时挑大梁。我深知自己经验不足，但也知道这是一个锻炼的机会，这里非常感谢我的老大信任我。 所以我非常努力，和业务线团队的小伙伴就如何提高我们的团队技术实力和业务支持能力讨论了很多，最后做了一下事情: 开发框架优化 遗留项目改造 项目规范 技术规划 开发框架优化最终的成果就是上面说的搭建了一套完整的开发环境。并不断进行优化。从一开始白领贷项目开发时每次 rebuild 需要 30s , 打包上线需要 4~5 min 到后来去花项目 rebuild 600ms, 打包只需要 1min .这中间既有针对 webpack 的优化，也有项目开放交付方式的改变。 在这些优化的过程中，积累了很多经验。 遗留项目改造有几个遗留项目，虽然整体处于维护状态，但偶尔还是有很多运营需求。而原有的开发方式和发布方式都比较麻烦，我们也尽可能在不需要多的重构的基础上，进行了逐步升级。主要是构建和发布上。改写原有的 webpack 配置文件方式，并从本地打包发布升级到了线上打包发布。减轻了这些项目的维护成本。 项目规范业务线上人员来越多，在需要合作的情况下，规范是必不可少。我们从项目文档、代码风格检查、Git 分支管理、代码 review 等各个方面制订了完善又尽可能不繁琐的规范。 技术规划我们组的项目大多应用 react ，所以需要持续关注 react 生态群的技术动向。但同时也关注其他技术和解决方案，包括 Nodejs , Angular 等。前端技术部也让我们多看看 Vue . 然而到现在我都没看过 Vue ，哈哈，可能是提不起兴趣吧。 5. 业务支持虽然我们前端技术部属于职能部门，但支持业务仍然是我们工作的最主要构成部分，毕竟公司要赚钱。除了一些小的以及一些后台项目，我主要参与维护和开发一下项目： a. 白领贷项目维护b. 来钱项目开发并上线c. 去花项目开发并上线 去花最近就要上线了，我们已经开始内测了。这是一个提供分期的项目，目前只接入了考拉，马上也要对外了，不久大家就在考拉上购物时就可以有分期的支付选项了。 看到项目上线，还是很高兴的😄。 总结时间还是蛮快的， 都来网易一年多了。 这段时间成长了许多，无论时工作技能、沟通技能还是工作流程和规范，都让我学会了很多东西。 也认识了很多优秀的同事，能跟这些优秀的同事一起做事情，也是一件很开心的事情。也许以后不会一直在网易，但在网易的这段经历还是很值得的。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[React-Redux 源码粗读]]></title>
    <url>%2F2017%2F08%2F03%2Freact-redux-source-code-read%2F</url>
    <content type="text"><![CDATA[Overview首先看一张图： 可以看到入口文件里面引入了这几个模块： Provider connectAdvanced connect 我们就来依次看一下这几个模块 Provider将 store 挂在在了 context 上面，给予了子组件访问 store 的能力。 connectAdvanced一个用来生成 connect 的高阶函数,引用了以下模块:import hoistStatics from 'hoist-non-react-statics'import invariant from 'invariant'import &#123; Component, createElement &#125; from 'react'import Subscription from '../utils/Subscription'import &#123; storeShape, subscriptionShape &#125; from '../utils/PropTypes' Subscription首先看一下 Subscription 模块。 createListenerCollection实现一个订阅发布模式，提供 clear，notify，subscribe 方法。分别用来清除当前队列，触发事件，订阅方法。 Subscription订阅类，订阅 onStateChange 事件，同时确保当父级也有事件订阅时，事件触发时，先触发父级事件，然后再触发当前组件事件。 makeSelectorStateful(sourceSelector,store):selectorfunction makeSelectorStateful(sourceSelector, store) &#123; // wrap the selector in an object that tracks its results between runs. const selector = &#123; run: function runComponentSelector(props) &#123; try &#123; const nextProps = sourceSelector(store.getState(), props) if (nextProps !== selector.props || selector.error) &#123; selector.shouldComponentUpdate = true selector.props = nextProps selector.error = null &#125; &#125; catch (error) &#123; selector.shouldComponentUpdate = true selector.error = error &#125; &#125; &#125; return selector&#125; selector 用来通过 state 和 prop 来计算出下一个状态的 props，然后传递给连接的组件。此函数是对 selector 的封装，在计算 props 的基础上，并记录上一次计算的结果。 connectAdvanced(selectorFactory,{options}):wrapWithConnect(WrappedComponent)connectAdvanced 的功能主要是根据传入的 selectorFactory, options 返回用于生成 Connect 组件一个高阶组件。 connectclass Connect extends Component &#123; constructor(props, context) &#123; super(props, context) ... this.initSelector() this.initSubscription() &#125; ... initSelector() &#123; const sourceSelector = selectorFactory(this.store.dispatch, selectorFactoryOptions) this.selector = makeSelectorStateful(sourceSelector, this.store) this.selector.run(this.props) &#125; initSubscription() &#123; if (!shouldHandleStateChanges) return // parentSub's source should match where store came from: props vs. context. A component // connected to the store via props shouldn't use subscription from context, or vice versa. const parentSub = (this.propsMode ? this.props : this.context)[subscriptionKey] this.subscription = new Subscription(this.store, parentSub, this.onStateChange.bind(this)) // `notifyNestedSubs` is duplicated to handle the case where the component is unmounted in // the middle of the notification loop, where `this.subscription` will then be null. An // extra null check every change can be avoided by copying the method onto `this` and then // replacing it with a no-op on unmount. This can probably be avoided if Subscription's // listeners logic is changed to not call listeners that have been unsubscribed in the // middle of the notification loop. this.notifyNestedSubs = this.subscription.notifyNestedSubs.bind(this.subscription) &#125; ... render() &#123; const selector = this.selector selector.shouldComponentUpdate = false if (selector.error) &#123; throw selector.error &#125; else &#123; return createElement(WrappedComponent, this.addExtraProps(selector.props)) &#125; &#125;&#125; 定义在 connectAdvanced 内部的组件，通过 context 获取 store 中数据，通过 initSelector 方法初始化一个包含初始 store 的 selector, 并通过 initSubscription 方法订阅 store 的变化。此组件的 render 方法只是一个代理，用来把通过 selector 计算出来的 props 传递给需要包裹的组件。 connectconnect 引入了以下模块：import connectAdvanced from '../components/connectAdvanced'import shallowEqual from '../utils/shallowEqual'import defaultMapDispatchToPropsFactories from './mapDispatchToProps'import defaultMapStateToPropsFactories from './mapStateToProps'import defaultMergePropsFactories from './mergeProps'import defaultSelectorFactory from './selectorFactory' 只是在 connectAdvanced 的基础上，传入了 selectorFactory 和 mapStateToPropsFactories, mapDispatchToProps, mapDispatchToPropsFactories 作为 connectAdvanced 的 options 参数。 defaultSelectorFactory定义了默认 selector 的行为，用来从传入的 state 中计算下一个状态的 props. defaultMap xxx To xxx Factories这类模块用来生成映射到 props 方法的工厂函数，它们的代码如下形式：import &#123; bindActionCreators &#125; from 'redux'import &#123; wrapMapToPropsConstant, wrapMapToPropsFunc &#125; from './wrapMapToProps'export function whenMapDispatchToPropsIsFunction(mapDispatchToProps) &#123; return (typeof mapDispatchToProps === 'function') ? wrapMapToPropsFunc(mapDispatchToProps, 'mapDispatchToProps') : undefined&#125;export function whenMapDispatchToPropsIsMissing(mapDispatchToProps) &#123; return (!mapDispatchToProps) ? wrapMapToPropsConstant(dispatch =&gt; (&#123; dispatch &#125;)) : undefined&#125;export function whenMapDispatchToPropsIsObject(mapDispatchToProps) &#123; return (mapDispatchToProps &amp;&amp; typeof mapDispatchToProps === 'object') ? wrapMapToPropsConstant(dispatch =&gt; bindActionCreators(mapDispatchToProps, dispatch)) : undefined&#125; 可以看到，主要引用了 wrapMapToProps 这个模块。 wrapMapToPropswrapMapToPropsFunc这个方法是一个通过把 mapToProps 函数包裹起来作为一个代理函数,用来做一下几件事情： 检测 mapToProps 函数的调用是否依赖与 props, 用来供 selectorFactory 来决定在 props 变化的时候是否需要重新调用。 在第一次调用的时候，如果 mapToProp 执行后返回另一个函数，那么处理它，并且把这个返回的函数作为新的 mapToProps 用来处理后续的调用。 当第一次调用的时候，验证调用的结果是否是一个字面量对象。为了能够警告开发者，他们的 mapToProps 函数没有返回一个合法的结果。 总结react-redux 就是一个用来绑定 redux 到 react 的一个库。如果不用 react-redux 的话，直接在 react 里面去用 redux 也是可以的，只是过于麻烦。需要手动监听 store 的变化，并手动执行组件的 render 方法。react-redux 提供了一个高阶组件 connect 来帮我们做这件事情，而且帮我们做了一些优化。我们需要的只是，提供 mapDispatchToProps 和 mapStateToProps 给需要监听 store 的组件就可以了。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于 React 的前端项目开发总结]]></title>
    <url>%2F2017%2F05%2F12%2Freact-base-project-summary%2F</url>
    <content type="text"><![CDATA[技术选型我们的项目主要选用以下技术开发，再配合一些其它辅助工具。 react react-router redux react-redux 开发及线上环境开发环境由于项目是前后端分离的，所以我们需要一套完整的开发环境，需要包括以下功能： 数据 Mock Webpack 实施编译刷新 方便前后端联调 基于这些需求，我们基于 Express, Webpack,Webpack-dev-middleware 搭建了这套完整的开发环境。 可以看到，浏览器所有的请求都被本地的 Node.js 服务拦截。对于静态资源请求，都委托给 webpack-dev-middleware 来处理，对于接口请求根据不同的环境来决定要做的操作。 本地开发当 ENV = &#39;development&#39; 时，也就是开发环境，那么就直接读取本地的 mock 数据来渲染页面。 前后端联调当 ENV = &#39;api&#39; 时，也就是我们认为的联调环境，这个时候对于接口请求由 node.js 转发到需要联调的真实后端服务地址上，从而避免直接调用所产生的跨域问题。 这样就可以直接用本地开发代码和后端联调，能大大提高效率，省去了每次需要往服务器上构建部署的步骤。 线上环境 前后端是分开部署的，所有的静态资源都放在 CDN (example.cdn.com)上面。 也就是说我们的页面在 example.cdn/index.html 这里，但是请求的接口在 example.163.com/api/xxx,我们肯定不能让用户去直接去访问 example.cdn.com/index.html,这样不合理，而且由跨域问题存在 那么访问 example.dai.163.com 的时候，怎么拿到我们的 html 页面呢？看下图： 在客户端和后台服务之间架设一台 nginx, 我们访问的 example.dai.163.com 有两种请求： html 页面资源 接口请求 这两种请求都先经过 nginx，在这里做判断，如果是页面请求那么由 nginx 转发到 CDN， 否则交给后端服务来响应接口请求。 拿到页面以后，其它所有的 css, js 等静态资源都是直接请求到 CDN ，这里没什么说的。 数据流转借助 redux 来管理数据流，我们来看这张图。 首先，通过 middleware 和 reducer 生成 store, 然后获得项目的初始 state,通过初始 state 去渲染页面的初始状态。 以 Home 页面为例，首先 Home 通过 react-redux 提供的 connect 方法拿到初始 state 作为 Home 的 prop 传递给 Home. 而 Home 由多个不同的子组件组成，这些组件的需要数据再由 Home 通过 props 传递给自己的子组件。 当 Home 的初始状态加载完毕后，我们需要向后端请求去拿去一些用户数据。这时，我们分发一个下面这种格式的 action:&#123; types: ['home/start','home/success','home/failure'], payload: &#123; api: ... &#125;, meta: &#123; isApi: true &#125;&#125; 所有的 action 都会按照我们制定的循序通过一个个 middleware. 在这里，我们的 action 会被 callApiMiddleware 通过 meta 里面的 isApi 标识命中，并去做相应的事情。 比如在这个中间件里面，我们去做了真实的接口请求，在请求成功或失败的时候分发对应的 action，以及做一些统一的业务逻辑。比如我们对后端返回的接口中 code 值有统一的约定，假设 1 为成功， 2 为失败， 3 为未登录。那么我们就可以在中间件中去处理这些业务逻辑。 当请求成功，并渲染页面后，假设用户点击了一个按钮，这个按钮需要唤起 native 的一些功能，比如说拍照。那么我们分发一个唤起拍照功能的 camera/start 的action:&#123; types: ['sdk/start','sdk/success','sdk/failure'], payload: &#123; command: ... &#125;, meta: &#123; isSDK: true &#125;&#125; 同样的道理，这个 action 会被 EpaySDKMiddleware 所识别并处理，在调起 native 的时候， 为了保证安全性，我们需要向后发起一个请求去拿签名，这个时候就可以在 EpaySDKMiddleware 里面分发一个接口请求的 action，那么这个 action 同样需要走一遍所有的 middleware. 那么这个接口请求的 action 就会像上面的流程一样，通过 callApiMiddleware 去处理。 中间件的存在，使整个流程变得非常清晰，接口的请求的中间件就只做接口请求，调用 native 接口的中间件就只做对 native 的调用，当对 native 接口的调用需要做后端接口请求的时候，去分发一个 action 走接口请求的中间件。 每个中间件只专注于自己的事情，既方便后续的维护，同时也提供了一个很好的拓展方式。而 View 层需要做的就只是做出分发 action，然后拿数据渲染页面就可以了，其他的逻辑都不用关心。 一个例子 假设我们由如下的一个路由配置。&#123; component: App, path: '/', onEnter: initLogin(store), indexRoute: &#123; getComponent(nextState, cb) &#123; require.ensure([], require =&gt; &#123; cb(null, require('../views/Home').default) &#125;, 'Home') &#125;, onEnter: initHome(store) &#125;, childRoutes: [ createActivateRoute(store), &#123; path: 'test', indexRoute: &#123; getComponent(nextState, cb) &#123; require.ensure([], require =&gt; &#123; cb(null, require('../views/Test').default) &#125;, 'Test') &#125; &#125; &#125;, ... ]&#125; 那结合 react-route 我们来看一个完整的流程。当我们浏览器里面输入 example.dai.163.com/index.html/#/ 的时候。 首先，通过最上面 线上环境 一节提到的内容，拿到页面需要 html,css,js. 然后渲染 Provide 和 Router 组件，分别提供 store 的注入和路由的控制。 此时触发根路径的路由匹配，然后加载根组件 APP, 然后根据路由匹配规则匹配到 IndexRouter, 加载 Home 组件。 后面的事情就和前面数据流转一节讲的是一样的了。 总结在前后端完全分离的基础上，借助一套完善的开发环境，可以大大提高的我们的开发效率，降低前后端联调的成本。 同时借助于 Redux 思想，实现单向数据流，让我们可以实现一个非常清晰的数据流向。并且，借助于中间件，我们可以更加有效的控制数据流转的过程。为后面项目的扩展提供无限的想象空间。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Redux</tag>
        <tag>react-router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React 单页面初始化渲染优化]]></title>
    <url>%2F2017%2F04%2F20%2Freact-page-render-improve%2F</url>
    <content type="text"><![CDATA[由于项目使用 React, React-Router, Redux 来开发项目，采取了前端渲染的方式（如果采用 ssr 就不会有这个问题）。 问题所以每到一个页面，需要发一个初始化的请求来获取页面数据，然后重新渲染页面，所以之前一个页面从请求到加载完毕的流程是这样的：Route match -&gt; ComponentWillMount -&gt; render -&gt; ComponentDidMount -&gt; dispatch(init())-&gt; render -&gt; componentDidUpdate 首先是路由匹配，然后准备加载组件，使用通过 Reducer 里面的初始化 state 进行 render, 然后触发 ComponentDidMount 事件，在这个事件里面去 dispatch 一个执行页面初始化的请求的 Action，请求成功过以后触发组件的重新渲染。 可以看到，展示最终的页面需要组件重新渲染两次。一次是使用写死在前端的reducer 里面的 initialState 数据来渲染，一次是在拿到后端数据进行的渲染。 所以有的时候会出现闪屏的情况，用户体验很不好。 我们的要求是进页面以后就是用从后台获取的最新数据渲染的页面，整个页面只会 render 一次。 那么怎么解决这个问题呢？ 解决方案要解决这个问题，那么必然是加载好数据后，再去挂载页面组件，那么加载数据的时机就显得尤为重要。借鉴传统服务端渲染页面的方式，这个时机肯定是放在路由里面去做比较合适。 具体到项目里面，就是在 react-route 里面的 onEnter 事件里面去做页面的初始化请求，当所有数据请求成功以后，在去加载这个页面。 整个页面加载的流程就变成了这样：Route match -&gt; dispatch(init()) -&gt; ComponentWillMount -&gt; render -&gt; ComponentDidMount 具体代码如下：HomeAction.jsimport &#123;createAction&#125; from 'redux-actions'import &#123;HOME_INDEX&#125; from '../../config/apis.js'import initAPI from '../../utils/initAPI.js'import createAsyncAction from '../../utils/createAsyncAction.js'export const InitActionList = createAsyncAction('home/init')export const FormChange = 'home/formChange'export const FormFieldChange = 'home/formFieldChange'export function init() &#123; return initAPI(InitActionList, HOME_INDEX, 'get')&#125; HomeReducer.jsimport &#123; InitActionList &#125; from './HomeAction.js'import &#123; CreditStatus, BillStatus, InstallmentStatus &#125; from '../../config/constant'const initState = &#123; foo: 1, bar: 10,&#125;export default function (state = initState, action) &#123; const type = action.type const payload = action.payload const meta = action.meta switch (type) &#123; case InitActionList.start: return state case InitActionList.success: const currentStatus = getCurrentStatus(payload) return &#123; ...state, foo: currentStatus, &#125; case InitActionList.failure: return state default: return state &#125;&#125; Router.jsimport &#123;init as initHome&#125; from './homeAction'export default function createRoutes (store) &#123; function initHome (store) &#123; return (nextState, replace, next) =&gt; &#123; // dispatch 页面加载的 Action，在数据加载完成后在执行 next() 以挂载组件 store.dispatch(homeInit()) .then(() =&gt; next()) &#125; &#125; return &#123; component: App, path: '/', childRoutes: [ require('./activate'), &#123; path: 'test', getComponent(nextState, cb) &#123; require.ensure([], require =&gt; &#123; cb(null, require('../views/Test').default) &#125;, 'Test') &#125; &#125; ], indexRoute: &#123; getComponent(nextState, cb) &#123; require.ensure([], require =&gt; &#123; cb(null, require('../views/Home').default) &#125;, 'Home') &#125;, onEnter: initHome(store) &#125; &#125;&#125; Index.jsimport React from 'react'import &#123; render &#125; from 'react-dom'import &#123; Router, hashHistory &#125; from 'react-router'import &#123; Provider &#125; from 'react-redux'import &#123; syncHistoryWithStore &#125; from 'react-router-redux'import &#123; AppContainer &#125; from 'react-hot-loader'import 'react-hot-loader/patch'import createRoutes from './routes'import configureStore from './store'import './style/app.scss'export const store = configureStore(hashHistory, &#123;&#125;)const history = syncHistoryWithStore(hashHistory, store)const root = document.getElementById('root')const routers = createRoutes(store)const renderRoot = () =&gt; &#123; render( &lt;AppContainer&gt; &lt;Provider store=&#123;store&#125; key='provider'&gt; &lt;Router routes=&#123;routers&#125; history=&#123;history&#125; key=&#123;Math.random()&#125; /&gt; &lt;/Provider&gt; &lt;/AppContainer&gt;, root )&#125;if (module.hot) &#123; module.hot.accept('./routes', () =&gt; &#123; renderRoot() &#125;)&#125;renderRoot()]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Redux</tag>
        <tag>react-router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个 React Form 组件的重构思路]]></title>
    <url>%2F2017%2F03%2F17%2Freact-form-rework-thinking%2F</url>
    <content type="text"><![CDATA[最近对团队内部 React 组件库（ne-rc）中的 Form 组件进行了重构，记录一下思考的过程。 一些前置定义： 名词 定义 表单 Form 组件 子表单 嵌套在 Form 下面的类似 Input, Select 这样的子组件 首先我们看一下，我们的对 Form 组件的需求是什么。 获取当前变动表单的状态 校验所有必填表单是否填写完成 对外触发具体表单变化的方法 formFieldChange 暴露对外提供整个表单状态的方法 提供整个表单最新状态的方法 $Form.data 提交方法 校验表单是否通过校验 对外触发 formSubmit 方法 接着我们从重构前和重构后，看如何来解决这个问题。 Before获取当前变动表单的状态如何获取变动的子表单React 父子通信需要通过 prop 传递方法，对于 Form 下面的类似与 Input 之类的子表单的变化想要通知到父级，如果不借助第三方的事件传递方法，那么就只能通过由父级通过 props 向 Input 传递 formFieldChange（假设就叫这个名字）方法，然后当子组件变化时去调用 formFieldChange 来实现。 那么问题来了，什么时候去传递这个方法呢？ 不能在具体页面里面使用的时候再去每条表单里面注册这个方法，那每个用到表单组件的时候就都需要给子表单进行这样的事件绑定，这样太累了。 所以一开始，我选择通过直接递归的遍历 Form 下面的 children，只要发现这个 children 是我想要的表单类型，那么就重新克隆一个带有 formFieldChange 的组件来替换掉原来的组件。/** * 获取 form 下面每一个表单对象，注入属性，并收集起来 * @param children * @returns &#123;*&#125; */function getForms(children) &#123; return React.Children.map(children, (el, i) =&gt; &#123; if (!el) &#123; return null &#125; switch (el.type) &#123; case Input: Forms.push(el) return React.cloneElement( el, &#123; key: i, formFieldChange, emptyInput &#125; ) case Select: Forms.push(el) return React.cloneElement( el, &#123; key: i, formFieldChange &#125; ) case CheckBox: Forms.push(el) return React.cloneElement( el, &#123; key: i, formFieldChange &#125; ) default: if (el.props &amp;&amp; el.props.children instanceof Array) &#123; const children = getForms(el.props.children) return React.cloneElement( el, &#123; key: i, children &#125; ) &#125; else &#123; return el &#125; &#125; &#125;)&#125; 这样，所有的特定子组件就都可以拿到被注册的方法。以 Input 为例，在 Input 的 onChange 方法里面去调用从父级 props 传入的 formFieldChange 就可以通知到 Form 组件了。 收集变动表单的数据。前一步完成后，这一步就比较简单了，Input 在调用 formFieldChange 的时候把想要传递的数据作为参数传进去，在 Form 里面去对这个参数做处理，就可以拿到当前变动的表单状态数据了。 校验表单是否填写完成前面我们收集了每一条变动表单的数据。但是要判断当前 Form 下面的表单是否填写完成，那么首先需要知道我们有多少个需要填写的表单，然后在 formFieldChange 的时候进行判断就可以了。如何来提前知道我们有多少需要填写的 Field 呢，之前我选择的是通过在使用 Form 的时候先初始化一个包含所有表单初始化状态的数据。export default class Form extends React.Component &#123; constructor(props) &#123; super(props) this.Forms = [] this.formState = Object.assign(&#123;&#125;, &#123; isComplete: false, isValidate: false, errorMsg: '', data: &#123;&#125; &#125;, this.props.formState) &#125; static propTypes = &#123; onChange: PropTypes.func, onSubmit: PropTypes.func, formState: PropTypes.object &#125; // 初始化一个类似这样的对象传递给 FormformState: &#123; data: &#123; realName: &#123;&#125;, cityId: &#123;&#125;, email: &#123;&#125;, relativeName: &#123;&#125;, relativePhone: &#123;&#125;, companyName: &#123;&#125; &#125;&#125;, 这样就很粗暴的解决了这个问题，但是这中间存在很多问题。 因为限定了特定的组件类型（Input，Select，CheckBox），导致不利于扩展，如果在开发过程遇到其他类型的比如自定义的子表单，那么 Form 就没法对这个自定义子表单进行数据收集，解决起来比较麻烦。 所以就在考虑另一个种实现方式， Form 只去收集一个特定条件下的组件，只要这个组件满足了这个条件，并实现了对应的接口，那么 Form 就都可以去收集处理。这样也就大大挺高了适用性。 暴露对外提供整个表单状态的方法通过在外监听每次 Form 触发的 onChange 事件来获取整个 Form 的状态。 提交方法检验表单是否通过校验已经有了整个 Form 的数据对象，做校验并不是什么困难。通过校验的时候调用 formSubmit 方法，没有通过校验的时候对外把错误信息添加到 Form 的 state 上去。 对外触发 formSubmit 方法当表单通过校验的时候，对外触发 formSubmit 方法，把要提交的数据作为 formSubmit 的参数传递给外面。 After前面是之前写的 Form 组件的一些思路，在实际使用中也基本能满足业务需求。 但是整个 Form 的可拓展性比较差，无法很好的接入其他自定义的组件。所以萌生了重写的想法。 对于重写的这个 Form，我的想法是：首先一定要方便使用，不需要一大堆的起始工作；其次就是可拓展性要强，除了自己已经提供的内在 Input，Select 等能够接入 Form 外，对于其他的业务中的特殊需求需要接入 Form 的时候，只要这个组件实现了特定的接口就可以了很方便的接入，而不需要大量的去修改组件内部的代码。 重构主要集中在上面需求 1 里面的内容，也就是：获取当前变动表单的状态 获取当前表单的状态分解下来有一下几点： 获取所有需要收集的子表单 formFields 初始化 Form state 表单下面子表单数量或类型发生变化时更新 1 里面创建的 formFields 子表单内部状态发生变化时通知到父表单 获取当前变动表单的状态获取所有需要的子表单同样通过递归遍历 children 来获取需要收集的子表单，通过子表单的 type.name 命名规则是否符合我们的定义来决定是否要进行收集。直接来看代码：collectFormField = (children) =&gt; &#123; const handleFieldChange = this.handleFieldChange // 简单粗暴，在 Form 更新的时候直接清空上一次保存的 formFields，全量更新， // 避免 formFields 内容或者数量发生变化时 this.formFields 数据不正确的问题 const FormFields = this.formFields = [] function getChildList(children) &#123; return React.Children.map(children, (el, i) =&gt; &#123; // 只要 Name 以 _Field 开头，就认为是需要 From 管理的组件 if (!el || el === null) return null const reg = /^_Field/ const childName = el.type &amp;&amp; el.type.name if (reg.test(childName)) &#123; FormFields.push(el) return React.cloneElement(el, &#123; key: i, handleFieldChange &#125;) &#125; else &#123; if (el.props &amp;&amp; el.props.children) &#123; const children = getChildList(el.props.children) return React.cloneElement(el, &#123; key: i, children &#125;) &#125; else &#123; return el &#125; &#125; &#125;) &#125; 只要组件的 class name 以 _Field 开头，就把它收集起来，并传入 handleFieldChange 方法，这样当一个自定义组件接入的时候，只需要在外面包一层，并把 class 的命名为以 _Field 开头的格式就可以被 Form 收集管理了。 接入组件里面需要做的就是，在合适的时机调用 handleFieldChange 方法，并把要传递的数据作为参数传递出来就可以了。 为什么一定要执迷不悟的使用遍历这种低效的方式去收集呢，其实都是为了组件上使用的方便。这样就不需要每次在引用的时候在对子表单做什么操作了。 初始化 Form state上一步拿到了所有的子表单，然后通过调用 initialFormDataStructure 拿来初始化 Form 的 state.data 的结构，同时通知到外面 Form 发生了变化。 子表单数量或类型发生变化时当 Form 下面子组件被添加或删除时，需要及时更新 Form Data 的结构。通过调用 updateFormDataStructure把新增的或者修改的子表单更新到最新，并通知到外面 Form 发生了变化。 子表单内部状态发生变化时在第一步收集子表单的时候就已经把 handleFieldChange 注入到了子表单组件里面，所以子表单来决定调用的时机。当 handleFieldChange 被调用的时候，首先对 Form state 进行更新，然后外通知子表单发生了变化，同时通知外面 Form 发生了变化。 这样看起来整个流程就走通了，但实际上存在很多问题。 首先由于 setState 是一个异步的过程，只有在 render 后才能获取到最新的 state. 这就导致，在一个生命周期循环内如果我多次调用了 setState ，那么两次调用之间对 state 的读取很可能是不准确的。（有关生命周期的详细内容可以看这篇文章：https://www.w3ctech.com/topic/1596） 所以我创建了一个临时变量 currentState 来存放当前状态下最新的 state，每次 setState 的时候都对其进行更新。 另一个问题是当 Form 发生变化的时候，updateFormDataStructure 调用的过于频繁。其实只有在子表单的数量或者类型发生变化时才需要更新 Form state 的结构。而直接去对比子表单的类型是否发生变化也是意见开销很大操作，所以选择另一种折中方式。通过给 Form 当前的状态打标，将 Form 可能处于的状态都标识出来：const STATUS = &#123; Init: 'Init', Normal: 'Normal', FieldChange: 'FieldChange', UpdateFormDataStructure: 'UpdateFormDataStructure', Submit: 'Submit'&#125; 这样，只有在 Form 的 STATUS 处于 Normal 的时候才对其进行 updateFormDataStructure 操作。这样就可以省去很多次渲染以及无效的对外触发的 FormChange 事件。 提交和对外暴露 Form 状态的方法和之前基本一致，这样整个对 Form 的重构就算完成了，具体项目中使用体验还不错 O(∩_∩)O Form 组件地址： https://github.com/NE-LOAN-FED/NE-Component/tree/master/src/Form 最后，如果看文章的你有什么更好的想法，请告诉我😛。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【翻译向】Webpack 1 到 2 升级指南]]></title>
    <url>%2F2017%2F01%2F19%2Fwebpack2-migrating-v1-v2%2F</url>
    <content type="text"><![CDATA[resolve.root,resolve.fallback,resolve.modulesDirectories这些配置项项都被一个单独的配置所替代 resolve.modules. 查看 resolving 了解更多。 resolve: &#123;- root: path.join(__dirname, "src")+ modules: [+ path.join(__dirname, "src"),+ "node_modules"+ ]&#125; resolve.extensions这个选项已经不在需要传一个空字符串了。它的行为已经被移动到了 resolve.enforceExtension. 查看 resolving 了解更多。 resolve.*这里修改了很多内容。因为被用到的不是很多，所以就不一一列举出来了。查看 resolving 了解更多。 module.loaders 现在是 module.rules老的 loader 配置被一个更加强大的 rules 系统所取代了，允许配置 loader 和更多内容。为了保证一致性，旧的 module.loaders 语法依然可以合法且可以使用的。新的命名规范更加易于理解，这是一个使用 module.rules 去升级配置的很好的理由。 module: &#123;- loaders: [+ rules: [ &#123; test: /\.css$/,- loaders: [+ use: [ &#123; loader: "style-loader" &#125;, &#123; loader: "css-loader",- query: &#123;+ options: &#123; modules: true &#125; ] &#125;, &#123; test: /\.jsx$/, loader: "babel-loader", // Do not use "use" here options: &#123; // ... &#125; &#125; ] &#125; 把 loader 链接起来（Chaining loaders）就像在 webpack1 中那样，loader 可以被链接起来，把上一个 loader 的结果传递给下一个 loader. 使用 rule.use， use 可以设置为一个 loaders 的列表。在 webpack1 中，loader 通过 ! 来链接再一起。现在只会在 module.loaders 里面才会支持这样的风格。 module: &#123;- loaders: &#123;+ rules: &#123; test: /\.less$/,- loader: "style-loader!css-loader!less-loader"+ use: [+ "style-loader",+ "css-loader",+ "less-loader"+ ] &#125; &#125; 自动添加 -loader 后辍的特性被移除了在引入 loader 的时候不能在省略后面的 -loader 了。 module: &#123; rules: [ &#123; use: [- "style",+ "style-loader",- "css",+ "css-loader",- "less",+ "less-loader", ] &#125; ] &#125; 不过依旧可以使用 resolveLoader.moduleExtensions 配置来达到以前的目的，但是我们不推荐这样做。+ resolveLoader: &#123;+ moduleExtensions: [&quot;-loader&quot;]+ &#125; 不再需要 json-loader当没有给 sjon 文件配置对应的 loader 的时候，webpack 会自动使用 json-loader 来载入 JSON 文件。 module: &#123; rules: [- &#123;- test: /\.json/,- loader: &quot;json-loader&quot;- &#125; ] &#125; webpack 选择这样做的目的是想要抹平在 webpack，nodejs 和 browserify 不同环境下的区别。 配置中的 loaders 会相对与上下文来解析（Loaders in configuration resolve relative to context）在 webpack1 中配置的 loader 会相对与匹配到的文件解析。但是 webapck2 中配置的 loader 会根据 context 的设置来解析。 这解决了当由于使用 npm link 或者引用 context 之外导致模块重复引入的问题。 你可能会通过 hach 的方式解决这个问题： module: &#123; rules: [ &#123; // ...- loader: require.resolve(&quot;my-loader&quot;)+ loader: &quot;my-loader&quot; &#125; ] &#125;, resolveLoader: &#123;- root: path.resolve(__dirname, &quot;node_modules&quot;) &#125; module.preLoades 和 module.postLoaders 被移除了 module: &#123;- preLoaders: [+ rules: [ &#123; test: /\.js$/,+ enforce: &quot;pre&quot;, loader: &quot;eslint-loader&quot; &#125; ] &#125; UglifyJsPlugin sourceMapUglifyJsPlugin 中 souceMap 的默认选项从 true 改为了 false. 这意味着如果你需要在压缩后的代码中使用 souceMap 的功能，需要手动去配置 sourceMap:false. devtool: &quot;source-map&quot;, plugins: [ new UglifyJsPlugin(&#123;+ sourceMap: true &#125;) ] UglifyJsPlugin 警告UglifyJsPlugin 中 compress.warnings 和上一条一样，默认选项从 true 改为了 false.如果需要看到 uglifyjs 的警告，需要设置 compress.warnings 为 true. devtool: &quot;source-map&quot;, plugins: [ new UglifyJsPlugin(&#123;+ compress: &#123;+ warnings: true+ &#125; &#125;) ] UglifyJsPlugin 压缩 loader（minimize loaders）UglifyJsPlugin 不会在压缩模式下切换 loaders 了。minimize: true 需要一直被设置在配置来传给 loader 了，查看文档以了解更多的内容。 在 webpack3 或者后续的版本中，loaders 的压缩模式这个特性会被移除掉。 BannderPlugin - breaking changeBannderPlugin 不在支持传递两个参数，而是传递一个对象。 plugins: [- new webpack.BannerPlugin(&apos;Banner&apos;, &#123;raw: true, entryOnly: true&#125;);+ new webpack.BannerPlugin(&#123;banner: &apos;Banner&apos;, raw: true, entryOnly: true&#125;); ] OccurrenceOrderPlugin 被作为默认设置不在需要手动去配置了 plugins: [- new webpack.optimize.OccurrenceOrderPlugin() ] ExtractTextWebpackPlugin - breaking changeExtractTextWebpackPlugin 1.0.0 无法在 webpack2 中正常工作，需要安装 ExtractTextPlugin V2 。 npm install --save-dev extract-text-webpack-plugin@beta 配置的区别主要是在语法上。 ExtractTextPlugin.extract module: &#123; rules: [ test: /.css$/,- loader: ExtractTextPlugin.extract(&quot;style-loader&quot;, &quot;css-loader&quot;, &#123; publicPath: &quot;/dist&quot; &#125;)+ loader: ExtractTextPlugin.extract(&#123;+ fallbackLoader: &quot;style-loader&quot;,+ loader: &quot;css-loader&quot;,+ publicPath: &quot;/dist&quot;+ &#125;) ]&#125; new ExtractTextPlugin({options}) plugins: [- new ExtractTextPlugin(&quot;bundle.css&quot;, &#123; allChunks: true, disable: false &#125;)+ new ExtractTextPlugin(&#123;+ filename: &quot;bundle.css&quot;,+ disable: false,+ allChunks: true+ &#125;)] 全动态 require 会默认失败（Full dynamic requires now fail by default）一个由表达式决定的依赖会创建一个空的上下文来替代之前创建的一个包含完成文件夹的上下文。 最好重构这里的代码，因为它不会在 ES2015 模块里面工作。如果这对你来说不太可能，可以使用 ContextReplacementPlugin 来指定编译器找到正确的地址。 在 CLI 和配置文件中使用自定义参数如果你滥用 CLI 参数去传递自定义参数到配置中，像这样： webapck --custom-stuff // webpack.config.jsvar customStuff = process.argv.indexOf("--custom-stuff") &gt;= 0;/* ... */module.exports = config; 你会发现这样不再被允许了，现在 CLI 比之前更加严格了。 作为替代，现在有一个接口用来给配置传递参数。未来的工具会基于这个。 webpack --env.customStuff module.exports = function(env) &#123; var customStuff = env.customStuff; /* ... */ return config;&#125;; 查看 CLI require.ensure 和 AMD require 是异步的了这些函数变成了异步的，代替之前如果代码块已经被加载后它们的回调函数会同步执行的行为。 require.ensure 现在依赖与原生的 Promise, 如果在一个不支持 Promise 的环境下使用 require.ensure ，那么你需要一个 polyfill. Loader 的配置要通过 options不能在通过在 webpack.config.js 中一个自定义的属性来配置 loader 了。必须通过 options. 下面这个 ts 属性的配置在 webpack2 中已经不合法了。 module.exports = &#123; ... module: &#123; rules: [&#123; test: /\.tsx?$/, loader: 'ts-loader' &#125;]&#125;,// does not work with webpack 2ts: &#123; transpileOnly: false &#125;&#125; 什么是 options？好问题。严格的说，它可能是两个东西；都是用来配置一个 loader 的方式。典型的 options 被称为 query, 是一个可以被添加 loader 名字后面的字符串。更像一个 查询字符（query string），但实际上是 greater powers module.exports = &#123; ... module: &#123; rules: [&#123; test: /\.tsx?$/, loader: 'ts-loader?' + JSON.stringify(&#123; transpileOnly: false &#125;) &#125;] &#125;&#125; 同样可以是一个指定的对象，和 loader 一同提供： module.exports = &#123; ... module: &#123; rules: [&#123; test: /\.tsx?$/, loader: 'ts-loader' options: &#123; transpileOnly: false &#125; &#125;]&#125;&#125; LoaderOptionsPlugin 上下文一些 loader 需要从配置文件中读取上下文信息。这个需要长期的设置在 loader 的选项中。 为了兼容老的 loader，可以通过这个插件来传递给 loader： plugins: [ + new webpack.LoaderOptionsPlugin(&#123; + options: &#123; + context: __dirname + &#125;+ &#125;)] debug在 webapck1 中 debug 选项用来把 loader 切换到 debug 模式。 在 webapck3 或更后面的版本中，这个模式会被移除掉。 为了兼容老的 loader，可以通过这个插件来传递参数给 loader： - debug: true, plugins: [+ new webpack.LoaderOptionsPlugin(&#123;+ debug: true+ &#125;)] ES2015 代码分割在 webpack1 中，可以通过 require.ensure 来懒加载一些代码块： require.ensure([], function(require) &#123; var foo = require("./module");&#125;); 在 ES2015 中我们使用 import() 作为一个方法在运行时动态的记载 ES2015. webpack 会把 import() 作为一个分割点，并且把加载的代码分离出来作为一个单独的代码块。 import() 需要一个模块的名称作为参数，并返回一个 Promise 对象。 function onClick() &#123; import("./module").then(module =&gt; &#123; return module.default; &#125;).catch(err =&gt; &#123; console.log("Chunk loading failed"); &#125;);&#125; 好消息：现在代码块加载失败可以被处理了，因为它们是基于 Promise 的。 警告（Caveat）：require.ensure 可以方便的指定代码块的名字，通过第三个参数，但是 import API 还不支持这个特性。如果你还依赖这个功能，那么你可以继续使用 require.ensure. require.ensure([], function(require) &#123; var foo = require("./module");&#125;, "custom-chunk-name"); 如果想要和 Babel 结合使用 import, 你需要安装 dynamic-import 这个还处于 Stage 3 的语法插件来绕过语法解析错误。当这个提案被加到标准里面后，就不需要这么做了。 动态表达式（Dynamic expressions）很有可能你会需要传递一个表达式给 import(). 这里处理的模式跟 CommonJs 中很相似。 import() 创建一个单独的代码块给每个可能的模块。 function route(path, query) &#123; return import(`./routes/$&#123;path&#125;/route`) .then(route =&gt; new route.Route(query));&#125;// This creates a separate chunk for each possible route 混合使用 ES2015，AMD 和 CommonJS如果是 AMD 和 CommonJs ，那么它们完全可以很自由的混合使用。在这种情况下，Webpack 的处理的行为和 babel 或者 node-eps 相似。 // CommonJS consuming ES2015 Modulevar book = require("./book");book.currentPage;book.readPage();book.default === "This is a book"; // ES2015 Module consuming CommonJSimport fs from "fs"; // module.exports map to defaultimport &#123; readFileSync &#125; from "fs"; // named exports are read from returned object+typeof fs.readFileSync === "function";typeof readFileSync === "function"; 很重要的一点是，你需要告诉 babel 不要解析这些模块符号（module symbols），这样 webpack 才能使用它们。在 .babelrc 中这样配置就可以了： babelrc&#123; &quot;presets&quot;: [ [&quot;es2015&quot;, &#123; &quot;modules&quot;: false &#125;] ]&#125; 提示不需要修改什么，但是会很方便。 字符串模板webpack 现在支持在表达式中使用字符串模板了。这意味着可以在 webpack constructs 中使用他们： - require(&quot;./templates/&quot; + name);+ require(`./templates/$&#123;name&#125;`); Configuration Promisewebpack 现在支持从配置文件中返回一个 Promise 了。这意味着我们可以在配置文件中做一些异步的处理。 webapck.config.js module.exports = function() &#123; return fetchLangs().then(lang =&gt; (&#123; entry: "...", // ... plugins: [ new DefinePlugin(&#123; LANGUAGE: lang &#125;) ] &#125;));&#125;; 高级 loader 匹配webpack 现在支持更多的方式来让 loader 去匹配文件 module: &#123; rules: [ &#123; resource: /filename/, // matches "/path/filename.js" resourceQuery: /querystring/, // matches "/filename.js?querystring" issuer: /filename/, // matches "/path/something.js" if requested from "/path/filename.js" &#125; ]&#125; 更多的命令行选项添加了一些新的命令行选项：--define process.env.NODE_ENV=&quot;production&quot; ,查看 DefinePlugin. --display-depth 展示每个模块和入口的距离 --display-used-exports 展示模块使用了那个模块的暴露的信息 --display-max-modules 设置输出中展示的最大模块数量 -p 同样设置了 process.env.NODE_ENV 为 “production” Loader 修改只和 loader 的作者有关。 可缓存（Cacheable）Loader 现在默认是可以缓存的。Loader 必须选择 return 如果它们是不可缓存的话。 // Cacheable loader module.exports = function(source) &#123;- this.cacheable(); return source; &#125; // Not cacheable loader module.exports = function(source) &#123;+ this.cacheable(false); return source; &#125; 复杂的选项webpack1 只支持可以 JSON.stringify选线的 loader. webpack2 支持所有的 plugins 接收一个 JS 对象作为参数。 使用复杂的选项会带来一个限制。需要给设置对象一个 ident 使他可以被其它 loaders 引用。 拥有一个 ident 在选项对象上，意味着他可以被其它 inline loader 引用。 require(&apos;some-loader??by-iden!resource&apos;) &#123; test: /.../, loader: &quot;...&quot;, options: &#123; ident: &quot;by-ident&quot;, magic: () =&gt; return Math.random() &#125;&#125; 这种 inline 写法不应该经常使用，但是它可以被 laoder 生成的代码使用。例子：style-loader 生成一个模块，require 了剩下的请求（比如用来暴露 CSS）。 // style-loader generated code (simplified)var addStyle = require(&quot;./add-style&quot;);var css = require(&quot;-!css-loader?&#123;&quot;modules&quot;:true&#125;!postcss-loader??postcss-ident&quot;);addStyle(css); 所以如果你要使用复杂的选项，那么告诉你的用户有关 ident 的事情。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【翻译向】webpack2 指南（下）]]></title>
    <url>%2F2017%2F01%2F18%2Fwebpack2-guide-3%2F</url>
    <content type="text"><![CDATA[缓存（Caching）为了能够使 webpack 处理后的静态资源能够长期缓存下来，需要： 使用 [chunkhash] 给每一个文件创建基于内容变化的缓存标识 在 HTML 文件中引入文件时使用编译状态来拿到文件名称 在载入资源之前生成 chunk-manifest JSON 文件并写入到 HTML 页面中 确保包含启动代码的入口代码块的 hash 值不会被修改，当它的依赖没有变化的时候 存在的问题每当我们代码中有一些东西需要被更新的时候，它需要在服务上部署然后由客户端重新下载这些文件。当网络状状况不太好的时候，这是意见非常低效的事情。这也是为什么浏览器要缓存静态资源的原因。 这会导致一个陷阱：当我们发布一个新的版本的时候不去更新的文件名，这会让浏览器认为文件没有变化，导致客户端拿不到最新的资源。 一个简单解决问题的方式就是告诉浏览器一个新的文件名。在没有 webpack 的时候我们会使用构建版本来标识此次的更新： application.js?build=1application.css?build=1 在 webpack 中这样做也很简单：每一次 webpack 的构建都会生成一个可以用来构成文件名的独一无二的 hash 值。下面这个配置文件会生成两个带有 hash 值的文件名： // webpack.config.jsconst path = require('path');module.exports = &#123; entry: &#123; vendor: './src/vendor.js', main: './src/index.js' &#125;, output: &#123; path: path.join(__dirname, 'build'), filename: '[name].[hash].js' &#125;&#125;; 执行 webpack 命令会得到以下输出： Hash: 55e783391098c2496a8fVersion: webpack 1.10.1Time: 58msAsset Size Chunks Chunk Namesmain.55e783391098c2496a8f.js 1.43 kB 0 [emitted] mainvendor.55e783391098c2496a8f.js 1.43 kB 1 [emitted] vendor[0] ./src/index.js 46 bytes &#123;0&#125; [built][0] ./src/vendor.js 40 bytes &#123;1&#125; [built] 但存在的问题是，每次我们重新编译，所有的文件名都会变化，这会导致客户端每次都重新把整个应用的代码重新下载一遍。那么我们如何才能时客户端每次只下载有变动的文件。 给每个文件生成独特的 hash当一个文件的内容没有变化的时候，如何保证它的文件名不会在每次编译中变化。比如，一个用来放所有的我们的所有依赖库文件的代码包。 Webpack 允许根据文件的内容生成 hash 值。这是更新后的配置： // webpack.config.jsmodule.exports = &#123; /*...*/ output: &#123; /*...*/ filename: '[name].[chunkhash].js' &#125;&#125;; 这个配置同样会生成两个文件，但是每个文件都拥有自己的 hash 值： main.155567618f4367cd1cb8.js 1.43 kB 0 [emitted] mainvendor.c2330c22cd2decb5da5a.js 1.43 kB 1 [emitted] vendor 不要在开发环境中使用 [chunkhash]，这会导致每次的编译时间边长。把开发环境和生成环境的配置文件分开，在开发环境使用 [name].js ，在生产环境中使用 [name].[chunkhash].js 从 webpack 编译状态（compilation stats）中获取文件名在开发环境中，你只需要在 HTML 中引入你的文件就可以了。 &lt;script src="main.js"&gt;&lt;/srcipt&gt; 然而，在生产环境中，我们每次都会得到一个不同的文件名： &lt;script src="main.12312123t234.js"&gt;&lt;/srcipt&gt; 为了能够在 HTML 中引入正确的文件，我们需要了解一些构建的信息。这可以通过下面这个插件来从 webpack 编译状态（compliation stats） 中提取出来。 // webpack.config.jsconst path = require('path');module.exports = &#123; /*...*/ plugins: [ function() &#123; this.plugin("done", function(stats) &#123; require("fs").writeFileSync( path.join(__dirname, "…", "stats.json"), JSON.stringify(stats.toJson())); &#125;); &#125; ]&#125;; 或者，通过下面这些插件来暴露 JSON 文件： https://www.npmjs.com/package/webpack-manifest-plugin https://www.npmjs.com/package/assets-webpack-plugin 一个简单的通过 webpack-manifest-plugin 输出的文件如下： &#123; "main.js": "main.155567618f4367cd1cb8.js", "vendor.js": "vendor.c2330c22cd2decb5da5a.js"&#125; 接下来的事情就由你的服务来决定了。这有一个很不错的例子 walk through for Rails-based projects. 使用 Node.js 的服务端渲染的话可以使用 webpack-isomorphic-tools. 如果你的应用不需要依赖服务端渲染的话，那完全可以直接生成一个 index.html. 可以使用下面这两个插件来完成： https://github.com/ampedandwired/html-webpack-plugin https://github.com/szrenwei/inline-manifest-webpack-plugin 确定的 hashes (Deterministic hashes)为了压缩生成文件的大小，webpack 使用 id 代替名字来识别模块。再编译过程中，id 已经被生成，映射到代码块的名字并且放到一个 JavaScript 对象中，被叫做代码块清单（ chunk manifest）。它会被放到入口文件中，确保打包后的文件能够正常工作。 这会有和之前一样的问题：无论修改任何地方的文件，即使其它地方都没有修改，更新后的入口需要包含清单文件。这会生成一个新的 hash 值，导致问们的入口文件名修改，无法享受长期缓存带来的好处。 为了解决这个问题，我们应该使用 https://github.com/diurnalist/chunk-manifest-webpack-plugin ，一个可以把清单文件提取出来单独放到一个 JSON 文件中。这是更新后的配置文件，会生成 chunk-manifest.json 并放到我们打包后的文件夹下面： // webpack.config.jsvar ChunkManifestPlugin = require('chunk-manifest-webpack-plugin');module.exports = &#123; // your config values here plugins: [ new ChunkManifestPlugin(&#123; filename: "chunk-manifest.json", manifestVariable: "webpackManifest" &#125;) ]&#125;; 当我们从入口文件中移除掉清单文件后，那么我们就需要手动把这个文件提供给 webapck 使用。在上面的例子中你可能注意到 manifestVariable 这个选项。这是一个全局变量，一个供 webpack 来查找清单 JSON 文件，这也是为什么我们需要在代码包前面引入到 HTML 中。在 HTML 中写入 JSON 文件的内容是很容易，那么我们的 HTML 文件的 head 部分就会向下面这样： &lt;html&gt;&lt;head&gt; &lt;script&gt; //&lt;![CDATA[ window.webpackManifest = &#123;"0":"main.3d038f325b02fdee5724.js","1":"1.c4116058de00860e5aa8.js"&#125; //]]&gt; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 最终的 webpack.config.js 文件如下： var path = require('path');var webpack = require('webpack');var ManifestPlugin = require('webpack-manifest-plugin');var ChunkManifestPlugin = require('chunk-manifest-webpack-plugin');var WebpackMd5Hash = require('webpack-md5-hash');module.exports = &#123; entry: &#123; vendor: './src/vendor.js', main: './src/index.js' &#125;, output: &#123; path: path.join(__dirname, 'build'), filename: '[name].[chunkhash].js', chunkFilename: '[name].[chunkhash].js' &#125;, plugins: [ new webpack.optimize.CommonsChunkPlugin(&#123; name: "vendor", minChunks: Infinity, &#125;), new WebpackMd5Hash(), new ManifestPlugin(), new ChunkManifestPlugin(&#123; filename: "chunk-manifest.json", manifestVariable: "webpackManifest" &#125;) ]&#125;; 如果使用 webpack-html-plugin ,那么你可以使用 inline-manifest-webpack-plugin 来做这件事。 使用这个配置，那么第三方代码块（vendors chunkd）将不会变化，除非你修改它的代码或者依赖。 垫片（Shimming）webpack 作为了个模块打包工具，可以支持的模块系统包括 ES2015 modules, CommonJs 和 AMD. 但是很多情况下，当我们使用第三方库的时候，我们看到他们会依赖一个全局变量比如 $ 或者说 jquery. 它们也可能创建一些需要暴露出来的新的全局变量。我们来看几种不同的方式来使 webpack 能够理解这些非模块（broken modules）的文件。 最好使用在 dist 文件下没有打包压缩过的 CommonJs/AMD 文件（Prefer unminified CommonJS/AMD files over bundled dist versions.）大多数模块会在 package.json 的 main 字段中指定它们的 dist 版本。这对大多数开发者来说都是非常有用的，对 webpack 来说最好设置一个别名到它们的 src 目录下面，这样能够使 webpack 更好的优化依赖。但是，在很多情况下使用 dist 版本也不会有什么大的问题。 // webpack.config.jsmodule.exports = &#123; ... resolve: &#123; alias: &#123; jquery: "jquery/src/jquery" &#125;&#125;&#125;; provide-plugin通过使用 [provide-plugin](https://webpack.js.org/plugins/provide-plugin) 使这个模块在所有通过 webpack 引用的模块中作为一个可用的变量。只有当你使用了这个变量后，对应的模块才会被引用进来。很多古老的模块通过使用特定的全局变量，比如 jQuery 的 $ 和或者 jQuery. 在这个场景下，你可以提前在 webpack 中配置为 var $=requrei(&#39;jquery&#39;) ，在每一次遇到全局 $ 标识符。 module.exports = &#123; plugins: [ new webpack.ProvidePlugin(&#123; $: 'jquery', jQuery: 'jquery' &#125;) ]&#125;; imports-loader[imports-loader](https://webpack.js.org/loaders/imports-loader/) 将必须要的全局变量插入到传统模块中。比如，一些传统模块依赖 this 指向 window 对象。这会导致一个问题，当模块被执行在 CommonJS 上下文的时候， this 指向为 module.exports.在这种情况下，你可以通过 imports-loader重写 this. webpack.config.js module.exports = &#123; module: &#123; rules: [&#123; test: require.resolve("some-module"), use: 'imports-loader?this=&gt;window' &#125;] &#125;&#125;; 它支持不同的模块类型，比如 AMD，CommonJS 同时也支持传统模块。可是，通常情况下它会去检查 define 变量，然后使用一些奇怪（quirky）的代码去暴露这些属性。在这种情况下，通过设置 define = false 来强制CommonJS 路径可能会有一些帮助。 webpack.config.js module.exports = &#123; module: &#123; rules: [&#123; test: require.resolve("some-module"), use: 'imports-loader?define=&gt;false' &#125;] &#125;&#125;; exports-loader假设一个库文件创建了一个全局变量，期待它的消费者去使用。在这种情况下，我们应该使用 [exports-loader](https://webpack.js.org/loaders/exports-loader/), 来暴露一个 CommonJS 风格的全局变量。比如，为了暴露 file 为 file，helpers.parse 为 parse: webpack.config.js module.exports = &#123; module: &#123; rules: [&#123; test: require.resolve("some-module"), use: 'exports-loader?file,parse=helpers.parse' // adds below code the the file's source: // exports["file"] = file; // exports["parse"] = helpers.parse; &#125;] &#125;&#125;; script-loader[script-loader](https://webpack.js.org/loaders/script-loader/) 会在全局上下文里面解析代码，就和你在 HTML 中添加了一个 script 标签一样。在这种情况下，理论上所有的模块都应该正常的运行。 这个文件会被作为字符串打包在代码中。不会被 webpack 压缩，所以请使用压缩后的版本。同样这种情况无法使用 webpack 提供的开发工具。 假设你有一个 legacy.js 文件包含： GLOBAL_CONFIG = &#123;&#125; 使用 script-loaderrequire('script-loader!legacy.js') 一般会得到这样的结果： eval('GLOBAL_CONFIG = &#123;&#125;') noParse 选项当没有 AMD/CommonJS 风格的模块，同时你需要在 dist 中引入，你可以把这个模块标识为 [noParse](https://webpack.js.org/configuration/module/#module-noparse). 这样 webpack 就只会引入这个模块但是不会去做任何处理，这样也可以减少构建的时间。 任何需要 AST 支持的，比如 ProvidePlugin, 都是不会工作的。 module.exports = &#123; module: &#123; noParse: /jquery|backbone/ &#125;&#125;; 编写一个库文件webpack 是一个工具，可以用来打包应用代码，同样也可以用来打包库代码。如果你是一个 JavaScript 库的作者，正在寻找精简打包代码的流程，那么这个章节的内容会对你很有帮助。 编写一个库（Author a Library）我们这有一个精简的包装库来把数字 1 到 5 转换到对应的单词，反之亦然。 看起来可能是这样的： src/index.js import _ from 'lodash';import numRef from './ref.json';export function numToWord(num) &#123; return _.reduce(numRef, (accum, ref) =&gt; &#123; return ref.num === num ? ref.word : accum; &#125;, '');&#125;;export function wordToNum(word) &#123; return _.reduce(numRef, (accum, ref) =&gt; &#123; return ref.word === word &amp;&amp; word.toLowerCase() ? ref.num : accum; &#125;, -1);&#125;; 库的使用规范如下： //ES2015modulesimport*aswebpackNumbersfrom'webpack-numbers';...webpackNumbers.wordToNum('Two')//outputis2...//CommonJSmodulesvarwebpackNumbers=require('webpack-numbers');...webpackNumbers.numToWord(3);//outputisThree...//Asascripttag&lt;html&gt;...&lt;scriptsrc="https://unpkg.com/webpack-numbers"&gt;&lt;/script&gt;&lt;script&gt;.../*webpackNumbersisavailableasaglobalvariable*/webpackNumbers.wordToNum('Five')//outputis5...&lt;/script&gt;&lt;/html&gt; 完整的库配置和代码放在这里 webpack-library-example. 配置 webpack那么接下来的事情就是打包这个库 • 不打包 lodash，但是会被它的消费者引入 • 命名这个库为 webpack-numbers, 并且变量为 webpackNumbers • 库可以通过 import webapckNumbers from &#39;webpack-numbers&#39; 或者 require(&#39;webpack-numbers&#39;) 来引入 • 当通过 script 标签引入的时候，可以通过全局变量 webpackNumbers 来访问 • 可以在 Node.js 中使用 添加 webpack添加基础 webpack 配置。 webpack.config.js module.exports = &#123; entry: './src/index.js', output: &#123; path: './dist', filename: 'webpack-numbers.js' &#125;&#125;; 这将添加一个基础配置来打包这个库。 添加 Loaders但是如果没有对应 loaders 去解析代码是没有办法工作的。这里，我们添加 json-loader 来添加对 json 文件的解析。 webpack.config.js module.exports = &#123; // ... module: &#123; rules: [&#123; test: /.json$/, use: &apos;json-loader&apos; &#125;] &#125;&#125;; 添加 externals现在，如果执行 webpack 命令，你会发现一个提交较大的代码包被生成。如果你去检查代码，会发现 ladash 被打包到了代码包中。对于你的库来说把 lodash 打包在一起使完全没有必要的。 可以通过 externals 配置： webpack.config.js module.exports = &#123; ... externals: &#123; "lodash": &#123; commonjs: "lodash", commonjs2: "lodash", amd: "lodash", root: "_" &#125;&#125;...&#125;; 这意味着在使用者的环境下你的库会期望依赖 lodash 。 添加 libraryTarget为了这个库能够被广泛的使用，我们需要让它在不同的环境下有相同的表现。比如， CommonJS，AMD，Node.js 或者作为一个全局变量。 为了达到这个目的，需要在 webpack 配置中添加 library 属性。 webpack.config.js module.exports = &#123; ... output: &#123;... library: 'webpackNumbers'&#125;...&#125;; 这能够你的库被引入的时候可以作为一个全局变量被访问。为了能够在其它情况下使用，在配置中继续添加 libraryTarget 的值： webpack.config.js module.exports = &#123; ... output: &#123;... library: 'webpackNumbers', libraryTarget:'umd' // Possible value - amd, commonjs, commonjs2, commonjs-module, this, var&#125;...&#125;; 如果 library 设置了，但是 libraryTarget没有配置，那么 libraryTarget 默认为 var 就像在 config reference 中指定的一样。 最后一步调整生产环境下的配置文件 将打包后的文件添加到 package.json 中指定的字段里面。 package.json &#123; ... "main": "dist/webpack-numbers.js", "module": "src/index.js", // To add as standard module as per https://github.com/dherman/defense-of-dot-js/blob/master/proposal.md#typical-usage ...&#125; 现在你可以把它作为一个 npm 模块发布了，并且在 unpkg.com 里面向你的用户传播了。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【翻译向】webpack2 指南（中）]]></title>
    <url>%2F2017%2F01%2F18%2Fwebpack2-guide-2%2F</url>
    <content type="text"><![CDATA[动态模块替换（Hot Module Repalcement -React）就像之前 理念页面 中解析的细节那样，动态模块替换（HMR）会在应用运行时动态的替换、添加或者删除模块而不用重新刷新页面。 HMR 非常有用，当应用只有一个状态树（single state tree）时。 下面介绍的方法描述中使用了 Babel 和 React ,但这并不是使用 HRM 所必须的工具。 项目配置这里会指导你如何用 Babel， React 和 PostCss 一起使用 HMR 去演示一个项目。为了能够跟着下面走下去，需要把这些依赖添加到 package.json 中去。 为了使用 HMR，你需要如下这些依赖： npm install --save-dev babel@6.5.2 babel-core@6.13.2 babel-loader@6.2.4 babel-preset-es2015@6.13.2 babel-preset-react@6.11.1 babel-preset-stage-2@6.13.0 css-loader@0.23.1 postcss-loader@0.9.1 react-hot-loader@3.0.0-beta.6 style-loader@0.13.1 webpack@2.1.0-beta.25 webpack-dev-server@2.1.0-beta.0 同时，为了达到我们演示的目的，还需要： npm install --save react@15.3.0 react-dom@15.3.0 Babel Config.babelrc 文件应该如下： &#123; "presets": [ ["es2015", &#123;"modules": false&#125;], // webpack understands the native import syntax, and uses it for tree shaking "stage-2", // Specifies what level of language features to activate. // Stage 2 is "draft", 4 is finished, 0 is strawman. // See https://tc39.github.io/process-document/ "react" // Transpile React components to JavaScript ], "plugins": [ "react-hot-loader/babel" // Enables React code to work with HMR. ]&#125; Webpack Config const &#123; resolve &#125; = require('path');const webpack = require('webpack');module.exports = &#123; entry: [ 'react-hot-loader/patch', // activate HMR for React 'webpack-dev-server/client?http://localhost:8080', // bundle the client for webpack-dev-server // and connect to the provided endpoint 'webpack/hot/only-dev-server', // bundle the client for hot reloading // only- means to only hot reload for successful updates './index.js' // the entry point of our app ], output: &#123; filename: 'bundle.js', // the output bundle path: resolve(__dirname, 'dist'), publicPath: '/' // necessary for HMR to know where to load the hot update chunks &#125;, context: resolve(__dirname, 'src'), devtool: 'inline-source-map', devServer: &#123; hot: true, // enable HMR on the server contentBase: resolve(__dirname, 'dist'), // match the output path publicPath: '/' // match the output `publicPath` &#125;, module: &#123; rules: [ &#123; test: /\.js$/, use: [ 'babel-loader', ], exclude: /node_modules/ &#125;, &#123; test: /\.css$/, use: [ 'style-loader', 'css-loader?modules', 'postcss-loader', ], &#125;, ], &#125;, plugins: [ new webpack.HotModuleReplacementPlugin(), // enable HMR globally new webpack.NamedModulesPlugin(), // prints more readable module names in the browser console on HMR updates ],&#125;; 上面有很多配置，但不是所有都和 HMR 有关。可以通过查阅 webpack-dev-server options 和concept pages 来加深理解。 我们基础设想是这样的，你的 JavaScript 入口文件在 ./src/index.js 且你使用 CSS Module 来编写样式文件。 配置文件中需要重点关注的是 devServer 和 entry key. HotModueReplacementPlugin 同样需要被包含在 plugins key 中。 为了达到目的，我们引入了两个模块： react-hot-loader 添加到了入口中， 是为了能够使 React 支持 HMR 为了更好的理解 HMR 每次更新的时候做了哪些事情，我们添加了 NamedModulePlugin Code// ./src/index.jsimport React from 'react';import ReactDOM from 'react-dom';import &#123; AppContainer &#125; from 'react-hot-loader';// AppContainer is a necessary wrapper component for HMRimport App from './components/App';const render = (Component) =&gt; &#123; ReactDOM.render( &lt;AppContainer&gt; &lt;Component/&gt; &lt;/AppContainer&gt;, document.getElementById('root') );&#125;;render(App);// Hot Module Replacement APIif (module.hot) &#123; module.hot.accept('./components/App', () =&gt; &#123; const NewApp = require('./components/App').default render(NewApp) &#125;);&#125; // ./src/components/App.jsimport React from 'react';import styles from './App.css';const App = () =&gt; ( &lt;div className=&#123;styles.app&#125;&gt; &lt;h2&gt;Hello, &lt;/h2&gt; &lt;/div&gt;);export default App; .app &#123; text-size-adjust: none; font-family: helvetica, arial, sans-serif; line-height: 200%; padding: 6px 20px 30px;&#125; 一个需要特别注意的是 module 的引用： Webpack 会暴露出 module.hot 给我们的代码，当我们设置 devServer: { hot: true } 时； 这样我们可以使用 module.hot 来给特定的资源弃用 HMR （这里是 App.js）. 这里有一个非常重要的 API module.hot.accept ,用来决定如何处理这些特定的依赖。 需要注意的是，webpack2 内建支持 ES2015 模块语法，你不需要在 module.hot.accept 中重新引用跟组件。为了达到这个目的，需要在 .babelrc 配置 Babel ES2015 的预先设置： ["es2015", &#123;"modules": false&#125;] 就像我们在之前 Babel Config 中配置的那样。需要注意，禁用 Babel 的模块功能 不仅仅是为了启用 HMR。如果你不关掉这个配置，那么你会碰到需要问题。 如果你在 webpack2 的配置文件中使用 ES6 模块，并且你按照 #3 修改了 .babelrc，那么你需要使用 require 语法来创建两个 .babelrc 文件： 一个放在根目录下面并配置为 &quot;presets: [&quot;es2015&quot;]&quot; 一个放在 webpack 要编译的文件夹下，比如在这个例子中，就是 src/所以在这个案例中，module.hot.accept 会执行 render 方法无论 src/compoents/App.js 或者其它的依赖文件变化的时候 ——这意味着当 App.css 被引入到 App.js 中以后，即使是 App.css 被修改，render 方法同样会被执行。 Index.html入口页面需要被放在页面 dist 下面，webpack-dev-server 的运行需要这个文件。 &lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Example Index&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="root"&gt;&lt;/div&gt;&lt;script src="bundle.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Package.json最后，我们需要启动 webpack-dev-server 来打包我们的代码并且看看 HMR 是如何工作的。我们可以使用如下的 package.json 入口： &#123; "scripts" : &#123; "start" : "webpack-dev-server" &#125;&#125; 执行 npm start, 打开浏览器输入 http://localhost:8080, 应该可以看到下面这些项展示在 console.log中： dev-server.js:49[HMR] Waiting for update signal from WDS…only-dev-server.js:74[HMR] Waiting for update signal from WDS…client?c7c8:24 [WDS] Hot Module Replacement enabled. 然后编辑并且修改 App.js 文件，你会在 console.log 中看到类似如下的日志： [WDS] App updated. Recompiling…client?c7c8:91 [WDS] App hot update…dev-server.js:45 [HMR] Checking for updates on the server…log-apply-result.js:20 [HMR] Updated modules:log-apply-result.js:22 [HMR] - ./components/App.jsdev-server.js:27 [HMR] App is up to date. 注意 HMR 指出了更新模块的路径。这是因为我们使用了 NamedModulesPlugin. 开发环境（Development）这个章节介绍在开发过程中可以使用的一些工具。 需要注意，不能在生产环境使用 Source Map当 JS 发生异常的时候，我们需要指导是哪一个文件的哪一行出错了。但是当文件都被 webpack 打包以后，找问题会变得很麻烦。Source Map 就是为了解决这个问题的。它有很多不同的选项，每一种都有的好处和不足。在一开始，我们使用： devtool: "cheap-eval-source-map" 选择一个工具（Choosing a Tool）Webpack 可被用于监视模式（watch mode）。这种模式下， webpack 会监视你的文件，当它们有变动的时候就会重编译。Webpack-dev-server 提供了一个很方便使用的开发环境的服务，并且支持自动刷新功能。如果你已经有了一个开发环境的服务，并且希望能够拥有更好的适应性，那么 webpack-dev-middleware 可以被用作一个中间件来达到这个目的。 Webpack-dev-server 和 webpack-dev-middleware 实在内存中进行编译的，这意味着打包后的代码包并不会保存到本地磁盘中。这回使打包变得很快，同时不会产生很多临时文件来污染你的本地文件系统。 大多数情况下，你都会想要去使用 webpack-dev-server， 因为它使用起来很方便，而且提供了许多开箱即用的功能。 Webpack 监视模式（wtach mode）Webpack 的监视模式会检测文件的变动。只要变动被检测到，它就会重新进行一次编译。我们希望它的编译过程能有一个很好的进度展示。那么就执行以下命令： webpack --progress --watch 随便修改一个文件然后保存，你就会看到重新编译的过程。 监视模式没有考虑任何和服务有关的问题，所以你需要自己提供一个服务。一个简单的服务就是 [server](https://github.com/tj/serve). 当安装好后（npm i server -g），在你打包后的文件目录下运行： server 当每次重新编译后，你都需要手动的去刷新浏览器。 webpack-dev-serverwebpack-dev-server 提供一个支持自动刷新的服务。 首先，确认你 index.html 页面里面已经引用了你的代码包。我们先假设 output.filename 设置为 bundle.js: &lt;script src="/bundle.js"&gt;&lt;/srcipt&gt; 从 npm 安装 webpack-dev-server： npm install webpack-dev-server --save-dev 然后就可以执行 webpack-dev-server 的命令了： webpack-dev-server --open 上面的命令会自动打开你的浏览器并指定到 http://localhost:8080. 修改一下你的文件并保存。你会发现代码被重新打包了，当打包完成的时候，页面会自动刷新。如果没有如愿达到效果，那么你需要调整 watchOptions(https://webpack.js.org/configuration/dev-server#devserver-watchoptions-). 现在你有了一个可以自动刷新的服务，接下来我们看如何启用动态模块替换（Hot Module Replacement）。这是一个可以提供不刷新页面替换模块的接口，查看这里了解更多 。 webpack-dev-server 可以做很多的事情，比如代理请求到你的后端服务。想了解更多的配置项，那就查看 devServer 的文档吧。 webpack-dev-middlewarewebpack-dev-middleware 适用于基于中间件的链接堆栈（好难翻译）。当你已经有一个 Node.js 服务或者你想要完全的控制服务的时候会很有用。 这个中间件会让文件编译在内存中进行。当一个编译在进行过程中，它会延迟一个文件请求，直到它编译完成。 首先从 npm 上安装： npm install express webpack-dev-server --save-dev 作为一个例子，我们可以这样使用中间件： var express = require("express");var webpackDevMiddleware = require("webpack-dev-middleware");var webpack = require("webpack");var webpackConfig = require("./webpack.config");var app = express();var compiler = webpack(webpackConfig);app.use(webpackDevMiddleware(compiler, &#123; publicPath: "/" // Same as `output.publicPath` in most cases.&#125;));app.listen(3000, function () &#123; console.log("Listening on port 3000!");&#125;); 根据你在 output.publicPath 和 output.filename 中的配置，你打包的代码应该可以通过 http://localhost:3000/bundle.js 访问。 默认情况下使用的是监视模式。它还支持懒模式（lazy mode），只有在有请求进来的时候才会重新编译。 配置如下： app.use(webpackDevMiddleware(compiler, &#123; lazy: true, filename: "bundle.js" // Same as `output.filename` in most cases.&#125;)); 还有许多其它有用的选项，详细内容可以查看 文档. 为生产环境构建（Building for Production）本章介绍如何用 webpack 来做生产环境的构建。 一条自动化的方式执行 webpack -p(等同于 webpack --optimize--minimize --define process.env.NODE_ENV=&quot;production&quot;).这会执行以下几个步骤： 使用 UglifyJsPlugin 压缩文件 执行了 LoaderOptionsPlugin, 查看文档 设置 Node 的环境变量 源码压缩webpack 使用 UglifyJsPlugin 来压缩源码，通过执行 UglifyJs 来达到压缩输出代码的目的。这个插件支持所有 UgilfyJs 的功能。在命令行里输入 --optimize-minimize ，那么相当与在配置文件中添加了以下配置： // webpack.config.jsconst webpack = require('webpack');module.exports = &#123; /*...*/ plugins:[ new webpack.optimize.UglifyJsPlugin(&#123; sourceMap: options.devtool &amp;&amp; (options.devtool.indexOf("sourcemap") &gt;= 0 || options.devtool.indexOf("source-map") &gt;= 0) &#125;) ]&#125;; 这样，基于 devtools option ，在打包的时候会生成 Source Map. 资源映射（Source Map）我们推荐在开发环境启用 Source Map. 因为在 debug 或者测试的时候很有用。Webpack 可以生成包含在代码包或者分离文件中的 inline Source Map. 在配置文件中，通过修改 devtools 配置来设置 Source Map 类型。目前我们支持七种不同类型的 Source Map. 可以在具体文档中找到更加详细的介绍。 一个比较好好的选择是使用 cheap-module-source-map，可以将源映射简化为每行映射(simplifies the Source Maps to a single mapping per line)。 Node 环境变量执行 webpack -p( --define process.env.NODE_EMV=&quot;production&quot;) 会通过如下的配置调用 DefinePlugin: // webpack.config.jsconst webpack = require('webpack');module.exports = &#123; /*...*/ plugins:[ new webpack.DefinePlugin(&#123; 'process.env.NODE_ENV': JSON.stringify('production') &#125;) ]&#125;; DefindPlugin 会在源码中进行查找和替换的工作。所有找到的 process.env.NODE_ENV 都会被替换为 production. 这样，类似与 if(process.env.NODE_ENV !==&#39;procution&#39;) console.log(…) 这样的代码就会被 UnglifyJs 认为等同于 if(false) console.log(…) . 一个手动的方式：为 webpack 配置不同环境变量下的配置文件一个最简单的方式来为 webpack 配置不同环境变量下的配置文件的方法就是建立多个配置文件。比如： dev.js // 此处官网文档有语法错误，我改了一下module.exports = function (env) &#123; return &#123; devtool: 'cheap-module-source-map', output: &#123; path: path.join(__dirname, '/../dist/assets'), filename: '[name].bundle.js', publicPath: publicPath, sourceMapFilename: '[name].map' &#125;, devServer: &#123; port: 7777, host: 'localhost', historyApiFallback: true, noInfo: false, stats: 'minimal', publicPath: publicPath &#125; &#125;&#125; prod.jsmodule.exports = function (env) &#123; return &#123; output: &#123; path: path.join(__dirname, '/../dist/assets'), filename: '[name].bundle.js', publicPath: publicPath, sourceMapFilename: '[name].map' &#125;, plugins: [ new webpack.LoaderOptionsPlugin(&#123; minimize: true, debug: false &#125;), new UglifyJsPlugin(&#123; beautify: false, mangle: &#123; screw_ie8: true, keep_fnames: true &#125;, compress: &#123; screw_ie8: true &#125;, comments: false &#125;) ] &#125;&#125; 然后把我们的 webpack.config.js 的内容改成下面这样： function buildConfig(env) &#123; return require('./config/' + env + '.js')(&#123; env: env &#125;)&#125;module.exports = buildConfig(env); 最后，在 package.json 中添加如下命令： "build:dev": "webpack --env=dev --progress --profile --colors", "build:dist": "webpack --env=prod --progress --profile --colors", 可以看到，我们把环境变量传给了 webpack.config.js 文件。从这里我们使用一个简单的方式通过传递环境变量来决定使用正确的配置文件。 一个更加高级的途径是我们有一个基础配置文件，里面有所有共通的功能，然后在不同环境变量下的不同功能通过指定特定的文件，然后使用 webpack-merge 来合并成一个完整的配置。这样可以避免写很多重复的代码。比如，类似与解析 js,ts,png,jpeg 等都是共通的功能，需要放在基础配置文件里面： base.js module.exports = function() &#123; return &#123; entry: &#123; 'polyfills': './src/polyfills.ts', 'vendor': './src/vendor.ts', 'main': './src/main.ts' &#125;, output: &#123; path: path.join(__dirname, '/../dist/assets'), filename: '[name].bundle.js', publicPath: publicPath, sourceMapFilename: '[name].map' &#125;, resolve: &#123; extensions: ['', '.ts', '.js', '.json'], modules: [path.join(__dirname, 'src'), 'node_modules'] &#125;, module: &#123; loaders: [&#123; test: /\.ts$/, loaders: [ 'awesome-typescript-loader', 'angular2-template-loader' ], exclude: [/\.(spec|e2e)\.ts$/] &#125;, &#123; test: /\.css$/, loaders: ['to-string-loader', 'css-loader'] &#125;, &#123; test: /\.(jpg|png|gif)$/, loader: 'file' &#125;, &#123; test: /\.(woff|woff2|eot|ttf|svg)$/, loader: 'url-loader?limit=100000' &#125;], &#125;, plugins: [ new ForkCheckerPlugin(), new webpack.optimize.CommonsChunkPlugin(&#123; name: ['polyfills', 'vendor'].reverse() &#125;), new HtmlWebpackPlugin(&#123; template: 'src/index.html', chunksSortMode: 'dependency' &#125;) ], &#125;;&#125; 然后使用 webpack-merge 来合并特定环境变量下指定的配置文件。来看一个合并生产环境下特定配置的例子（和上面 prod.js 对比以下）： prod.js(updated) const webpackMerge = require('webpack-merge');const commonConfig = require('./base.js');module.exports = function(env) &#123; return webpackMerge(commonConfig(), &#123; plugins: [ new webpack.LoaderOptionsPlugin(&#123; minimize: true, debug: false &#125;), new webpack.DefinePlugin(&#123; 'process.env': &#123; 'NODE_ENV': JSON.stringify('prod') &#125; &#125;), new webpack.optimize.UglifyJsPlugin(&#123; beautify: false, mangle: &#123; screw_ie8: true, keep_fnames: true &#125;, compress: &#123; screw_ie8: true &#125;, comments: false &#125;) ] &#125;)&#125; 可以注意到，在 ‘prod.js’ 中主要有三处更新，分别是： • 通过 &apos;webpack-meger&apos; 合并了 `base.js` • 把 `output` 属性移到了 `base.js` 中。我们只要关心在 `base.js` 中以外的不同的配置就可以了 • 通过 `DefinePlugin` 把 `process.env.NODE_ENV` 设置为 `prod`. 这样，整个应用代码中的 `process.env.NODE_ENV` 都有一个为 `prod` 的值了。 哪些需要在不同的环境变量下保持一致都由你来决定。这里只是通过一个 DEMO 来典型的说明一下如何在不同的环境变量下保持部分配置的统一。 可以看到，webpack-merge 是多么强大，可以让我们避免写很多重复的代码（外国人话真多）。 React 懒加载（Lazy Loading - React）通过使用高阶函数可以使一个组件懒加载它的依赖而不需要它的消费者知道，或者使用一个接收函数或者模块的组件，可以使一个消费者可以懒加载它的子组件而不需要它的子组件知道。 组件懒加载先看一个消费者选择去懒加载一些组件。importLazy 是一个返回 defualt 属性的函数，这是为了能和 Babel/ES2015 互通。如果你不需要，可以忽略掉 importLazy 方法。importLazy 只是简单的返回了通过 export default 暴露出的模块。 &lt;LazilyLoad modules=&#123;&#123; TodoHandler: () =&gt; importLazy(import('./components/TodoHandler')), TodoMenuHandler: () =&gt; importLazy(import('./components/TodoMenuHandler')), TodoMenu: () =&gt; importLazy(import('./components/TodoMenu')),&#125;&#125;&gt; &#123;(&#123;TodoHandler, TodoMenuHandler, TodoMenu&#125;) =&gt; ( &lt;TodoHandler&gt; &lt;TodoMenuHandler&gt; &lt;TodoMenu /&gt; &lt;/TodoMenuHandler&gt; &lt;/TodoHandler&gt; )&#125;&lt;/LazilyLoad&gt; 高阶组件（Higher Order Component）作为一个组件，你可以确保整个组件本身的依赖是懒加载的。当一个组件依赖一个非常大的库文件的时候会很有用。假设我们要写一个支持代码高亮的 Todo 组件： class Todo extends React.Component &#123; render() &#123; return ( &lt;div&gt; &#123;this.props.isCode ? &lt;Highlight&gt;&#123;content&#125;&lt;/Highlight&gt; : content&#125; &lt;/div&gt; ); &#125;&#125; 我们可以确保只有当我们需要代码高亮功能的时候才去加载这个代价高昂的库文件： // Highlight.jsclass Highlight extends React.Component &#123; render() &#123; const &#123;Highlight&#125; = this.props.highlight; // highlight js is now on our props for use &#125;&#125;export LazilyLoadFactory(Highlight, &#123; highlight: () =&gt; import('highlight'),&#125;); 注意这个 Highlight 组件的消费者是如何在不知情的情况下被懒加载的。 完整的代码LazilyLoad 组件的源码，暴露了组件接口和高阶组件接口。 import React from 'react';class LazilyLoad extends React.Component &#123; constructor() &#123; super(...arguments); this.state = &#123; isLoaded: false, &#125;; &#125; componentWillMount() &#123; this.load(this.props); &#125; componentDidMount() &#123; this._isMounted = true; &#125; componentWillReceiveProps(next) &#123; if (next.modules === this.props.modules) return null; this.load(next); &#125; componentWillUnmount() &#123; this._isMounted = false; &#125; load(props) &#123; this.setState(&#123; isLoaded: false, &#125;); const &#123; modules &#125; = props; const keys = Object.keys(modules); Promise.all(keys.map((key) =&gt; modules[key]())) .then((values) =&gt; (keys.reduce((agg, key, index) =&gt; &#123; agg[key] = values[index]; return agg; &#125;, &#123;&#125;))) .then((result) =&gt; &#123; if (!this._isMounted) return null; this.setState(&#123; modules: result, isLoaded: true &#125;); &#125;); &#125; render() &#123; if (!this.state.isLoaded) return null; return React.Children.only(this.props.children(this.state.modules)); &#125; &#125;LazilyLoad.propTypes = &#123; children: React.PropTypes.func.isRequired,&#125;;export const LazilyLoadFactory = (Component, modules) =&gt; &#123; return (props) =&gt; ( &lt;LazilyLoad modules=&#123;modules&#125;&gt; &#123;(mods) =&gt; &lt;Component &#123;...mods&#125; &#123;...props&#125; /&gt;&#125; &lt;/LazilyLoad&gt; );&#125;;export const importLazy = (promise) =&gt; ( promise.then((result) =&gt; result.default));export default LazilyLoad; 提示 通过使用 bundle loader 可以语义化命名代码块，一次来智能的加载一组代码 确保你使用了 babel-preset-2015, 并且设置 modules 为 false，这允许 webpack 去处理 modules 公开路径？（Public Path）Webpack 提供了一个很长有用的功能，可以设置你应用中所有资源引用的基础路径。它被称之为 publicPath. 使用场景（Use case）这里有一些真实应用中的场景，通过这个功能来达到目的。 在构建的时候设置值在开发模式下，我们通常会把 assets/ 目录放在和入口页同级的目录下面。这样没有问题，但是假如在生产环境下你的静态资源是存放在 CDN 上那又该怎么办呢？ 可以很方便的通过环境变量来解决这个问题。假设我们有一个变量 ASSET_PATH: // 这里看起来好像有问题import webpack from 'webpack';// Whatever comes as an environment variable, otherwise use rootconst ASSET_PATH = process.env.ASSET_PATH || '/';export default &#123; output: &#123; publicPath: ASSET_PATH &#125;, plugins: [ // This makes it possible for us to safely use env vars on our code new webpack.DefinePlugin(&#123; 'process.env.ASSET_PATH': JSON.stringify(ASSET_PATH) &#125;) ]&#125;; 在开发中设置值（Set Value on the fly）另一种方式是在开发过程成设置 public 路径。Webpack 暴露了一个全局变量 __webpack_public_path__ 来让我们达到这个目的。所以在你的入口文件中，你可以这样做： __webpack_publick_path__ = process.en.ASSET_PATH; 如何来做都取决于你。当我们通过 DefinePlugin 进行了配置以后， process.env.ASSET_PATH 在任何地方都可以直接拿来使用。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【翻译向】webpack2 指南（上）]]></title>
    <url>%2F2017%2F01%2F17%2Fwebpack2-guide-1%2F</url>
    <content type="text"><![CDATA[前置定义Bundle 代码包Chunk 代码块 安装npm install webpack –save-dev 代码分割代码分割是 webpack 中最引人注目的功能之一。它允许你把代码分割成各种可以根据需求载入的代码包，就像一个用户浏览器去匹配路由一样，或者一个用户发出的事件。这允许你小的模块，允许你控制资源的载入优先级，如果使用得当的话，可以大大影响（降低）你应用的加载时间。 缓存和并行加载的资源分割第三方代码分割一个典型的应用会依赖很多第三方的框架和库文件。不像应用代码本身，这些第三方代码的变更非常频繁。如果我们保持这些库在它本身的代码包中，从应用代码本身分离出来，那么我们就可以使用浏览器的缓存策略去在一个长时间内把这些代码缓存到最终用户的机器上。 为了达到这个效果，第三方代码的 verndor 包的 hash 部分必须保持不变，不管应用代码如何变化。学习 如何通过 CommonsChunkPlugin 来分割 verndor/libray 代码。 CSS 分割你可能也想把样式文件分割成为一个单独的包，从应用逻辑总独立出来。这可以增强样式文件的可缓存性，并且允许浏览器在加载应用代码时并行加载你的样式文件，因此也可以避免 FOUC （一个无样式内容的闪屏）。学习 如何去分割 CSS 通过使用 ExtractTextWebpackPlugin. 按需代码分割虽然前面的资源分割需要用户在配置文件中预先指定分割点，但是也可以在应用代码中创建动态的分割点。 这个功能在有很多细微颗粒代码块时会很有用，举个例子，每一个应用的路由或者按照用户的预测行为。这可以使用户按需加载需要的资源。 通过 require.ensure() 来分割代码require.ensure 是一个 CommonJS 风格的方式去异步加载资源。通过添加 require.ensure([&lt;fileurl&gt;]) , 我们可以在代码中定义一个分割点。 Webpack 可以创建一个包含在这个分割点中的所有代码的代码包。学习 如何分割代码 通过使用 require.ensure(). TODO System.import() 代码分割 - CSS在 webpack 中，当你使用 css-loader 并且在 JavaScript 中引入 CSS 文件，那么 CSS 文件会被打包在你的 JavaScript 文件中。这有一个不好的地方，就是你无法使用浏览器异步并行加载 CSS 的能力。相反，你的页面会等到整个 JavaScript 文件加载完成，才完成了样式文件的加载。Webpack 可以通过使用 extract-text-webpack-plugin 和 css-loader 来把样式文件分离出来去解决这个问题。 使用 css-loader引入 css 到你的 JavaScript 中，需要使用 css-loader 去配置 webpack 的配置文件。 //webpack.config.jsmodules.exports = function(env)&#123; entry: '..', ... module: &#123; rules: [&#123; test: /\.css$/, exclude: /node_modules/, loader: 'css-loader' &#125;] &#125; ...&#125; 使用 extract-text-webpack-plugin - ExtractTextPlugin安装： npm I --save-dev extract-text-webpack-plugin 要使用这个 ExtractTextPlugin,需要通过两个步骤配置在 webpack.config.js 中。 在 lodaer 里面从之前的 css-loader 中适配，我们应该如下添加 ExtractTextPlugin. loader: ExtractTextPlugin.extract('css-loader?sourceMap') //Can be used without sourcemaps too. 在 plugin 里面new ExtractTextPlugin(&#123; filename: 'bundle.css', disable: false, allChunks: true &#125;) 通过这两步，就可以生成一个新的包含所有 CSS 模块的代码包，然后把他们添加到 index.html 的 heade 中去。可以通过 ExtractTextPlugin 去了解关于它 api 的更多信息。 完整的配置文件如下： var ExtractTextPlugin = require('extract-text-webpack-plugin');module.exports = function () &#123; return &#123; entry: './main.js', output: &#123; path: './dist', filename: 'bundle.js' &#125;, module: &#123; rules: [&#123; test: /\.css$/, exclude: /node_modules/, loader: ExtractTextPlugin.extract(&#123; loader: 'css-loader?sourceMap' &#125;) &#125;] &#125;, devtool: 'source-map', plugins: [ new ExtractTextPlugin(&#123; filename: 'bundle.css', disable: false, allChunks: true &#125;) ] &#125;&#125; 代码分割-库文件一个典型的应用会依赖很多第三方来提供框架或功能支持。项目中使用的固定版本的库/框架文件的代码一般不会有变动，然而应用本身的业务逻辑代码却经常会有变动。 把应用代码和库文件的代码打包在一起是一件非常低效的事情。这是因为浏览器可以根据缓存头缓存这些资源文件到本地而不用每次都去服务端或者 cdn 上去发请求重新获取，如果文件内容没有变动的话。为了能够享受这个好处，我们需要保持第三方文件的 hash 不变，无论应用本身的代码如何变化。 我们只有把应用代码和第三方代码分离开才可以达到这样的效果。 我们考虑一个一个简单的应用，它使用了 momentjs ，一个通常用来时间格式化的库。 安装 moment ： npm install --save moment Index 文件会引用 moment 作为一个依赖并且打印当前的时间： Index.js var moment = require('moment');console.log(moment().format()); 我们可以通过如下这个配置文件来打包这个应用 Webapck.config.js module.exports = function(env) &#123; return &#123; entry: './index.js', output: &#123; filename: '[chunkhash].[name].js', path: './dist' &#125; &#125;&#125; 当运行 webapck 命令的时候，如果你检查打包后的文件，你会发现 moment 和 index.js 都被打包在了 bundle.js 中。 这不是一个很好的解决方案。如果 index.js 修改了，那么这打包文件会重新构建，浏览器就需要重新去加载这个文件，即使 moment.js 文件并没有任何改动。 多个入口让我们缓和这个问题，我们给 moment 添加一个新的入口命名为 vendors. Webpack.config.js module.exports = function(env) &#123; return &#123; entry: &#123; main: './index.js', vendor: 'moment' &#125;, output: &#123; filename: '[chunkhash].[name].js', path: './dist' &#125; &#125;&#125; 现在执行 webpack 命令，我们会看到两个打包后的文件。如果你检查里面代码的话，你会看到 moment 的代码同时出现在两个代码包中。 为了解决这个问题，我们需要使用 CommonsChunkPlugin. CommonsChunksPlugin这是一个相当复杂的插件。它从根本上允许你从不同的代码包中提取出所有的相同模块并且把它们加入到共同的代码包中。如果这个相同的代码包不存在，那么就创建一个新的。 我们可以修改 webpack 的配置文件来使用这个 CommonsCunksPlugin Webpack.config.js var webpack = require('webpack');module.exports = function(env) &#123; return &#123; entry: &#123; main: './index.js', vendor: 'moment' &#125;, output: &#123; filename: '[chunkhash].[name].js', path: './dist' &#125;, plugins: [ new webpack.optimize.CommonsChunkPlugin(&#123; name: 'vendor' // Specify the common bundle's name. &#125;) ] &#125;&#125; 这样的话， moment 的代码就只会出现在 vendor 代码包中了。 清单文件（Manifest File）但是，如果我们可以修改应用的代码并且再次执行 webpack 命令，我们看到 vendors 文件的 hash 还是变化了。即使我们已经分离了 vendor 和 main 代码包，但是当应用代码发生修改的时候 vendor 还是变化了。 这意味着我们依旧不能享受浏览器缓存带来的好处，因为每一次重新编译都会修改 vendors 的 hash 值。 这个问题是因为每一次编译，webpack 生成一些 webpack 运行时代码，用来帮助 webpack 来做它的工作。当那里存在一个单独的代码包，运行时会驻留在其中。但当多个代码包被生成的时候，运行时代码会被提取到公共的模块中，就是这个 vendor 文件。 为了阻止这个，我们需要提取出运行时到一个分离的清单文件（Manifest File）。虽然我们又多创建另一个代码包，但它的开销也被我们在 vendor 文件上获得的长期缓存所带来的好处所抵消了。 Webpack.config.js var webpack = require('webpack');module.exports = function(env) &#123; return &#123; entry: &#123; main: './index.js', vendor: 'moment' &#125;, output: &#123; filename: '[chunkhash].[name].js', path: './dist' &#125;, plugins: [ new webpack.optimize.CommonsChunkPlugin(&#123; names: ['vendor', 'manifest'] // Specify the common bundle's name. &#125;) ] &#125;&#125;; 通过上面这个配置文件，我们会看到三个代码包被生成。vendor,main 和 manifest. 这样当应用代码修改的时候，重新打包后，修改的就只有 main 和 manifest 了。 manifest 被修改是因为里面有对生成文件 hash 值的引用。 代码分割-使用 RequireJS在这个章节，我们讨论 webpack 如何通过 require.ensure() 分割代码。 require.ensure()Webpack 静态分析给 require.ensure() 在代码中当构建和添加模块到分离的代码块中。这个新的代码块会被 webpack 在需要的时候通过 jsonp 引入。 它的语法如下： require.ensure(dependencies: String[], callback: function(require), chunkName: String) 依赖(dependencies)这是一个字符串数组，用来声明所有需要在执行回掉函数之前就需要预先加载好且可用的模块。 回调函数(callback)一个回调函数会被 webpack 执行一次当所有依赖(dependencies)都被加载以后。Require 对象的实现作为一个参数传递给这个回调函数。这样，我们可以更进一步 require 需要的依赖(dependencies)和其他需要执行的模块。 代码块名字(chunkName)代码块名字是一个用来命名通过 require.ensrue() 创建的代码块。通过给不同的 require.ensure() 创建的代码分割点分割出来的代码块一个相同的名字，我们可以确保所有的依赖都被打包到同一个代码块中。 我们来看一下如下结构的一个项目 \\ file structure | js --| | |-- entry.js | |-- a.js | |-- b.js webpack.config.js | dist // entry.jsrequire('a');require.ensure([], function(require)&#123; require('b');&#125;);// a.jsconsole.log('***** I AM a *****');// b.jsconsole.log('***** I AM b *****'); // webpack.config.jsmodule.exports = function(env) &#123; return &#123; entry: './js/entry.js', output: &#123; filename: 'bundle.js', path: './dist' &#125; &#125;&#125; 当运行 webpack 命令的时候，我们发现 webpack 创建了两个新的代码包，bundle.js 和 0.bundle.js. entry.js 和 a.js 被打包到了 bundle.js 中。 b.js 被打包到了 0.bundle.js require.ensure() 的陷阱空数组作为一个参数require.ensure([], function(require)&#123; require('./a.js');&#125;); 上面的代码确保一个分割点被创建， a.js 会被 webpack 单独的打包成一个文件。 依赖作为参数require.ensure(['./a.js'], function(require) &#123; require('./b.js');&#125;); 上面的代码，a.js 和 b.js 会被一起打包并且从主代码包中分离出来。但是只有 b.js 的内容被执行了。 a.js 的内容只是是可用的但并没有被执行。为了执行 a.js, 我们需要 require 它作为一个同步的方式比如 require(&#39;./a.js) ，这样 JavaScript 就可以执行它了。 依赖管理Ø es6 module Ø Commonjs Ø Amd 表达式依赖（require with expression）当你通过表达式去引入一个模块的时候，就会创建一个上下文，所以当编译的时候我们并不知道准确的模块是哪个。 例： require("./template/" + name + ".ejs"); Webpack 解析 require() 的调用，并且提取出来一些信息： Directory:./templateRegularexpression:/^.*\.ejs$/ 上下文模块（context module）一个上下文模块被生成。它包含了在这个文件夹下所有可以被上面的正则匹配所匹配到的模块的引用。上下文模块包含了一个把请求解释到模块 id 的 map.例： &#123; "./table.ejs": 42, "./table-row.ejs": 43, "./directory/folder.ejs": 44&#125; 上下文模块同样包含了一些运行时代码用来访问这个 map. 这意味着动态的引用可以被支持，但是会导致所有可能被用到的模块都被打包到了最终的代码包中。 require.context你可以通过 require.context() 方法创建你自己的上下文。它允许你传入一个用来查询的文件夹，一个用来决定是否递归查找子文件夹的标识，还有一个用来匹配文件的正则表达式。 Webpack 会在代码打包的时候解析 require.context() 它的语法如下： require.context(directory, useSubdirectories = false, regExp = /^\.\//) 例： require.context("./test", false, /\.test\.js$/);// a context with files from the test directory that can be required with a request endings with `.test.js`. require.context("../", true, /\.stories\.js$/);// a context with all files in the parent folder and descending folders ending with `.stories.js`. 上下文模块API（context module API）一个上下文模块暴露一个方法，它接收一个参数：请求的内容。暴露出来的函数有三个属性：resolve,key,id • resolve 是一个函数，执行后返回解析后的请求内容的模块 id • keys是一个函数，执行后返回一个数组，包含所有可能被上下文模块所请求的所有的模块的 id 当你想要通过正则匹配引入一个文件夹下所有模块时，这会非常有用： function importAll (r) &#123; r.keys().forEach(r);&#125;importAll(require.context('../components/', true, /\.js$/)) var cache = &#123;&#125;;function importAll (r) &#123; r.keys().forEach(key =&gt; cache[key] = r(key));&#125;importAll(require.context('../components/', true, /\.js$/));// At build-time cache will be polulated with all required modules. • `id` 是上下文模块生成的模块 id. 当使用 `module.hot.accept` 时，这会非常有用。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2016年终总结]]></title>
    <url>%2F2016%2F12%2F09%2F2016-year-end-summary%2F</url>
    <content type="text"><![CDATA[工作时间也真是快，从 15 年到现在算来我做前端开发也将近两年了，没想到这一路走过来这么顺利，运气真是挺好的。 当初自学三个月，然后投简历面试，就拿到了好几个 offer，一切都太顺利了。然后去了一家做互联网金融的公司，老大对我很好，然而待了一年多还是在今年五月份选择了离职。原因很简单，公司的开发模式过于保守，一直待下去真的不会有任何长进了， 整天干的活都像是美工干的活，公司很不重视前端，而且前后端不分离，同一份文件前后端两个人一起改，想想真是痛苦。 那离职了就要找工作，不得不说，找工作的经历真有意思。 找工作有一家创业公司，人家对我还比较满意，但就是薪资没谈妥，就算了，谁知道后来我都拿到另一家公司的 offer 了又说那个薪资可以接受了。 有一家外企，面试的时候对他们的工作环境非常满意，然而面试发挥太差，连 sass 的循环都写不出来，结果可想而知。面试官还很和蔼，说回去等消息吧，然后我出门不到五分钟就收到了短信，‘您不适合本公司的要求’，嗯，效率真高，挺喜欢这点。 有一家在滨江的大公司，面试通过了，薪资都谈妥了， Hr 说回去等 offer 吧，一般三天内就会发出来。我很高兴，第二天回原公司就提了离职。结果等了一星期还没收到 offer ，就打电话问，对方很不好意思的回答说，部门公司架构重组，我面试的那个事业部已经没了,,Ծ ㅂ Ծ,,，我也不好说什么了。 中途还有一堆不靠谱的公司，当然也有我能力不足没通过面试的。 有一个最直接就是蘑菇街的人问你能接受加班吗，我说偶尔可以，经常不行，然后人家来了一句，那不行，我们这边加班还是很严重的，几乎每天 11 点。然后，就没有然后了。后来小伙伴给内推了阿里，面天猫挂在了三面，又面了滨江的 B2B 部门。 到二面的时候，接到了网易的面试，面网易的时候谈的很高兴，双方都很满意，最后 hr 问说有没有在面其他公司，我说当然， 比如阿里也在面，现在已经到了二面。然后就有了下面的对话： Hr ：“那如果阿里和网易同时给你发 offer 你去哪个？“ 我当时随口一说，“哪个先发 offer 就去哪个” 然后当天晚上就电话通知我面试通过了，第二天就发了 offer。现在想想，我真是机智啊，O(∩_∩)O 网易找工作的事情就告一段落，来到网易。首先网易给我的第一印象就是，食堂真好（虽然已经吃腻了），仿佛回到了大学时候一样，然后妹子真多，嗯，真的。 不得不说大公司跟小公司还是有很多差别的。首先，流程上就很规范，不会出现说之前公司那种产品经理过来一会要这样一会要那样的事情，但同时也有弊端，就是会议太多。想想那些会议有没有必要开，还是有必要的，但是会议的整体效率，真是低啊。 一开始去网易除了业务上的需求，还自发奋勇接了几个前端技术部的非业务工作，可能这一点让老大觉得我积极性比较强，就又比较看好我。中途本来还要做个前端监控系统的，可惜刚搞好前期工作，负责人就离职了，项目也就搁置了。想想也是挺可惜的。 都说进了网易会长胖，然而短短半年时间，我竟瘦了七八斤。不得不说，工作还是挺忙的，每天都得八九点多才能下班。想想以前六点下班，下班后看两小时书，打俩小时游戏，然后躺床睡觉，劳逸结合，简直完美。现在一下班就跟死猪一样了，什么都不想干，游戏都懒得打，就刷刷微博、A、B 站然后就睡了。看书很少了，偶尔也看看一些前端相关的博客和文章。所以感觉这半年，除了工作经验上的积累，个人知识拓展上几乎是停滞的，长期这样下去肯定是不行的。 而且我们那条业务线负责人离职后，老大让我顶大梁。虽然这对我来说是个锻炼，但确实亚历山大，每天除了业务需求，还有一堆杂七杂八的事情要处理，搞得焦头烂额。 不过，还好。公司的同事都挺有意思的，上班整体也挺开心，这到挺好的。 生活翻了一下去年的日记，哦，不对，应该叫月记。看来日常生活上还是那个样子，跟去年没什么大的区别。 找房子一开年就又是找房子，原来的房东直接涨价 500 块，真心不能接受。就只能开始又一次找房子的旅程了，跑了很多小区，最后在原来房子附近的小区找到一个还行的，不过价格也真是高。这种每年都要找房子的感觉真是不爽。 找到的房子是个三室一厅的，就拉了个前同事入伙，开始三人合租的日子。 新室友养了只猫，挺可爱的， 就是那猫实在掉毛掉的厉害，猫主人又很少打扫，这里让人不太愉快。不过还好，大家关系都不错，周末一起看个电影吃个饭，偶尔也去西湖、九溪等地方逛逛，挺好的。 方向到现在都还是有点迷茫，还是不知道自己到底是个怎样的人，想要成为什么样的人。有点找不到方向的感觉 。 年初和同学聊天，聊到想在哪里发展。他说不太想待杭州，又不想回去，比较想去上海。然而年中就结婚并定居杭州了。我呢，是想回去又不想回去，跟所有出来工作的人一样，纠结。 总想活的潇洒一点，可又给自己画了很多条条框框，画地为牢，把自己困在原地。 果然，一个人想要改变自己还是挺难的。 目标先看看去年给自己定的目标吧： 在此给明年订个简单的规定： 每个月至少写一篇博客 至少每两周看一次电影 每两个月看一本书 加强身体锻炼 该追的美剧不能落下 除了 2，5 其他的一个都没完成，果然这执行力还是不行啊。 博客自从进了网易就没有更新过； 书，一年下来就看了四本，好多书买回来，连封皮都没撕； 锻炼身体，买了瑜伽毯，买了新的咏具，但锻炼总是断断续续的，一直没能坚持下来； 所以今年的计划就简单一点吧： 每个月至少一篇博客 每个月都要出去走走，哪怕一个人 书还是要看的，那就三个月一本书吧 身体还是要锻炼的，心里有这个事情就行 写一个个人项目，并发布出来，无论项目多水 感情→← 最后整体的感觉，就是这一年过的真快呀！转眼毕业都两年多了，有时都觉得挺可怕的，必须得再次告诫自己：Seize the day.]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>年终总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【翻译向】走进 Redux 之高级篇]]></title>
    <url>%2F2016%2F05%2F21%2Fstep-to-redux-3%2F</url>
    <content type="text"><![CDATA[异步的 Actions前几篇的教程里面，我们搭建了一个 todo 应用。这是一个完全同步的，每次一个 action 被 dispatched, state 都会即时更新。解析来，我们要搭建一个不同的，异步的应用。它使用 Reddit API 来展示一个选中栏目的头条。 Actions当你调用一个异步的 API 时，有两个至关重要的时刻：你开始调用的时刻，和你收到答复的时刻。 这两个时刻通常都会需要对应用的 state 做出变化；为此，你需要 dispatch 普通的将会被 reducers 同步处理的 actions. 通常，对于任意 API 请求，你将需要 dispatch 至少三次不同的 actions: 一个通知 reducers 请求开始的 action reducers 可能通过切换一个 state 中的 isFetching flag 来处理这个 action. 用来告诉 UI 是时候显示一个等待标识了。 一个通知 reducers 请求已经成功完成的 action reducers 可能通过把新数据合并到它控制的 state 中并重置 isFetching 来处理这个 action. UI 会隐藏等待标识，并展示获取到的数据。 一个通知 reducers 请求失败的 action reducers 可能通过重置 isFetching 来处理这个 action. 另外，有些 reducers 可能想要存储这个错误信息，这样可以让 UI 展示出来。 可能需要在 actions 添加一个专用的 status 字段：&#123;type: 'FETCH_POSTS'&#125;&#123;type: 'FETCH_POSTS', status: 'error', error: 'Oops'&#125;&#123;typs: 'FETCH_POSTS', status: 'success', response: &#123; ... &#125;&#125; 或者为它们定义单独的 types：&#123; type: 'FETCH_POSTS_REQUEST' &#125;&#123; type: 'FETCH_POSTS_FAILURE', error: 'Oops' &#125;&#123; type: 'FETCH_POSTS_SUCCESS', response: &#123; ... &#125; &#125; 选择一个拥有 flags 的单独的 action type, 或者多个 actions types, 这都取决与你。多个 types 会有更少的犯错空间，但这不是一个问题，如果你使用 redux-actions 这样的辅助库来生成 action creator 和 reducers 的话。 异步的数据流不使用 middlerware, Redux store 只提供同步的数据流。这是你通过 createStore() 得到的默认结果。 可以使用 applyMiddleware() 来增强 createStore(). 这不是必须的，但它可以让你通过一个便利的方法描述异步的 action 。 异步的 middleware 比如 redux-thunk 或 redux-promise 都包装了 store 的 dispatch() 方法，允许你 dispatch 除了 action 以外的内容，比如函数或者 Promise。你所使用的 middleware 可以以自己的方式解析你 dispatch 的任何内容，并继续传递 actions 给下一个 middleware。比如，支持 Promise 的 middleware 能够拦截 Promise，然后为每个 Promise 异步地 dispatch 一对 begin/end actions。 当数据流上最后一个 middleware dispatches 一个 actions 时，它必须是一个普通的对象。这是同步的 Redux 数据流开始的地方。 中间件（Middleware）中间件提供一个第三方的扩展点，在 dispatching 一个 action 和 它到达 reducer 的中间时刻。人们使用中间件来打印日志，记录崩溃报告，调用一个异步的 API, 路由……这里有一些例子来展示中间件的强大作用 理解中间件中间件可以做很多事情，理解它是从哪来的非常重要。我们通过使用 logging 和 crash reporting 这俩个例子来展示一个使用中间件的思维过程。 问题: 日志记录尝试#1：手动记录最原始的解决方案就是每次在调用 store.dispatch(action) 时记录 action 和 下一个 state. 代码可能就是下面的样子：let action = addTodo('Use Redux')console.log('dispatching',action)store.dispatch(action)console.log('next state', store.getState()) 这真的是一种很搓的办法。 尝试#2：包装 Dispatch把 logging 提取到一个函数里面：function dispatchAndLog(store,action)&#123; console.log('dispatching',action) store.dispatch(action) console.log('next state',store.getState())&#125; 这样每次调用的时候通过使用这个函数来替换 store.dispatch()dispatchAndLog(store,addTOdo('USe Redux')) 这样已经能解问题了，但是这样并不优雅。 尝试#3： Monkeypatching Dispatch如果我们只在 store 里面替换 dispatch 函数呢？ Redux 的 store 只是一个拥有几个方法的普通对象，所以我们可以改写 dispatchlet next = store.dispatchstore.dispath = fucntion dispatchAndLog (action)&#123; console.log('dispatching',action) let result = next(action) console.log('next state',soter.getState()) return reslut&#125; 这样基本上已经达到了我们的妖要求，不论你在哪里 dispatch 一个 action, 它都保证会被记录下来。虽然我们通过 Monkeypatching 改写了 store 内部的方法，但暂时先这样。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flex 布局]]></title>
    <url>%2F2016%2F05%2F04%2Fstep-to-flexbox%2F</url>
    <content type="text"><![CDATA[第一次接触 flex 是在去年，当时是我第一次做手机项目，结果却因为兼容性问题给掉坑了。查了 can I use 发现它只支持到安卓 4.1, 然而我们的要求是要兼容到 4.0 才行的。所以之后一直都没敢用，昨天听到有人说 flex 是可以支持到安卓 2.1 以上的。我不信，难道是我当时看错了？！今天又去查了一下，发现确实是 4.1 啊。盯着屏幕想了半天，突然发现 Can I Use 上一个浏览器浏览器使用率，想着该不会直接把使用率低的浏览器给忽略掉了吧。打开设置一看，果真如此，于是把数据源改成中国，浏览器最小使用率 0.03% 果真 2.3 出来了。 既然如此，说明 flex 还是可以在生产环境中使用了。那么就好好在过一下它的用法吧。Flex 就是弹性布局，任何一个元素都可以设置为 flex 布局，当一个元素被设置为 flex 布局后，它的子元素上 float, vertical-align 都会失效。 div &#123;truedisplay:flex&#125; 基本概念 图片出自 就是说一个 flex 容器有两个轴，一个主轴一个交叉轴。每个轴都有自己对应的起始位置，主轴的起始分别为 main start 和 main end, 交叉轴的起始分别为 cross start 和 cross end.容器内的项目会默认沿着主轴排列，从 main start 到 main end . felx 容器容器上可以 6 个属性，分别为： flex-direction flex-wrap flex-flow justify-content align-items align-content flex-direction决定主轴方向，也就是项目的排列方向。 MDN 上的语法解释： /* The direction text is laid out in a line */flex-direction: row;/* Like &lt;row&gt;, but reversed */flex-direction: row-reverse;/* The direction in which lines of text are stacked */flex-direction: column;/* Like &lt;column&gt;, but reversed */flex-direction: column-reverse;/* Global values */flex-direction: inherit;flex-direction: initial;flex-direction: unset;&gt; 实例下面从左到右分别是 row, row-reverse, colum, colum-reverse. 可以明显的看出他们之间的区别。 flex-wrapflex-wrap 定义内部的 item 是排列在一行还是说当超出时可以换行的属性。如果允许换行，这个属性也能让你控制堆叠的方向。 语法 flex-wrap: nowrap;flex-wrap: wrap;flex-wrap: wrap-reverse;&gt; 实例： flex-flowflex-flow 是 flex-direction 和 flex-wrap 的简写。初始值： flex-directoin: row flex-wrap: nowrap 语法： /* flex-flow: &lt;'flex-direction'&gt; */flex-flow: row;flex-flow: row-reverse;flex-flow: column;flex-flow: column-reverse;/* flex-flow: &lt;'flex-wrap'&gt; */flex-flow: nowrap;flex-flow: wrap;flex-flow: wrap-reverse;/* flex-flow: &lt;'flex-direction'&gt; and &lt;'flex-wrap'&gt; */flex-flow: row nowrap;flex-flow: column wrap;flex-flow: column-reverse wrap-reverse;&gt; justify-contentjustify-content 用来定义浏览器如何计算主轴上 (main-axis) flex 内部的 item 之间的空隙。对齐的过程会在长度和自动外编剧计算后进行，也就是说只要有一个设置了 flex-grow 不为 0 的弹性 (flexible) 元素，那么 justify-content 就不会起作用了。初始值为 flex-start. 语法： /* Pack flex items from the start */justify-content: flex-start;/* Pack items from the end */justify-content: flex-end;/* Pack items around the center */ justify-content: center;/* Distribute items evenlyThe first item at the start, the last at the end */justify-content: space-between;/* Distribute items evenlyItems have equal space around them */justify-content: space-around;&gt; 实例： align-itemalign-item 属性用来对齐当前 flex line 上的 flex 元素，和 justify-content 一样，不过是是在主轴的垂直方向上作用。初始值为 stretch. 语法 /* Align to cross-start */align-items: flex-start;/* Align to cross-end */align-items: flex-end;/* Center items in the cross-axis */align-items: center;/* Align the items' baselines */align-items: baseline;/* Stretch the items to fit */align-items: stretch;&gt; ### 实例 align-contentalign-content 属性定义当交叉轴上有空间时，flex 元素在交叉轴上的对齐方式。对于单行的flex 元素，这个属性没有作用。默认值为： stretch. 语法 /* Pack lines from the cross-axis start */align-content: flex-start;/* Pack lines to the cross-axis end */align-content: flex-end;/* Pack lines around the cross-axis center */align-content: center;/* Distribute lines along the cross-axis, start to end */align-content: space-between;/* Distribute lines along the cross-axis, equally spaced */align-content: space-around;/* Stretch lines to occupy the whole cross-axis */align-content: stretch;&gt; 实例 flex 项目（子元素）flex 项目上同样可以设置 6 个属性： order flex-grow flex-shrink flex-basis align-self flex order定义项目在主轴上的优先级，越小越靠前。默认为 0. flex-grow定义项目的拉伸因子，就是计算这个项目如何来占据剩余的空间。默认为 1. flex-shrink定义项目的因子。默认为 1. order,flex-grow,flex-shrink 实例 flex-basisflex-basis 定义在初试阶段 flex 占据主轴空间的基础。这个属性决定了 content-box 的尺寸，除非你修改了 box-sizing. 初始值为 auto. 语法 /* Specify &lt;'width'&gt; */flex-basis: 10em; flex-basis: 3px;flex-basis: auto;/* Intrinsic sizing keywords */flex-basis: fill;flex-basis: max-content;flex-basis: min-content;flex-basis: fit-content;/* Automatically size based on the flex item’s content */flex-basis: content;&gt; 实例 flexflex 是一个定义项目改变尺寸能力的一个缩写属性。默认值： flex-grow: 0 flex-shrink: 1 flex-basis: auto 语法 /* 0 0 auto */flex: none;/* One value, unitless number: flex-grow */flex: 2;/* One value, width/height: flex-basis */flex: 10em;flex: 30px;flex: auto;flex: content;/* Two values: flex-grow | flex-basis */flex: 1 30px;/* Two values: flex-grow | flex-shrink */flex: 2 2;/* Three values: flex-grow | flex-shrink | flex-basis */flex: 2 2 10%;&gt; align-self定义项目的对齐方式，会覆盖 align-items 属性。如果只要有一个项目的交叉轴外边距设置为 auto, 那么 align-self 就会被忽略。默认值为 auto. 语法和 align-items 相同 实例 iframe { min-height: 300px; }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>flexbox</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【翻译向】走进 Redux 之基础篇(二)]]></title>
    <url>%2F2016%2F05%2F03%2Fstep-to-redux-2%2F</url>
    <content type="text"><![CDATA[紧接上一篇走进 Redux 之基础篇(一),接下来会跟着文档从下面三个点开始。 数据流 与 React 配合 实例：TodoList 数据流Redux 的架构围绕与如何搭建一个严格的单向数据流。 这意味着所有的数据都有遵循一个同样的生命周期模式，可以让整个应用变得可预测也更加易于理解。在 Redux 应用中，所有的数据生命周期分为如下四个步骤： 1 你主动调用 store.dispatch(action)Action 是一个用来描述发生了事情的对象。比如：&#123;type:'ADD_TODO',text:'todo\'s content'&#125;&#123;type: 'FETCH_USER_SUCCESS', response: &#123;id: 3, name: 'Mary'&#125;&#125; 可以认为 action 是一个事件的简短片段描述。你可以在任何地方调用 store.dispatch(action) ，包括组件和 XHR 中，甚至可以在定时器中调用。 2 Redux store 调用你提供的 reducer 函数store 会传递俩个参数给 reducer：当前的 state 和 action. 比如，在一个 todo 应用中，根 reducer 会收到类似下面这样的参数： let previousState = &#123; visibleTodoFilter: 'SHOW_ALL', todos: [&#123; text: 'Read the docs', complete: false &#125;]&#125;let action = &#123; type: 'ADD_TODO', text: 'Understand the flow'&#125;// nextState 由 todoApp 这个根 reducer 来生成let nextState = todoApp(previousState, action) 需要注意的是 reducer 是一个纯函数，没有副作用的，仅仅是计算下一个 state . 他应该是可以完全预测的，对于同样的参数，无论调用多少次都应该返回一个同样值。类似于 API 调用或者路由的变化都应该在 action 被 dispatch 之前。 3 根 reducer 可以合并多个子 reducer 的输出来生成一个单一的 state 树。如何组合根 reducer 完全由你来决定。 Redux 提供了 combineRedux() 这个帮助函数，在把根 reducer 分离成独立的函数去管理整个 state 树的一个分支时很有帮助。我们来看一下 combineRedusers() 这个函数怎么工作。假设你有俩个 reducer ， 一个用来管理 todo 列表，另一个用来管理当前选中的过滤状态： function todos(state = [], action) &#123; // Somehow calculate it... return nextState &#125;function visibleTodoFilter(state = &apos;SHOW_ALL&apos;, action) &#123; // Somehow calculate it... return nextState &#125;let todoApp = combineReducers(&#123; todos, visibleTodoFilter &#125;) 当触发一个 action 的时候， 通过 combineRedusers 返回的 todoApp 将会调用所有 reducer：let nextTodos = todos(state.todos, action)let nextVisibleTodoFilter = visibleTodoFilter(state.visibleTodoFilter, action) 它会把每个 reducer 返回的 state 合并成一个单独的 state 树return &#123; todos: nextTodos, visibleTodoFilter: nextVisibleTodoFilter &#125; 你也可以选择不用 combineRedusers ，毕竟他只是好用的辅助工具，你可以自己来实现你的跟 reducer. 4 Redux store 会保存由根 reducer 返回的整个 state 树现在这个新的 state 树就是当前应用的下一个 state 。所有通过 store.subscribe(listener) 注册了监听事件的监听函数都会被调用； 监听对象可能会调用 store.getState() 来获取当前的 state .现在，整个视图都可以通过新的 state 来更新。如果你使用 React Redux 做为视图绑定工具，那么这就是 component.setState(newState) 调用的节点。 和 React 配合使用虽然 Redux 和 React 之间没有联系，但是 Redux 确实和类似于 React 和 Deku 这类可以用数据状态俩描述 UI 的框架配合的很好。我们将会使用 React 来搭建一个简单的 Todo 应用。 安装 React ReduxReact bindings 并没有默认包括在 Redux 中，我们需要单独的安装： npm install --save react-redux 展示型组件 (Presentational Components) 和容器型组件 (Container Components)Redux 的 React bindings 信奉 展示型组件和容器型组件分离 — 展示型组件 容器型组件 目的 界面看起来的样子（标记，样式） 事情是怎样工作的（数据获取，状态更新） 意识到 Redux No Yes 读取数据 从父 props 中读取 顶 Redux state 中订阅获取 修改数据 从 props 中调用回调函数 分发 (dispatch) Redux actions Are written 手写 通常由 React Redux 生成 大多数组件都应该被写成展示型组件，但是我们也需要生成一些容器型组件类把它们和 Redux store 连接起来。 技术上说，你可一通过使用 store.subscribe() 来手写容器型组件。但是我们不建议这样做，因为 React Redux 做了很多你很难直接手写出来的性能优化。所以，比起手写容器型组件，我们更建议通过 React Redux 提供的 connetc() 函数来生成它。 设计组件层级我们的设计很简单。我们想要展示一个 todo 内容列表。一个按钮，用来标记一个 todo 内容是否完成。一个用来添加新 todo 的地方。在页脚部，我们需要一个切换键来展示所有的、完成的或者未完成的 todos. 展示型组件通过下面这些展示型组件，我们可以概括出一个 props 层级。 TodoList 是一个用来展示可用 Todos 的列表 todos: Array 一个内容为 { id, text, completed } 样子的列表 onTodoClick(id: number) 一个回调函数，当一个 todo 被点击的时候 Todo 一个单独的 todo 项目 text: string 要展示的文字 completed: boolean todo 是否被完成的状态 onClick 一个回调函数，当一个 todo 被点击时调用 Link 一个用回调的链接 onClick 这个链接被点击时的回调 Footer 用来改变当前显示 todo 内容的地方 App 跟组件，用来渲染所有其它的东西 它们描述这个应用看起来的样子，但是不知道数据从哪里来，也不知道如何改变他们。只是渲染我们给它的数据。如果你要从 Redux 迁移到其它框架，这些组件几乎都是可以不用改动的。它们和 Redux 之间没有联系。 容器型组件我们同样需要一些容器型组件来把展示型组件连接到 Redux. 比如，TodoList 组件需要一个容器 VisibleTodoList 用来从 Redux 去订阅数据来知道如何使用当前的可视性筛选条件 (visibility filter). 为了更改可视性筛选条件，我们提供一个 FilterLink 容器来渲染 Link 用来 dispatches 一个合适的 action 在点击的时候： VisibleTodoList 通过当前的可视性筛选条件来过滤要展示的内容并渲染一个 TodoList FilterLink 获得当前的可视性筛选条件并渲染 Link filter: string 表示一个可视性筛选条件 其它组件有时，我们难以去区分一个组件是展示型还是容器型的。比如，有时表单和函数是互相依赖的， 就像这个小型的组件： AddTodo 一个有 ‘添加’ 按钮的输入框 技术上说，我没呢可以把它分离成俩个组件，但是这样明显太繁琐了。当项目变得负责和庞大的时候，我们可以把它分离开，但是现在的话，就这样让他们混合在一起吧。 实现组件展示型组件就是普通的 React 组件，就不详细介绍了。TodoList.js import React, &#123; PropTypes &#125; from 'react'import Todo from './Todo'const TodoList = (&#123; todos, onTodoClick &#125;) =&gt; ( &lt;ul&gt; &#123;todos.map(todo =&gt; &lt;Todo key=&#123;todo.id&#125; &#123;...todo&#125; onClick=&#123;() =&gt; onTodoClick(todo.id)&#125; /&gt; )&#125; &lt;/ul&gt;)TodoList.propTypes = &#123; todos: PropTypes.arrayOf(PropTypes.shape(&#123; id: PropTypes.number.isRequired, completed: PropTypes.bool.isRequired, text: PropTypes.string.isRequired &#125;).isRequired).isRequired, onTodoClick: PropTypes.func.isRequired&#125;export default TodoList 容器型组件接下来我们通过生成容器型组件来把展示型组件和 Redux 链接起来。技术上说，一个容器型组件只是一个 React 组件，通过使用 store.subscribe() 来读取一部分 Redux state tree 并且提供 props 给一个展示型组件用来渲染。你可以手写这个组件，但是我们建议使用 Redux 提供的 connect() 函数来生成这些容器型组件，它提供了很多有用的优化去阻止一些不必要重新渲染。 为了使用它 connect() , 你需要顶一个叫做 mapStateToProps 的特殊函数，用来指明如何转换当前的 Redux store state 成为你想要传递给展示型组件的 props. 比如， VisibleTodoList 需要去计算 todos 来传递给 TodoList, 所以我们定义一个函数通过 state.visibilityFilter 用来过滤 state.todos, 并且在 mapStateToProps 中使用它： const getVisibleTodos = (todos, filter) =&gt; &#123; switch (filter) &#123; case 'SHOW_ALL': return todos case 'SHOW_COMPLETED': return todos.filter(t =&gt; t.completed) case 'SHOW_ACTIVE': return todos.filter(t =&gt; !t.completed) &#125;&#125;const mapStateToProps = (state) =&gt; &#123; return &#123; todos: getVisibleTodos(state.todos, state.visibilityFilter) &#125;&#125; 除了读取 state 之外， 容器型组件可以 dispatch actions. 通过同样的方式，你可以定义一个名为 mapDispatchToProps() 的函数去接收 dispatch() 方法，并返回一个回调 props 用来注入到你想要的展示型组件中。比如，我们想要 VisibleTodoList 去注入一个名为 onTodoClisk 的 prop 到 TodoList 组件中，而且我们想要 onTodoClick 去 dispatch 一个 `TOGGLE_TODO’ action: const mapDispatchToProps = (dispatch) =&gt; &#123; return &#123; onTodoClick: (id) =&gt; &#123; dispatch(toggleTodo(id)) &#125; &#125;&#125; 最后，我们通过调用 connect() 来生成一个 VisibleTodoList 并传递这两个函数： import &#123; connect &#125; from 'react-redux'const VisibleTodoList = connect( mapStateToProps, mapDispatchToProps)(TodoList)export default VisibleTodoList 这些都是 React Redux 的基础 API, 但是这有一些快捷方式和强大的选项，所以我们鼓励你去仔细查看 这个文档. 如果你担心 mapStateToProps 创建新对象的过程，你可能需要去了解 computing derived data with reselect 传递到 Store所有的容器型组件需要连接到 Redux store 这样它们才能订阅它。一个方式是把它做为一个 prop 传递给每一个容器型组件。然而那样过于繁琐，我们推荐的方式是通过使用特定的 React Redux 组件 &lt;Provider&gt; 去黑魔法般的使 store 可用给应用中的所有容器型组件而不用专门去传递它。你只需要在渲染跟组件的时候调用它一次。 Index.js import React from 'react'import &#123; render &#125; from 'react-dom'import &#123; Provider &#125; from 'react-redux'import &#123; createStore &#125; from 'redux'import todoApp from './reducers'import App from './components/App'let store = createStore(todoApp)render( &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt;, document.getElementById('root')) 实例：TodoList直接看文档，虽然了解到很多专有名次和方法，但还是看不出个所以然来。所以还是得看代码，这里是官方的 TodoList 源码，结合这两篇文章应该就能很好的理解了。我在这里遇到了几个问题 webpack 一直报错找不到入口文件 ‘./index’ , 最后发现 babel 的坑。 Babel 升级到 6.0 以后需要在 .babelrc 这个文件中指明要编译 js 的文件类型，否则编译会报错。 &#123;"presets": ["es2015", "react"]&#125; 页面渲染出来后，点击添加什么都是可以正常运行的。但是点击筛选的时候老师报错，而且报的错莫名其妙。于是一步一步打断点来看，最后发现是 Footer.js 里面 filter 对应的 action 拼写错误导致后面的组件找不到对应的 action import React from 'react'import FilterLink from '../containers/FilterLink'const Footer = () =&gt; (&lt;p&gt; Show: &#123;" "&#125; &lt;FilterLink filter="SHOW_ALL"&gt; All &lt;/FilterLink&gt; &#123;", "&#125; &lt;FilterLink filter="SHOW_ACTIVE"&gt; Active &lt;/FilterLink&gt; &#123;", "&#125; &lt;FilterLink filter="SHOW_COMPLETED"&gt; Completed &lt;/FilterLink&gt;&lt;/p&gt;)export default Footer 可见应用的 action 还是需要专门单独维护一个文件，将所有的 action 都定义为变量然后暴露出来，这样如果后面有拼写错误的话，那么在编译阶段就可以发现问题了。 参考Basics|Redux]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【翻译向】走进 Redux 之基础篇(一)]]></title>
    <url>%2F2016%2F04%2F26%2Fstep-to-redux-1%2F</url>
    <content type="text"><![CDATA[Redux 的三个原则 整个应用的状态都以一个对象树的形式保存在一个单一的 store 中 唯一去改变这个对象树的方法就是通过去触发 action,一个用来描述发生了什么事情的对象 通过编写纯函数 reducers，去描述这个 action 如何改变了整个对象树 ActionAction 就是承载了要从你的应用传送给 store 的信息。它们只是 store 的信息数据来源。可以通过 store.dispatch() 来传递 action.action 可能长这个样子：const ADD_TODO = 'ADD_TODO'&#123; type: ADD_TODO, text: 'Bulid my first Redux App'&#125; Actions 就是普通的 JavaScript 对象，但是必须有 type 属性，用来指定是发生了哪种类型的操作。 Types 应该被定义为字符串常量。当你的项目变的庞大起来时，你可能需要把它们移动到一个单独隔离的模块里面。import &#123; ADD_TODO, REMOVE_TODO &#125; from '../actionTypes' 与 type 不同的是，整个 action 的结构完全由你来决定。不过可以参考 Flux Standard Action 里面的指南来了解如何更好的组织 action 的结构。 Action CreatorsAction Creators 就是用来生成 action 的函数。在 Redux 中 action creators 简单的返回一个 action 对象就可以了：function addTodo(text)&#123; return &#123; type: ADD_TODO, text: 'Some text' &#125;&#125; 这样可以更加容易的创建一类 action, 而且更易于测试。 Dispatch实际的初始化一个 dispatch 可以通过把结果传递给 diapatch() 函数： store.dispatch(addTodo(text))``` 或者，你可以通过创建个一个被的绑定 action creator 用来自动 dispatches：```javascriptconst boundAddTodo = (text) =&gt; dispatch(addTodo(text)) 现在你能够直接调用它们了：boundAddTodo(text) dispatch() 函数可以直接访问 store 通过 store.dispatch()，但你可能更喜欢通过使用一个像 react-redux 的 connect() 这样辅助函数来访问。可以通过 bindActionCreators() 来自动绑定很多 action creators 到 dispatch() 函数上。 ReducersActions 描述一个发生了什么事情的事实，但是没有指定如何去改变应用的 state. 这个就是 reducer 要做的。 设计 State 结构在 Redux 里面，应用的所有状态都被存储在一个单一的对象中。所以在写代码之前考虑一下如何设计 state 是很重要的。如何用最简单的方法来把应用状态描述为一个对象。对于一个 todo 应用来说，我们想要存储俩个不同的事情： 当前选中的显示过滤条件 实际的 todos 列表 简单的 state 就是下面这个样子&#123; visibilityFilter: 'SHOW_ALL', todos: [ &#123; text: 'Consider using Redux', completed: true &#125;,&#123; text: 'Keep all state in a single tree', completed: false &#125; ] &#125; 处理 ActionsReducer 是一个纯函数，接受之前的 state 和 action 做为参数，返回下一个 state.(previousState, action) =&gt; newState 之所以叫做 reducer 是因为它要被传递给 Array.prototype.reduce(reducer,?initialValue) 这个函数。所以保持 reduce 的纯净非常重要。永远不要在 reducer 里面做下面的事情： 转换它的函数参数 做一些带有副作用的操作，比如 API 的调用和路由的跳转 调用不纯净的函数，比如 Date.now() 和 Math.random() 了解了这些以后，我们来开始 reducer 函数。通过指明初始 state 来开始。 Redux 将会在第一次调用 reducer 时传递一个 undefined state. 这时我们需要返回一个初始化的 state：import &#123; VisibilityFilters &#125; from './actions'const initialState = &#123; visibilityFilter: VisibilityFilters.SHOW_ALL, todo: []&#125;function todoApp(state = initialState, action) &#123; //采用 ES2015 写法，当 state 传递为 undefined 时，会被赋值为 initialState return state&#125; 接下来处理 SET_VISIBILITY_FILTER. 需要做的就是在 state 上改变 visibilityFilter. function todoApp(state = initialState, action) &#123; switch (action.type) &#123; case SET_VISIBILITY_FILTER: return Object.assign(&#123;&#125;, state, &#123; visibilityFilter: action.SET_VISIBILITY_FILTER &#125;) default: return state &#125;&#125; 需要注意的是： 我们不修改原有的 state. 通过 Object.assign() 创建一个原有 state 和 要改变内容合并后的副本。 当找不到状况也就是 default 时，必须返回之前的 state 处理更多的 Actions还有一些 action 需要去处理，我们也都一一加上。function todoApp(state = initialState, action) &#123; switch (action.type) &#123; case SET_VISIBILITY_FILTER: return Object.assign(&#123;&#125;, state, &#123; visibilityFilter: action.filter &#125;) case ADD_TODO: return Object.assign(&#123;&#125;, state, &#123; todos: [ ...state.todos, &#123; text: action.text, completed: false &#125; ] &#125;) default: return state &#125;&#125; 我们可以通过分离 reducer 函数来使它更加容易理解，毕竟把 todos 相关的处理逻辑和 visibilityFilter 的处理逻辑放在一块不是很清晰。分离 reducer 也是很简单的。function todos(state=[], action) &#123; switch (action.type) &#123; case ADD_TODO: return [ ...state, &#123; text: action.text, completed: false &#125; ] default: return state &#125;&#125;function visibilityFilter(state = SHOW_ALL, action) &#123; switch (action.type) &#123; case SET_VISIBILITY_FILTER: return action.filter default: return state &#125;&#125;function todoApp(state = &#123;&#125;, action) &#123; return &#123; visibilityFilter: visibilityFilter(state.visibilityFilter, action), todos: todos(state.todos, action) &#125;&#125; 可以看到，每个 reducer 都管理着整个 state 中属于自己的部分。每个 reducer 的 state 参数都不同，分别对应他们自己管理部分的 state.当应用变得庞大时，我们可以把 reducer 分离到多个不同的文件中，保持独立性并管理不同的数据源。最后，Redux 提供了一个 combineReducers() 函数来做和上面 todoApp 同样逻辑的事情，合并多个 reducer, 这样可以省略很多样板代码。import &#123; combineReducers &#125; from 'redux'const todoApp = combineReducers(&#123; visibilityFilter, todos&#125;)export default todoApp 它和下面的写法是完全等价的：export default function todoApp(state = &#123;&#125;, action) &#123; return &#123; visibilityFilter: visibilityFilter(state.visibilityFilter, action), todos: todos(state.todos, action) &#125;&#125; combineReducers() 所做的就是生成一个函数，并给每个 reducer 函数并传入对应的 state，并把它们合并成一个单独的对象。这并不是黑魔法。 combineReducers 原理15 年看 Redux 时，没有读文档，这里一直没能理解，不知道 combineReducers() 到底是怎么做的，以为他就是个黑魔法。而且还能通过 combineReducers() 后的函数生成初始化的 store. 今天重新读了文档和 黑魔法 这个 issue 后理解了。其实 combineReducers() 是这样工作的。假设你有俩个 reducer ， 一个用来管理 todo 列表，另一个用来管理当前选中的过滤状态： function todos(state = [], action) &#123; // Somehow calculate it... return nextState &#125;function visibleTodoFilter(state = &apos;SHOW_ALL&apos;, action) &#123; // Somehow calculate it... return nextState &#125;let todoApp = combineReducers(&#123; todos, visibleTodoFilter &#125;) 可以看到，每个 reducer 中都定义了默认的 state:todos 中为 [], 而 visibleTodoFilter 中为 SHOW_ALL。当触发一个 action 的时候， 通过 combineReduser 返回的 todoApp 将会调用整个 reducer：let nextTodos = todos(state.todos, action)let nextVisibleTodoFilter = visibleTodoFilter(state.visibleTodoFilter, action) 最终它会把每个 reducer 返回的 state 合并成一个单独的 state 树return &#123; todos: nextTodos, visibleTodoFilter: nextVisibleTodoFilter &#125; 这样就可以理解 combineReducer 的工作原理了。当然你也可以选择不用 combineReduser ，毕竟他只是一个官方提供的辅助工具，你可以自己来实现你的根 reducer. StoreStore 是一个对象，用来把它们联系起来。Store 的职责如下： 保存整个应用的 state 可以通过 getState() 来获取 state 可以通过 dispatch(action) 来更新 state 通过 subscribe(listener) 来注册监听器 通过 subscribe(listener) 返回的值来处理没有注册的监听器 需要注意的只能有一个 store 在 Redux 应用中。当你想要分离数据逻辑时，你可以通过创建更多的 reducer 来代替更多的 store.当你拥有一个 reducer 时，创建 store 是很容易的。我们可以通过 combineReducers() 后创建的根 reducer 来创建 store.import &#123; createStore &#125; from 'redux'import todoApp from './reducers'let store = createStore(todoApp) 也可以通过传递可选参数来初始化 state. 当你开发一个通过应用时着很有用，可以把服务端传来的 state 做为客户端初始化 state.let store = createStore(todoApp, window.STATE_FROM_SERVER) 总结理解了这些内容，就大概可以知道 Redux 是怎么运作的了。可见读文档还是很有用的，不像去年直接去看官方例子里的源码，结果看的一愣一愣的，最后也不明白是个怎么回事。接下来，要继续学习数据流以及和 React 的配合，并动手写一个 TodoList 实例来加深理解。 参考Basics|Redux]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 中的类和继承]]></title>
    <url>%2F2016%2F03%2F21%2Fclass%20and%20inherit%20in%20JavaScript%2F</url>
    <content type="text"><![CDATA[我们都知道 JavaScript 是一门基于原型的语言。当我们调用一个对象本身没有的属性时，JavaScript 就会从对象的原型对象上去找该属性，如果原型上也没有该属性，那就去找原型的原型，一直找原型链的末端也就是 Object.prototype 的原型 null。这种属性查找的方式我们称之为原型链。 类的实现由于 JavaScript 本身是没有的类的感念的。所以我们如果要实现一个类，一般是通过构造函数来模拟类的实现：function Person(name,age)&#123; //实现一个类 this.name = name; this.age = age;&#125;var you = new Person('you',23); //通过 new 来新建实例 首先新建一个 Person 的构造函数，为了和一般的函数区别，我们会使用 CamelCase 方式来命名构造函数。然后通过 new 操作符来创建实例，new 操作符其实干了这么几件事： 创建一个继承自 Person.prototype 的新对象 构造函数 Person 执行时，相应的参数传入，同时上下文被指定为这个新建的对象。 如果构造函数返回了一个对象，那么这个对象会取代 new 的结果。如果构造函数返回的不是对象，则会忽略这个返回值。 返回值不是对象function Person(name)&#123; this.name = name; return 'person'&#125;var you = new Person('you');// you 的值: Person &#123;name: "you"&#125;返回值是对象function Person(name)&#123; this.name = name; return [1,2,3]&#125;var you = new Person('you');// you的值: [1,2,3] 如果类的实例需要共享类的方法，那么就需要给构造函数的 prototype 属性添加方法了。因为 new 操作符创建的对象都继承自构造函数的 prototype 属性。他们可以共享定义在类 prototype 上的方法和属性。 function Person(name,age)&#123; this.name = name; this.age = age;&#125;Person.prototype = &#123; sayName: function()&#123; console.log('My name is',this.name); &#125;&#125;var you = new Person('you',23);var me = new Person('me',23);you.sayName() // My name is you.me.sayName() // My name is me. 继承的实现 JavaScript 中常用的继承方式是组合继承，也就是通过构造函数和原型链继承同时来模拟继承的实现。//Person 构造函数如上function Student(name,age,clas)&#123; Person.call(this,name,age) this.clas = clas;&#125;Student.prototype = Object.create(Person.prototype); // Mark 1Student.constructor = Student; //如果不指明，则 Student 会找不到 constructorStudent.prototype.study = function()&#123; console.log('I study in class',this.clas)&#125;;var liming = new Student('liming',23,7);liming instanceof Person //trueliming instanceof Student //trueliming.sayName(); // My name is limingliming.study(); // I study in class 7 代码中 Mark 1 用到了 Object.create 方法。这个是 ES5 中新增的方法，用来创建一个拥有指定原型的对象。如果环境不兼容，可以用下面这个 Polyfill 来实现（仅实现第一个参数）。if(!Object.create)&#123; Object.create = function(obj)&#123; function F()&#123;&#125;; F.prototype = obj; return new F(); &#125;&#125; 其实就是把 obj 赋值给临时函数 F ，然后返回一个 F 的实例。这样通过代码 Mark 1 Student 就得到了 Person.prototype 上的所有属性。有人会问了，那么为什么不干脆把 Person.prototype 直接赋值给 Student.prototype 呢？ 是的，直接赋值是可以达到子类共享父类 prototype 的目的，但是它破坏了原型链。即：子类和父类共用了同一个 prototype,这样当某一个子类修改 prototype 的时候，其实同时也修改了父类的 prototype,那么就会影响到所有基于这个父类创建的子类，这并不是我们想要的结果。看例子： //Person 同上//Student 同上Student.prototype = Person.prototype;Student.prototype.sayName = function()&#123; console.log('My name is',this.name,'my class is',this.clas)&#125;var liming = new Student('liming',23,7)liming.sayName() //My name is liming,my class is 7;//另一个子类function Employee(name,age,salary)&#123; Person.call(name,age); this.salary = salary;&#125;Employee.prototype = Person.prototype;var emp = new Employee('emp',23,10000);emp.sayName() //Mark 2 你们猜 Mark 2 会输出什么？ 我们期望的 Mark 2 应该会输出 “My name is emp”. 但实际上报错，为什么呢？因为我们改写 Student.prototype 的时候，也同时修改了 Person.prototype，最终导致 emp 继承的 prototype 是我们所不期望的，它的 sayName 方法是 My name is&#39;,this.name,&#39;my class is&#39;,this.clas，这样自然是会报错的。 ES6 的继承随着 ECMAScript 6 的发布，我们有了新的方法来实现继承。也就是通过 class 关键字。 类的实现class Person &#123; constructor(name,age)&#123; this.name = name; this.age = age; &#125; sayHello()&#123; console.log(`My name is $&#123;this.name&#125;,i'm $&#123;this.age&#125; years old`) &#125;&#125;var you = new Person('you',23);you.sayHello() //My name is you,i'm 23 years old. 继承ES6 里面的继承也很方便，通过 extends 关键字来实现。class Student extends Person&#123; constructor(name,age,cla)&#123; super(name,age); this.class = cla; &#125; study()&#123; console.log(`I'm study in class $&#123;this.class&#125;`) &#125;&#125;var liming = new Student('liming',23,7)liming.study() // I'm study in class 7. 这个继承相比上面的 ES5 里面实现的继承要方便了很多，但其实原理是一样的，提供的这些关键字方法只是语法糖而已，并没有改变 Js 是基于原型这么一个事实。不过 extends 这样实现的继承有一个限制，就是不能定义属性，只能定义方法。要新添属性，还是得通过修改 prototype 来达到目的。Student.prototype.teacher = 'Mr.Li'var liming = new Student('liming',23,7)var hanmeimei = new Student('hanmeimei',23,7)liming.teacher //Mr.Lihanmeimei.teacher //Mr.Li 静态方法ES6 还提供了 static 关键字，来实现静态方法。静态方法可以继承，但只能由类本身调用，不能被实例调用。class Person&#123; constructor(name,age)&#123; this.name = name; this.age = age; &#125; static say()&#123; console.log('Static') &#125;&#125;class Student extends Person&#123;&#125;Person.say() // StaticStudent.say() // Staticvar you = new Person('you',23);you.say() // TypeError: liming.say is not a function 可以看到，在实例上调用的时候会直接报错。 Super关键字在子类中可以通过 super 来调用父类，根据调用位置的不同，行为也不同。在 constructor 中调用，相当于调用父类的 constructor 方法，而在普通方法里面调用则相当与调用父类本身。class Person &#123; constructor(name,age)&#123; this.name = name; this.age = age; &#125; sayHello()&#123; console.log(`My name is $&#123;this.name&#125;,i'm $&#123;this.age&#125; years old`) &#125;&#125;class Student extends Person&#123; constructor(name,age,cla)&#123; super(name,age); // 必须在子类调用 this 前执行，调用了父类的 constructor this.class = cla; &#125; sayHello()&#123; super.sayHello; // 调用父类方法 console.log('Student say') &#125;&#125;var liming = new Student('liming',23,7);liming.say() // My name is liming,i'm 23 years old.\n Student say. 总结至此，我们可以看到：在 ES6 发布以后，JavaScript 中实现继承有了一个标准的方法。虽然它们只是语法糖，背后的本质还是通过原型链以及构造函数实现的，不过在写法上更易于我们理解而且也更加清晰。 参考： JavaScript继承方式详解 JavaScript 原型系统的变迁，以及 ES6 class]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>inherit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo部署到VPS并启用HTTPS]]></title>
    <url>%2F2016%2F03%2F10%2FHexo%E9%83%A8%E7%BD%B2%E5%88%B0VPS%E5%B9%B6%E5%90%AF%E7%94%A8HTTPS%2F</url>
    <content type="text"><![CDATA[上周买了个 VPS 玩 ，从板瓦工买的，一年的 19 刀。性价比还算合适，这是配置：10 GB SSD RAID-10 Disk Space256 MB RAM500 GB TransferGigabit portMultiple locations 这是购买链接。 买过来，先是搭了个 SS 解决科学上网的问题。然后想想要不要把博客也迁移过去算了,一个 ss 又用不了多少流量。于是说干就干，一番搜索查询后，达成成就。 简单的记录下操作的步骤： 客户端： 配置 ssh 本地部署 hexo 服务器： 安装所需软件 a. Git b. Nginx 为了安全与方便，新建专用与部署 hexo 的用户git，并给予相应权限。 配置 ssh，与客户端达成通道 配置 git hooks，这样本地在 hexo 部署到服务器 git 用户的对应仓库后就不用在把它复制到用以访问的网站的文件夹了。 #!/bin/bashGIT_REPO=/home/git/hexo.git #git仓库TMP_GIT_CLONE=/tmp/hexoPUBLIC_WWW=/var/www/hexo #网站目录rm -rf $&#123;TMP_GIT_CLONE&#125;git clone $&#123;GIT_REPO&#125; $&#123;TMP_GIT_CLONE&#125;rm -rf $&#123;PUBLIC_WWW&#125;/*cp -rf $&#123;TMP_GIT_CLONE&#125;/* $&#123;PUBLIC_WWW&#125; 配置nginx，并启动nginx服务 遇到的问题 访问 vps 地址，直接显示403 forbidden，以为是权限问题，网上查了半天也没解决。最后发现用于网站的目录下是空的。 由问题1推断出，Git hooks 压根没起作用。因为用于放网站文件夹下一直都是空的，于是手动试git hooks 下面的命令，执行到 rm -rf ${PUBLIC_WWW}的时候，系统提示操作被拒绝，发现是权限问题，赋予git用户用于放网站的 www/hexo 的权限。 ssh 在服务器重启后出现问题，多方排查后发现也是权限问题，赋予 git 用户.ssh 文件 700 权限 输入 www.kisnows.com ，访问成功，哈哈，好开心。而且国内访问速度比原来快了一点点，虽然就那么一点点。 想想也上个 SSL 吧，不然太落后了，毕竟最近电信劫持很严重。因为不想投入过大成本，就打算用 cloudFlare 提供的免费 SSL。虽然只是浏览器到 cloudFlare 之间是加密的，但是有总比没有强嘛。于是把 DNS 服务从 DNSPod 切换到了cloudFlare，并借助 cloudFlare 全站启用了 HTTPS，同时将顶级域名重定向到了www 下的二级域名。方法如下： 启用HTTPS进入 cloudFlare 管理中心，Crypto下 强制非HTTPS访问跳转到HTTPS位于 Page Rules 模块下上图1，选 always use https，然后如图第一条规则，http://*.kisnows.com/* 这样所有匹配的所有访问，都会走 https 了。 顶级域名重定向到带 www 的二级域名下也是用 Page Rules，如上图2。选 Forwarding，然后匹配如下填写就OK了：Forwarding 中的 $1 就是 kisnows.com/* 中 * 匹配到元素。 至此，为期两天的折腾完毕，全站迁移到了 VPS，并全程启用 HTTPS。真是生命不息，折腾不止啊！ 参考文章：http://tiktoking.github.io/2016/01/26/hexo/http://www.hansoncoder.com/2016/03/02/VPS%20building%20Hexo/http://hejun.me/2015/01/05/deploy-hexo-on-cloud/]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>网站建设</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP 缓存]]></title>
    <url>%2F2016%2F03%2F07%2Fhttp-cache%2F</url>
    <content type="text"><![CDATA[下午意外的接到了阿里钉钉前端的面试，很是欣喜。面试内容从做的项目，到使用的技术 Angular、React、Express 等，让我感觉到自己的理解还是不够深刻。比如我说我喜欢 React，大项目中需要配合 Redux 来用处理数据，然后就问到 Redux 到底解决了哪些问题，我没能清楚的答上来。但是整体上，面试的前面部分，自我感觉还是很不错的。但是到最后，面试官说问一个比较基础的问题：如何在HTTP协议中控制缓存？我懵了，平时工作中根本接触不到。只能凭自己感觉说，从文件名的更改以及在 HTTP 的 header 中设置相应参数来设置，但具体怎样设置，设置的内容是什么，我完全答不上来。感觉肯定是要挂在这里。不过俗话说的好，人不能在同一个地方跌到两次，谨以此篇记录HTTP缓存的相应内容。 概览HTTP 控制缓存主要有一下几种方式： Expires Cache-Control Last-Modified/If-Modified-Since Etag/If-None-Match 接下来，就一个一个来了解。 Expires过期时间，有点类似于 cookies 里面的 Expires。可以在 header 中设置一个具体的过期时间，在这个过期时间内，浏览器都不会向服务器请求这个文件，会直接存本地的缓存中读取。上图是我博客中一个 js 文件的 HTTP header，可以看到其中红框1 Expires 设置为当前 Date 的4个小时后，也就是说正常情况这个文件在 Expires 这个时间点以前的请求都会直接使用本地缓存，而不用从服务端重新获取。需要注意的是，Expires 是 HTTP 1.0 的东西，现在绝大多数浏览器都默认使用 HTTP 1.1，所以用 Expires 控制缓存不是首选的方法。 Cache-controlCache-control 与 Expires 作用基本相同，都是标志出当前资源的有效期，以此来控制浏览器是使用本地缓存还是从服务器重新获取资源。不过，不同的地方在于，Cache-control 能够控制的更加细致，当header中同时存在 Expires 时，Cache-control 的优先级要更高一些。 HTTP协议头 Cache-Control 的值可以是 public、private、no-cache、no- store、no-transform、must-revalidate、proxy-revalidate、max-age各个消息中的指令含义如下： Public 指示响应可被任何缓存区缓存。 Private 指示对于单个用户的整个或部分响应消息，不能被共享缓存处理。这允许服务器仅仅描述当用户的部分响应消息，此响应消息对于其他用户的请求无效。 no-cache 指示请求或响应消息不能缓存 no-store 用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不使用缓存。 max-age 指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应。 min-fresh 指示客户机可以接收响应时间小于当前时间加上指定时间的响应。 max-stale 指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。 如图，红框2上面的 Cache-Control 这一栏，值为 public，max-age=14400. 就是说它的有效期是 14400s，也就是4h，和上面的 Expires 的过期时间是一样的，但是它不像 Expires 那样必须给一个类似 Mon，07 Mar 2016 17:14:33 GMT 这样具体的时间，只需要给定一个最大寿命的时间就可以了。这个应该是比较常用的方法。 Last-Modified/If-Modified-Since Last-Modified 表示这个资源的最后修改时间，服务器在相应请求时，会告诉浏览器此资源的最后修改时间。 If-Modified-Since 发送HTTP请求时，浏览器会把缓存资源的最后修改时间一起发送到服务器去，服务器会用这个时间与服务器上实际文件的最后修改事件进行对比。如果时间一致，则返回 HTTP 状态码 304，浏览器接收到后会直接显示缓存的文件。如果时间不一致，则返回 HTTP 状态码 200 和新的文件内容，浏览器拿到文件后会丢掉本地旧文件，缓存新文件并展示出来。要注意的是 Last-Modified/If-Modified-Since 需要配合 Cache-control 使用，只有当本地的资源过期时（即超过了max-age 定义的时间），才会向服务器发送相应的带有 If-Modified-Since 的请求。 Etag/If-None-Match Etag/If-None-Match 同样需要配合 Cache-control 使用。 Etag 服务器相应浏览器请求时，会告诉浏览器当前资源在服务的唯一标识，标识规则有服务器决定。If-None-Match 当资源过期时（即超过了max-age 定义的时间），发现资源具有 Etag 声明，则在再次向服务器发送求情时带上 If-None-Match（即本地缓存资源的 Etag 值）。服务器收到请求后如果发现有 If-None-Match 则与服务端被请求资源的 Etag 进行比对，如果相同则说明资源无更改并返回 304，否则返回 200 和新的资源。 这四种方式的优先级可以通过一张图来说明：图片来自可以看到 Etag 的优先级是大于 Last-Modified 的。 参考文章：1.浏览器缓存机制2.浏览器缓存相关的HTTP头介绍:Expires,Cache-Control,Last-Modified,ETag 3.HTTP的请求头标签 If-Modified-Since]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Postman 的简单使用]]></title>
    <url>%2F2016%2F02%2F26%2Fsimple-use-of-postman%2F</url>
    <content type="text"><![CDATA[Postman 是一款用来测试 WEB 接口的工具，可以简单的发送 GET 、POST、PUT、DELETE 等请求，可以在 chrome 商店里面搜索安装。为了介绍它的功能，首先本地起一个服务器：var http = require('http');var url = require('url');var querystring = require('querystring');http.createServer(function (req, res) &#123; res.writeHead(200, &#123; 'content-type': 'text/json' &#125;); if (req.method === 'GET') &#123; var params = url.parse(req.url, true).query; res.write(params.name + ' is ' + params.age + ' years old'); res.on('error', function (err) &#123; throw new Error(err); &#125;) res.end(); &#125; else &#123; var resDate = []; req .on('data', function (chunk) &#123; resDate.push(chunk); &#125;) .on('end', function () &#123; var params = querystring.parse(resDate.join('')); res.write(JSON.stringify(params)); res.end(); &#125;) .on('error', function (e) &#123; throw new Error(e) &#125;) &#125;&#125;).listen(8088);console.log('Server listen at localhost:8088'); 用来监听 POST 和 GET 请求，并返回相应的数据。接下来打开 Postman ，界面很简洁，所有的功能都在图上标注了出来上图是模拟 post 请求，填好要发送的参数，点击 send ，就可以看到返回了正确的结果&#123; "name": "moqiao", "age": "23"&#125; GET 请求同理。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Postman</tag>
        <tag>调试工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用ES6重构fullPage]]></title>
    <url>%2F2016%2F02%2F21%2Ffullpage-js-es6%2F</url>
    <content type="text"><![CDATA[用 ES6 重写了 fullpage-light.js。主要做了一下修改： 模块化：将整个文件问个成多个独立的模块，每个模块负责一个功能 新语法：替换一些新的语法，比如变量声明的 let,const,Object.assign 等 转码：因为目前浏览器还并不支持 ES2015,所以还需要用 Babel 做一下转码 模块化根据功能，将整个文件分割成为了五个模块。-bootstrap.js //方法和功能-constant.js //一些常量-event.js //绑定的事件-index.js //入口-utils.js //工具函数 这样原来一个很大文件就被分割成为了五个独立的模块，每个模块只负责自己的功能就好，维护起来会方便很多。 新语法除了用了 let,const 这个声明变量的关键字外，最主要还用 Object.assign 这个方法替换了下面这个函数/** * 扩展 Option 对象 * @param &#123;Object&#125; Default 默认设置 * @param &#123;Object&#125; Customize 自定义设置 * @returns &#123;Object&#125; Default 扩展后的设置 */function extendOption(Default, Customize) &#123; if (typeof Customize !== 'object') &#123; Customize = &#123;&#125;; &#125; for (var i in Customize) &#123; if (Default.hasOwnProperty(i)) &#123; Default[i] = Customize[i]; &#125; &#125; return Default;&#125; options = extendOption(defaults, Customize); //现在options = Object.assign(&#123;&#125;, defaults, Customize); 既然用到了Object.assign，就来说说它吧。参考MDN上的定义： Object.assign() 方法可以把任意多个的源对象所拥有的自身可枚举属性拷贝给目标对象，然后返回目标对象。Object.assign(target, …sources) 也就是说，它可以把…sources包含对象上所有可枚举的属性，复制到目标对象。这样浅拷贝一个对象就很容易了。var obj = &#123;a:1,b:2&#125;var copy = Object.assign(&#123;&#125;,obj);//console.log(copy);//Object &#123;a: 1, b: 2&#125; 同时也可以用来合并若干的对象var a = &#123;a:1&#125;var b = &#123;b:1&#125;var c = &#123;c:1&#125;var copy = Object.assign(&#123;&#125;,a,b,c)copyObject &#123;a: 1, b: 1, c: 1&#125; 但是需要注意的是继承属性和不可枚举属性是不能拷贝的，如果你尝试这么做，会发现虽然语句不会报错，但是继承属性和不可枚举的属性并没有拷贝成功。兼容性上，目前 chrome 已经支持这个属性了，上面的例子都是在 chrome 控制台上实验过的。 转码因为现在浏览器大多还不支持 ES2015 的语法，所以webpack+Babel 来将代码转换为 ES5 的语法。这样，就可以直接在现代浏览器里面使用了。 总结ES6 带来了很大的改进。比如 let 和 const 的块级作用域可以避免一些坑，合理使用箭头函数也可提高代码的可读性，以及 class,promise,module 等新特性，可以大大提高编程的快感。虽然目前兼容性上还是有很多问题，但是有 babel 转码器的存在，也算是可以逐步从 ES3 和 ES5 过渡到 ES2015 了，尤其是最近在尝试用 React，发现用 ES2015 简直爽的飞起。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手机上键盘弹出时的一些问题]]></title>
    <url>%2F2016%2F01%2F12%2F%E8%A7%A3%E5%86%B3%E6%89%8B%E6%9C%BA%E9%94%AE%E7%9B%98%E8%A6%86%E7%9B%96%E5%BC%B9%E7%AA%97%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[做手机商城接到一个需求。具体大概是这样子的，要求用户点击购买按钮后，直接显示输入密码的弹窗并弹出键盘。拿到需求一想，这挺简单的。就麻利的写了个模拟的密码输入框，然后在用户点击购买按钮的时候让他弹出来，并且让焦点 focus 在 input 框上。Chrome 上一试，完全没问题，觉得自己简直太棒了有没有。可是拿出自己的手机一试，oh no ~,键盘直接把页面给推了上去，导致完全看不到弹窗弹的是个什么东西。但是在 Android 上是没有任何问题的。观察了下是因为 Android 和 ios 上键盘弹出的行为是不一样的，Android 上键盘弹出来，直接覆盖在原来的页面上，而 ios 上键盘弹出来的时候会直接把整个页面推上去。怎么解决呢？其实也挺好解决，就是针对不同系统 hack 一下。购买页面这个弹窗的定位是这么定位的：// 后面的遮罩.dialog-wrap&#123; width: 100%; height: 100%; background: rgba(0,0,0,.7); position: relative;&#125;// 密码输入框.password-dialog&#123; position: absolute; top: 0; left: 0; bottom: 0; right: 0; margin: 0;&#125; 在弹窗弹出的时候，判断当前设备是 Android 还是 ios ，如果是 ios 设备，调整一下密码输入框定位就 OK 了。$$('.go-buy').click(function()&#123; showPassword(); //调出弹窗 if(!device.android)&#123; // 如果不是安卓，那就调整定位 $$('.password-dialog').css(&#123; 'top': 'initial', 'bottom': '20px' &#125;) &#125;&#125;) 最终就达到了目标， 之前也遇到过类似的问题，比如页面上有一个输入框，在 Android 上点击输入框调出键盘的时候，因为键盘不会把页面推上去，导致如果这个输入框在当前页面比较靠下的位置，就可能被弹出的键盘覆盖掉，看不到当前选中的输入框，影响用户体验。解决方法其实也很简单，就是当点击输入框弹出键盘的时候，调整页面 scrollTop 值，让页面的可视区域刚好滚动到输入框这一块，也就解决了这个问题。 这些坑，在事后看起来都很简单，然而当刚遇到的时候就是不知道怎么解决。比如密码输入框那个，当时总是在想怎么才能让键盘不把页面推上去，如果从这个角度去想解决办法那恐怕很难想出办法来，因为手机操作系统在实现的时候人家就那么规定了，你总不能用 js 去改这个键盘弹出方式吧，除非你写个模拟键盘，但那就是舍近求远了。但是如果换个角度，从调整页面上元素定位来解决，那就很简单了。所以碰到问题，一定要从多种角度去想解决办法，这样才能更容易的找到问题的解决办法。一定要放开眼界，放开眼界啊！]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>手机开发</tag>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2015年终总结]]></title>
    <url>%2F2015%2F12%2F30%2F2015-year-end-summary%2F</url>
    <content type="text"><![CDATA[来到杭州回想一下二月二十八号怀着忐忑的心来到杭州。 那天天还下着大雨，我从机场出来一路大巴加地铁到滨江区。出了地铁站，站口一个三轮师傅一看我拉一个行李箱，明显外地人，隔老远就吆喝，走不走！想想我怎么也是有导航的人，怎么能让你们坑。然后就跟着导航找酒店，结果怎么找也找不到，就在目的地旁边转来转去，问路人也没人听过酒店名，我一度认为是不是订的酒店有问题。最后无奈，又跑回地铁口，掏了二十块上了三轮，结果五分钟就开到了，其实那酒店距离地铁口也就不到一公里，因为下雨视线不好所以我一直找不到。到了酒店，收拾了一下发现行李箱都被雨水打湿了，赶紧打开看了一下，还好，只有基本放在外面的书有点潮，衣服什么的还是干的。洗了个澡，就出去感受这个被誉为人间天堂的陌生城市了。不得不说，杭州城市真的很干净，而且绿化也很好，但是雨真的真的太多了 找房子到一个新的城市工作，首要的事情就是找房子。说道找房子，不得不说这是一个非常痛苦的过程。 从好友三月初来到杭州开始找房子，找了差不多一星期的时间，最后还是在没办法，两个人第二天都要上班的情况随便找了一个两居室租了下来。这房间说好也还行，说不好那就是太吵了，尤其是天气很冷或者很热人们需要开空调的时候，那噪音，晚上不戴耳塞是没法睡觉的。睡眠质量不好大大影响我了日常工作和生活，可是由于种种原因，暂时又不能搬家，所以也就在各种噪音中度过了小一年时间。 工作本来是拿到余杭区一家公司offer的，三月一号要去报到的。但是被我们现在的老大提前一天拉去面试，发的offer虽然薪水没给到位，甚至还不如另一家公司给的多情况，依然选择了现在的公司。为什么呢？也许我傻吧，至少现在看来当时我确实是傻。一个公司给你薪水的多少，也就是对你能力的认可有多少。整个工作内容，我还是可以轻松 hold 住的，从 PC 到 Mobile，大大小小也有成十个项目，虽然有时会有些棘手的问题，但是在老大的指点下还是轻松解决了。总体上来看，工作内容难度不大，非要说有难度，那也只有工作量上的难度，对这一点我已经无力吐槽了。公司也不知道是因为要上市还是什么原因，整体上都比较浮躁，以至于会出现说让三天搞完一个手机商城这种奇葩的事情。不过工作归工作，不能因为工作难度不大，就忘了提升自己的技能。这一年时间里，大半的业余时间都用在给自己充电上了 。其实是因为周末只有自己一个人，完全不知道该干嘛，除了偶尔一个人去西湖边走走，也就只能写写代码，聊以慰藉了。 其它年初凑了套厨具，像模像样的炒了几次菜，然后基本就再也没有进过厨房； 六月份我投奔的好友因为网易加班过于严重离开了杭州，启程去了武汉，好友的离去伴随的是换了一个新的室友，爱养花养鱼，有时还会做顿饭给我吃； 一个人去游泳，泳池玩了一会出去上了个厕所，回来忘了带泳镜直接跳到深水区，然后睁眼一片浑浊，水性不好的我当时吓得连呛几口水，强行稳定情绪后努力游到了对岸。事后想想真是后怕，深水区那么多人，如果当时没能稳定紧张的情绪恰好安全员又没看到我，那我基本上 GG 了，以后一个人还是不要去深水区了； 陪伴了自己四年的电脑突然散热风扇不转了，淘宝买了风扇装上，风扇是好了，结果屏幕不亮了，换了跟屏线依然没有什么用，只能剁手买了个23寸的显示器外接，不过屏大真心爽； 下雨天早上上班时为了帮一个的哥推抛了锚的车而错过了公交，不过还好的哥免费把我送到了上班的地方； 一个人跑去看电影，结果看的自己眼泪唰唰的，果然是随着年龄的增长，人也变得越来越感性了； 展望20162015年做为自己转行后的第一年，整体上对自己还是比较满意的，但是不能懈怠，要继续保持技术能力的增长，但同时也要提高自己的生活质量，毕竟工作是为了更好的生活嘛。 在此给明年订个简单的规定： 每个月至少写一篇博客 至少每两周看一次电影 每两个月看一本书 加强身体锻炼 该追的美剧不能落下 当然这些计划并不会执行，o(∩_∩)o 哈哈]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>年终总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-v2ex]]></title>
    <url>%2F2015%2F12%2F26%2Freact-v2ex%2F</url>
    <content type="text"><![CDATA[为了练手，用 react 写了个 v2ex 的首页：页面地址项目地址 整个项目基础 react 搭建，样式本来打算用 inlineStyle 来写的，但是发现写起来太累，于是还是用回到 sass，最后用 webpack来编译。本来想着看能不能直接调用 V 站的 API 来做一个纯前端的首页，所有的数据都用 ajax 来调，但是发现因为跨域的问题，前端无法拿到数据，也就放弃了，最终也只能是一个静态页面。 说一下写代码中遇到的一些问题吧，首先整个项目的文件结构如下：│ .babelrc│ .editorconfig│ .eslintrc│ .gitignore│ index.html│ index.js│ package.json│ readme.md│ server.js│ tree.txt│ webpack.config.js│ ├─api│ hot.json│ latest.json│ ├─build│ bundle.js│ index.html│ ├─components│ CommunityStatus.js│ Footer.js│ Header.js│ Main.js│ SearchInput.js│ TopicsHot.js│ UserLink.js│ UserPanel.js│ ├─containers│ App.js│ ├─sass│ │ main.scss│ │ _config.scss│ │ _global.scss│ │ _normalize.scss│ │ _page.scss│ │ │ └─components│ _CommunityStatus.scss│ _Footer.scss│ _Header.scss│ _Main.scss│ _TopicHot.scss│ _UserPanel.scss│ ├─static│ └─images│ qbar_light@2x.png│ └─utils getData.js 优点先说说用 react 写的优点，它火起来不是没有道理的，确实是有很多优点的，我这里只说实际码代码中的优点，不涉及 virtualDom 带来的性能提升之类的。 结构清晰因为 react 本身就是组件化的，所以整个页面按结构被分为几个组件，每个组件自己管理自己的展示和行为，最后通过容器组合起来，结构非常清晰。组件的状态都是通过 state 或者 props 来控制，而我认为大多数组件只需要 props 就行了，只在顶层组件上控制 state，这样可以更加清晰的管理 state。 易于维护因为结构清晰，所以可以预想到，这样是易于维护的。比如头部要改结构和样式，那就只改 Hearker.js 和对应 _Header.scss 就行了，或者要改逻辑，那只要修改 Hearker.js 中和 props 或者 state 相关的代码就行了，不用像以前那样在整个页面的逻辑里面去找这块的代码。这根我目前维护的一些老项目来比，维护性上简直是天壤之别，再也不用愁找不到代码在哪改了，也不用吐槽那一串串的不知道干什么的 jquery 代码了。 省去了模版引擎因为 react 可以说是自带了模版引擎，类似的 jade 或者 ejs 之类的模版引擎也就不需要了，类似这样拿到数据直接渲染就行了。&lt;div&gt; &#123;Hot.map((topic, index) =&gt; &lt;TopicsHotItem &#123;...topic&#125; key=&#123;index&#125; /&gt; )&#125;&lt;/div&gt; 缺点组件划分大小的疑惑一个页面到底要划分成几个部分？根据逻辑分还是根据页面布局分？组件分到那个层级？像V站的这个头部，是划分成一个组件还是三个？当然这个可能不能算是缺点，可能是因为我经验不足以至于无法确定该如何化分。 报错不友好比如我 className 习惯性的写成了 class，然而console里面只是报了个 Did you mean className 的错，但是报不出来错在哪个文件，更不用指望报错在哪行了？只能自己去找，当项目大起来的时候，这个肯定很坑爹。 总结整体来说， react 写起来还是很爽的，而且有点也很明确，组件化·单向数据流·函数式编程，虽然有一些不成熟的问题，但是优点还是突出，如果可以的话，在一些小型项目里实际试水一下应该还是不错的。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于 Express+Gulp+BrowserSync 搭建高性能的前端开发环境]]></title>
    <url>%2F2015%2F11%2F02%2Fdev-environment-Express-Gulp-BrowserSync%2F</url>
    <content type="text"><![CDATA[原文发布于我的博客 为什么要搭这么一套框架公司 Pc 端以前遗留的项目，都是基于jekyll+ruby-sass这一套比较老的技术搭建的。不过 jekyll 的模版继承加上 sass 强大预处理能力，同时配合 Grunt 做任务管理，一切还是很得心应手的。 然而随着项目规模的急剧增大，这一套东西的速度是在是太慢了，一至于后来一旦这个项目有需要求要改我就头疼，倒不是说头疼需求怎么改，而是你随便改一个文件，从 jekyll 检测到改动到编译完 sass 到浏览器自动刷新，基本需要 40+ s，这完全不能接受。 于是一直就打算新搭一套开发环境，刚好前段时间有个新项目，我就拿来操刀动手了，目前已经用它做了俩个项目下来，在原有基础上做了一些修改之后，已经完全可以替代原来那一套懂了。 性能得益于 node-sass 对 ruby-sass 在编译速度上的碾压以及被 jade 完爆的 jekyll。现在项目中从文件变动=&gt;编译完成=&gt;浏览器自动刷新，整个过程在 1s 左右，可以说速度提升了几十倍。而且整个过程都是全自动的，无论你修改了 js,css 还是 html 文件，浏览器都会在重新编译完成后自动刷新。 文件结构这是项目开发时的文件结构： 其中 public,router,views 都是 express 默认的文件结构，这里就不做介绍了。submodule 是我们不同项目中公用的代码库，这样可以少写很多公共代码。 技术细节整个项目的技术栈是 jade+node-sass+js，实现全自动开发。首先在 views 下面，定义好 jade 模版文件，然后开始新加页面 关系依赖这个环境，主要基于 Express,Gulp 以及一系列的Gulp插件搭建，这个是开发环境的依赖关系：&#123; "dependencies": &#123; "body-parser": "~1.13.2", "cookie-parser": "~1.3.5", "debug": "~2.2.0", "express": "~4.13.1", "jade": "~1.11.0", "morgan": "~1.6.1", "serve-favicon": "~2.3.0" &#125;, "devDependencies": &#123; "browser-sync": "^2.9.1", "del": "^2.0.2", "gulp": "^3.9.0", "gulp-autoprefixer": "^3.0.1", "gulp-jade": "^1.1.0", "gulp-nodemon": "^2.0.4", "gulp-sass": "^2.0.4", "gulp-sourcemaps": "^1.5.2", "jade": "^1.11.0" &#125;&#125; 其中，express 主要用来渲染 jade 模版引擎以及提供路由功能，同时起一个本地的服务器。有人说，渲染jade 模版，我直接用 gulp 也可以啊。是的，gulp 是可以直接渲染 jade 模版，但是有一个问题，就是如果你本地只修改了一个 jade 文件时候，gulp 也需要把所有的 jade 文件全部渲染一遍，这明显会浪费很多时间。 所以我引入了 express，只会按需渲染 jade，节省了很多时间。同时一个高效的开发环境必须有浏览器自动刷新，但是 express 没有这个功能。所以我引入了 browser-sync，用它来代理 express 启动的本地服务，然后来监测本地文件的变动，来做到浏览器自动刷新。 有同学可能会问了，如果我改了 express 相应的 js 文件怎么办，或者 jade 文件编译出错了怎么办。因为这些时候 express 服务器都会 crash 掉，需要重启。所以我引入了 nodemon，来做 express 服务器的自动重启功能。 在这个环境下面，我在开发中所能碰到的所有 jade，scss，js 文件的改动都会被检测到并作出相应的动作，而且速度还非常快。让我可以花更多时间在业务代码的开发上，而不是不断重启服务和刷新浏览器。 最后这个东西被我放到 Github上了，地址在这。 同时附上 gulpfile 全文，以供参考： 'use strict';var gulp = require('gulp');var browserSync = require('browser-sync');var reload = browserSync.reload;var sass = require('gulp-sass');var prefix = require('gulp-autoprefixer');var nodemon = require('gulp-nodemon');var sourcemaps = require('gulp-sourcemaps');var jade = require('gulp-jade');var stylus = require('gulp-stylus');var rename = require('gulp-rename');var del = require('del');//dev task start//DONE can not compile the sass or less filegulp.task('sass', function () &#123; return gulp.src(['./sass/personal.scss']) .pipe(sourcemaps.init()) .pipe(sass(&#123;errLogToConsole: true&#125;) .on('error', sass.logError)) .pipe(prefix('last 2 versions', '&gt; 1%', 'ie 8', 'Android 2')) .pipe(sourcemaps.write()) .pipe(gulp.dest('./public/css')) .pipe(reload(&#123;stream: true&#125;));&#125;);gulp.task('browser-sync', ['nodemon'], function () &#123; browserSync.init(null, &#123; proxy: 'http://localhost:3000', files: ['public/**/*.*', 'views/**/*.*', 'submodule/**/*.*'], browser: 'google chrome', notify: false, port: 5000 &#125;);&#125;);gulp.task('movesub', function () &#123; return gulp.src(['./submodule/images/**/*.*'], &#123;base: './submodule'&#125;) .pipe(gulp.dest('./public'))&#125;);gulp.task('stylus', function () &#123; return gulp.src('submodule/stylus/public.styl') .pipe(stylus()) .pipe(rename(&#123; extname: '.scss' &#125;)) .pipe(gulp.dest('submodule/stylus/'))&#125;);gulp.task('nodemon', function (cb) &#123; del(['./public/*.html']); var called = false; return nodemon(&#123; script: 'bin/www' &#125;).on('start', function () &#123; if (!called) &#123; cb(); called = true; &#125; &#125;);&#125;);//dev task endgulp.task('clean', function (cb) &#123; del(['./dist/*'], cb)&#125;);gulp.task('copy', function () &#123; return gulp.src([ 'public/css/**/*', 'public/images/**/*', 'public/js/**/*', 'public/pageScripts/**/*' ], &#123;base: './public'&#125;) .pipe(gulp.dest('./dist'))&#125;);//build task start//DONE add build taskgulp.task('jade', function () &#123; return gulp.src(['views/**/*.jade', '!views/layout/**/*.jade', '!views/includes/**/*.jade']) .pipe(jade(&#123;pretty: true&#125;)) .pipe(gulp.dest('./dist'));&#125;);//build task endgulp.task('dist', ['clean', 'copy', 'jade']);gulp.task('default', ['browser-sync', 'sass', 'movesub'], function () &#123; gulp.watch(['sass/**/*.*', '.submodule/stylus/**/*.*'], ['sass']);&#125;);]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Express</tag>
        <tag>开发环境</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Canvas 基础]]></title>
    <url>%2F2015%2F10%2F19%2Ffirst-contact-of-canvas%2F</url>
    <content type="text"><![CDATA[首先引用 MDN 上对于 canvas 的定义： &lt;canvas&gt; 是 HTML5 新增的元素，可使用JavaScript脚本来绘制图形。例如：画图，合成照片，创建动画甚至实时视频处理与渲染。 也就是说这是浏览器提供给我们的一个画布和丰富的接口，可以用来制作各种复杂的效果。&lt;canvas&gt; 元素创造了一个固定大小的画布，它公开了一个或多个渲染上下文。其可以用来绘制和处理被现实的页面。这是 canvas 2d 的坐标，可以看到左上角为原点，横轴为x轴，纵轴为y轴。我们所有的canvas2d的功能实现都是在这个坐标系中。 基本用法本文只简单介绍一下矩形、线段和圆弧的画法。 矩形通过一个简单的例子来了解一下基本的API： HTML:&lt;canvas id="canvas" style="height:100%"&gt; 当前浏览器不支持Canvas，请更换浏览器后再试&lt;/canvas&gt; JavaScript:var canvas = document.getElementById(&apos;canvas&apos;);var ctx = canvas.getContext(&apos;2d&apos;);var WINDOW_WIDTH = window.screen.availWidth;var WINDOW_HEIGHT = window.screen.availHeight;ctx.clearRect(0, 0, WINDOW_WIDTH, WINDOW_HEIGHT)ctx.beginPath();ctx.fillStyle = &apos;#000&apos;;ctx.fillRect(10, 10, 55, 50);ctx.fillStyle = &apos;rgba(0,0,200,0.5)&apos;ctx.fillRect(30, 30, 55, 50); 页面上会如下显示： 首先获取到 canvas 元素，并通过 getContext(‘2d’) 获取到它的渲染上下文。 clearRect(x, y, width, height)清空指定区域，如果需要做动画的话，每次重新渲染前都需要调用这个函数来清除前一帧的内容。 beginPath()新建一条路径 fillStyle用来设置要填充的颜色 ctx.fillRect(10, 10, 55, 50);以x轴等于10，y轴等于10为起点，绘制一个宽55高50的矩形。 strokeRect(x,y,width,height)跟fillRect不同的地方在于，strokeRect会绘制一个矩形的边框，如下： 线段绘制一个三角形ctx.beginPath();ctx.moveTo(75, 50);ctx.lineTo(100, 75);ctx.lineTo(100, 25);ctx.closePath();ctx.stroke(); moveTo(x,y)定义一个起点，从这个点开始绘制 lineTo(x,y)绘制一条从当前位置到指定x以及y位置的直线 closePath()闭合当前路径，也可以用lineTo到起点来代替 storke()根据已有路径的来绘制线段，也就是说如果不执行stroke(),那么画布上什么都没有。 圆弧arc(x, y, radius, startAngle, endAngle, anticlockwise)该方法有五个参数： x,y为绘制圆弧所在圆上的圆心坐标。radius为半径。startAngle以及endAngle参数用弧度定义了开始以及结束的弧度。这些都是以x轴为基准。参数anticlockwise 为一个布尔值。为true时，是逆时针方向，否则顺时针方向。看个直观的例子：ctx.beginPath();truectx.arc(75, 75, 50, 0, Math.PI * 2, true);truectx.moveTo(110, 75);truectx.arc(75, 75, 35, 0, Math.PI, false);truectx.moveTo(65, 65);truectx.arc(60, 65, 5, 0, Math.PI * 2, true);truectx.moveTo(95, 65);truectx.arc(90, 65, 5, 0, Math.PI * 2, true);truectx.stroke();truectx.clearRect(0, 0, 500, 500);truefor (var i = 0; i &lt; 4; i++) &#123;truetruefor (var j = 0; j &lt; 3; j++) &#123;truetruetruectx.beginPath();truetruetruevar x = 20 + j * 40;truetruetruevar y = 20 + i * 40;truetruetruevar radisu = 20;truetruetruevar startAngle = 0;truetruetruevar endAngle = Math.PI + (Math.PI * j) / 2;truetruetruevar anticlockwise = i % 2 == 0 ? true : false;truetruetruectx.arc(x, y, radisu, startAngle, endAngle, anticlockwise);truetruetrueif (i &gt; 1) &#123;truetruetruetruectx.fill();truetruetrue&#125; else &#123;truetruetruetruectx.stroke();truetruetrue&#125;truetrue&#125;true&#125; 通过这个例子可以看清楚的看到 fill 和 stroke 这个两个函数的区别，前者渲染边框，后者填充整个指定区域。同时可以区分，anticlockwise 分别 true 和 false 时渲染的机制，前者为逆时针，后者为顺时针。# 总结仅仅通过这三个基础的用法，就可以制作出很多漂亮的动画了。我这里做了一个简单运动的小球，同时做了边界判定。 参考文章： MDN-Canvas]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[轻量级fullPage整屏滚动框架V1.3发布]]></title>
    <url>%2F2015%2F10%2F13%2Ffullpage-js%2F</url>
    <content type="text"><![CDATA[项目初衷前段时间接到一个新的项目，是一个整屏滚动的单页应用。 本来打算完全自己写的，但是由于项目时间吃紧，就用了fullpage这个框架。这个框架确实很强大，几乎你想要的API它都有，所以用起来也很方便。 但是它也有几个缺点，第一它必须依赖 jQuery,而且文件体积也比较庞大，对于移动端来说不是很友好。于是自己就抽出业余时间，写了这个项目。 项目地址 一个简单的DEMO changeListV1.3.0 修复对firefox的支持 添加页面导航控制 解决一些bug V1.1.0 添加自动播放 添加循环播放 V1.0.0 支持移动端触摸控制 添加slide水平滑动 添加PC端键盘控制和鼠标滚轮控制 提供实用的API方便开发 简介一个轻巧的fullpage框架，不依赖其他任何库，主要针对移动端设备（同时也支持桌面端），压缩后不到4kb。轻松创建炫酷的单页滑动网站。 兼容性 Android 4.1+ Safari 7.1+ IE Edge Opera Chrome 使用方法 引入 JavaScript 文件 fullpage.js 引入 css 文件 fullpage.css（如果你使用less，则可以在less主文件中引入fullpage.less） 按照下面格式书写html代码（其中 id 为 sectionContent 的为包裹层，你可以自定义修改其id） &lt;div id=&quot;sectionContent&quot; class=&quot;fp-section-content&quot;&gt; &lt;div class=&quot;fp-section&quot;&gt; &lt;div class=&quot;fp-slide-wrap&quot;&gt; &lt;div class=&quot;fp-slide&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;fp-slide&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;fp-slide&quot;&gt;3&lt;/div&gt; &lt;div class=&quot;fp-slide&quot;&gt;4&lt;/div&gt; &lt;div class=&quot;fp-slide&quot;&gt;5&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;fp-section&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;fp-section&quot;&gt;3&lt;/div&gt; &lt;/div&gt; 初始化简单使用，只要在页面加载完成后执行： fullpage.init(&apos;#sectionContent&apos;); 如果需要定制化，则需要如下方法：fullpage.init(&apos;#sectionContent&apos;,&#123; threshold: 10, //触发滚动事件的阈值，越小越灵敏 pageSpeed: 600, //滚屏速度，单位为毫秒 ms afterLoad: null, //页面载入事件，具体查看下面的 afterLoad 函数 beforeLeave: null //页面离开事件，具体查看下面的 beforeLeave 函数 &#125;); ##beforeLeave(leaveIndex,nowIndex)离开当前页面时触发的事件，函数中 this 指向当前页面的 section,leaveIndex为要离开页面的 index ，nowIndex 为要载入页面的 Index ##afterLoad(afterIndex)载入下一张页面后触发的事件，函数中 this 指向将要载入页面的 section, afterIndex 为要载入页面的 indexfullpage.init('#sectionContent', &#123; beforeLeave: function (leaveIndex, nowIndex) &#123; //如果现在在第1个页面，向下滚动后 if (nowIndex === 2) &#123; //leaveIndex = 1,nowIndex = 2 console.log('You will leave page 2') //这条语句会执行 &#125; console.log(this, leaveIndex, nowIndex) //这里的 this 指向将要离开的页面元素，即第一个页面 &#125;, afterLoad: function (afterIndex) &#123; //afterIndex = 2 if (afterIndex === 2) &#123; console.log('You will go to page 2') //这条语句会执行 &#125; console.log(this, afterIndex) //此处 this 指向当前载入的页面，即第二个页面 &#125;&#125;); 方法##init(el,options)页面初始化，el为最外包裹层选择器，options是要定制的参数。具体同初始化 ##moveTo(index,slideIndex)滚动到指定页面,index 为必选参数，slideIndex为可选参数fullpage.moveTo(1) //滚动到第一个页面fullpage.moveTo(3,2) //滚动到第三个页面的第二个slider ##moveToNext(callback)垂直滚动到下一个页面,callback为回掉函数，可选。fullpage.moveToNext(); //滚动到下一个页面fullpage.moveToNext(callback) //滚动到下一个页面后，执行 callbackfullpage.moveToNext(callback,params...) //滚动到下一个页面后，执行 callback,params为callback的参数，根据情况传入function foo(a,b)&#123; console.log(a,b)&#125;fullpage.moveToNext(foo,1,2) //滚动到下一个页面，并输出 1，2 moveToPre(callback)垂直滚动到上一个页面，用法同 moveToNext(callback) slideToNext()水平滚动到下一个页面（页面向左滚动） slideToPre()水平滚动到上一个页面（页面向右滚动） TODO 添加滚动到指定页面方法 页面滚动时，页面载入或离开时添加自定义事件 横屏滚动支持 添加鼠标滚轮控制 添加键盘控制]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>project</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初试 react-router]]></title>
    <url>%2F2015%2F10%2F08%2Freact-router%2F</url>
    <content type="text"><![CDATA[react-router 提供简单有强大 API 来方便我们在React搭建的单页面中实现路由功能。首先看一个简单的例子：import React from 'react'import &#123;render,findDOMNode&#125; from 'react-dom'import &#123; Router, Route, Link &#125; from 'react-router'let Page1 = React.createClass(&#123; render()&#123; return ( &lt;div&gt;&lt;h1&gt;Page1&lt;/h1&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Ab accusantium animi dicta dignissimos earum eos esse impedit ipsum iste laboriosam numquam odio perspiciatis porro, quas sequi tempore vero vitae voluptates?&lt;/div&gt; ) &#125;&#125;);let Page2 = React.createClass(&#123; render()&#123; return ( &lt;div&gt;&lt;h1&gt;Page2&lt;/h1&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Fuga porro voluptas voluptatum. Corporis debitis deleniti, doloremque et eum ex id iste magni nobis nostrum quae, reiciendis rem repellendus similique tempora.&lt;/div&gt; ) &#125;&#125;);let App = React.createClass(&#123; render()&#123; return ( &lt;div &gt; &lt;Link to="/page1"&gt;Page1&lt;/Link&gt; &lt;Link to="/page2"&gt;Page2&lt;/Link&gt; &lt;/div&gt; ) &#125;&#125;);render(( &lt;Router&gt; &lt;Route path="/" component=&#123;App&#125;&gt; &lt;Route path="page1" component=&#123;Page1&#125;/&gt; &lt;Route path="page2" component=&#123;Page2&#125;/&gt; &lt;/Route&gt; &lt;/Router&gt;), document.body); 只需要在 &lt;Link&gt; 标签中的 to 属性中定义路径，那么在渲染出的页面中点击 Page1 或 Page2 标签，就会显示相应的 Components，而且 url 也会跟着路径进行变化。我们来简单分析一个这段代码，这里我们定义了三个路由，一个指向根目录即 ‘/‘,一个指向 ‘page/‘,一个指向 ‘page/2’.路由定义必须包裹在 &lt;Router&gt;&lt;/Router&gt; 中。&lt;Route&gt;&lt;/Route&gt;为每一个路由要定义的路径，并处理它的行为。其中 path 为路径， component 为要渲染的组件。并且还可以提供相应的 handle，用来处理控制路由的行为。接下来我们来模拟一个拦截登陆的行为。import React from 'react'import &#123;render,findDOMNode&#125; from 'react-dom'import &#123; Router, Route, Link, History &#125; from 'react-router'import TransitionGroup from 'react-addons-transition-group'require('./index.css');let goLogin = &#123; isLogin: true, login()&#123; this.isLogin ? this.onChange(false) : this.onChange(true) this.isLogin = !this.isLogin &#125;, onChange()&#123; &#125;&#125;;let App = React.createClass(&#123; getInitialState()&#123; return &#123; login: goLogin.isLogin &#125; &#125;, updateAuth(logged)&#123; this.setState(&#123; login: logged &#125;) &#125;, componentWillMount()&#123; goLogin.onChange = this.updateAuth &#125;, render()&#123; return ( &lt;div &gt; &lt;nav className="nav"&gt; &#123;this.state.login ? ( &lt;Link to="/logout"&gt;Log out&lt;/Link&gt; ) : ( &lt;Link to="/login"&gt;Log in&lt;/Link&gt; ) &#125; &lt;/nav&gt; &lt;ul&gt; &lt;li&gt;&lt;Link to="/page1" activeClassName="active"&gt;Page1&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to="/page2" activeClassName="active"&gt;Page2&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &#123;this.props.children&#125; &lt;/div&gt; ) &#125;&#125;); let Login = React.createClass(&#123; mixins: [History], handleClick(event)&#123; event.preventDefault(); goLogin.login(); var &#123;location&#125; = this.props if (location.state &amp;&amp; location.state.nextPathname) &#123; this.history.replaceState(null, location.state.nextPathname) &#125; else &#123; this.history.replaceState(null, '/about') &#125; console.log(this.history) &#125;, render()&#123; return ( &lt;div&gt; &lt;button onClick=&#123;this.handleClick&#125;&gt;Login&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;);let Logout = React.createClass(&#123; componentDidMount()&#123; goLogin.login() &#125;, render()&#123; return ( &lt;div&gt; &lt;p&gt;You are now logged out&lt;/p&gt; &lt;/div&gt; ) &#125;&#125;);let About = React.createClass(&#123; render()&#123; return ( &lt;div&gt; &lt;h1&gt;登录成功&lt;/h1&gt; &lt;/div&gt; ) &#125;&#125;)let Page1 = React.createClass(&#123; render()&#123; return ( &lt;div className="page"&gt;&lt;h1&gt;Page1&lt;/h1&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Ab accusantium animi dicta dignissimos earum eos esse impedit ipsum iste laboriosam numquam odio perspiciatis porro, quas sequi tempore vero vitae voluptates?&lt;/div&gt; ) &#125;&#125;);let Page2 = React.createClass(&#123; getInitialState()&#123; return &#123; className: 'pageactive' &#125; &#125;, handler()&#123; if (this.state.className === 'pageactive') &#123; this.setState(&#123; className: '' &#125;) &#125; else &#123; this.setState(&#123; className: 'pageactive' &#125;) &#125; &#125;, render()&#123; return ( &lt;div className=&#123;`$&#123;this.state.className&#125; page`&#125; onClick=&#123;this.handler&#125;&gt;&lt;h1&gt;Page2&lt;/h1&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Fuga porro voluptas voluptatum. Corporis debitis deleniti, doloremque et eum ex id iste magni nobis nostrum quae, reiciendis rem repellendus similique tempora.&lt;/div&gt; ) &#125;&#125;) 定义 needLogin 函数，用来判断用户否登陆并根据情况跳转到相应的页面。function needLogin(nextState, replaceState) &#123; if (!goLogin.isLogin) &#123; replaceState(&#123;nextPathname: nextState.location.pathname&#125;, '/login') &#125;&#125; 最后，执行 render 命令。render(( &lt;Router&gt; &lt;Route path="/" component=&#123;App&#125;&gt; &lt;Route path="login" component=&#123;Login&#125;/&gt; &lt;Route path="logout" component=&#123;Logout&#125;/&gt; &lt;Route path="about" component=&#123;About&#125;/&gt; &lt;Route path="page1" component=&#123;Page1&#125;/&gt; &lt;Route path="page2" component=&#123;Page2&#125; onEnter=&#123;needLogin&#125;/&gt; &lt;/Route&gt; &lt;/Router&gt;), document.body); 点击这里查看DEMO这段代码实现了这么一个功能： 首先页面默认为未登录状态。 此时点击 Page1,会显示 Page1 的内容。 点击 Page2 的时候，Page内容的显示被拦截，出现登陆页面。 当你点击 login 后，就会显示 Page2 的内容，并且状态切换为 Logout. 当我们点击 Logout 的时候，就会退出登录。 在这段代码中，当我们点击 page2 的时候，首先会触发 &lt;Link&gt; 标签中的 to 属性来找到对应的path为 page2 的路由，然后会触发 needLogin 事件。在 needLogin 事件中，我们判断 goLogin.isLogin 事件，如果未登录，则将路径替换为 ‘/login’.并在 &lt;Route&gt; 中找到 path 为 ‘/login’ 的一项，然后渲染 Login 组件。也就是说我们可以在 &lt;Route&gt; 中监听事件，以此来根据需要动态的改变路由地址。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>React</tag>
        <tag>react-router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[learnyounode-functional-javascript]]></title>
    <url>%2F2015%2F09%2F23%2Flearnyounode-functional-javascript%2F</url>
    <content type="text"><![CDATA[坑爹的CMD不知怎么回事，在做到倒数第三道题后突然罢工了，不能选择题目，公司和自己的电脑都是这样。于是最后三道题还是放弃了，也没精力去找那三道题到底是什么了，就这样吧。 做题的过程中有个需要注意的地方，也是在js中一个很常用的方法。那就是被setTimeout延迟的函数会等前面函数彻底执行完以后，才会执行,也就是说可以阻塞js的进程。如下：function repeat(operation, num) &#123; // modify this so it can be interrupted if (num &lt;= 0) return operation(); setTimeout(function()&#123; return repeat(operation, --num); &#125;,0)&#125;module.exports = repeat Operation是一个操作很费时间的函数，如果不用setTimeout延迟后面的递归调用的话，就会造成repeat函数已经执行完了，但是含有很多个operation没有执行完的情况。 其它的到没有什么了，所有代码都放在这里]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ECMAScript6学习简记（三）- 函数扩展]]></title>
    <url>%2F2015%2F09%2F08%2FLearning-ECMAScript6-Three%2F</url>
    <content type="text"><![CDATA[1.函数参数默认值以前我们经常会些下面的代码 function doS(e)&#123; e = e|window.e; //doSomeThing with e&#125; 通过这样的方法来给函数设置默认值，这样有一个缺点就是，如果传进来的参数对应的布尔值为false，比如空字符串或者0，那就尴尬了。 所以如果我们还想上面的代码得到正确的结果，就需要对e在做一个判断，判断它是否被赋值了。 这样会很麻烦，所以ES6有了新的方法，如下 function doS(e=window.e)&#123; //doSomeThing with e&#125; 这样不尽代码简短了很多，而且可读性大大提高，看代码的人可以一样看到那些参数是有默认值的。同时，默认值的设置也非常人性化 function get(url,&#123;body='',method='GET')&#123; console.log(method);&#125; 上面的代码中，传入第二个参数是一个对象，我们可以给对象的属性设置默认值。 甚至还可以设置双重默认值。fetch(url, &#123; method = 'GET' &#125; = &#123;&#125;)&#123; console.log(method);&#125; 上面代码中，调用函数fetch时，如果不含第二个参数，则默认值为一个空对象；如果包含第二个参数，则它的method属性默认值为GET。 参数的默认值设置同样支持解构赋值， function ha(&#123;x,y=5&#125;)&#123; console.log(x,y);&#125;ha() //TypeError: Cannot read property 'x' of undefinedha(&#123;&#125;) //undefined 5ha(&#123;x:1&#125;) //1 5ha(&#123;x:1,y:2&#125;) //1 2 定义默认值的参数，必须在参数的尾部，因为有了默认之后参数可以被省略，而只有位于尾部，函数才能判断到底省略了那个参数。 如果给设置默认值的参数传入undefined和null,前者该函数会触发默认值，而后者不会。 function a(b=1,c=2)&#123; console.log(b,c);&#125;a(undefined,null);//1 null 需要注意的是，如果设置了默认值，那么函数的length属性会失真 &gt; (function a(a,b)&#123;&#125;).length2&gt; (function b(a,b,c)&#123;&#125;).length3&gt; (function c(a,b,c=1)&#123;&#125;).length2&gt; (function e(a,b=1,c=1)&#123;&#125;).length1 可以看到，没设置默认值的时候，函数的length等于它的参数个数，而设置了默认值之后，它的length值等于没有设置默认值的参数的个数。 2.rest参数rest参数用于获取函数的多余变量，这样可以避免使用arguments对象。 function add(...values) &#123; let sum = 0; values.forEach(function(value)&#123; sum += value; &#125;); return sum;&#125;&gt; add(1,2,3,4,5)15 可以看到，该函数可以返回传入参数的和。同时，注意到rest参数其实是一个数组，所以数组的方法它都可以使用，所以上面代码中的forEach是可以使用的。 需要注意的是，rest参数同参数的默认值一样，必须在参数的最后。而函数的length属性是不包括rest参数的。 (function(a) &#123;&#125;).length // 1(function(...a) &#123;&#125;).length // 0(function(a, ...b) &#123;&#125;).length // 1 3.扩展运算符扩展运算符，符号三个点（…），它可以看作是rest参数的你运算，可以讲一个数组转为用逗号分割的参数序列。 &gt; let array = [1,2,34];&gt; console.log(...array)1 2 34&gt; console.log(11,22,...array,4)11 22 1 2 34 4 该运算符主要用于函数的调用。 function push(array, ...items) &#123; array.push(...items);&#125;function add(x, y) &#123; return x + y;&#125;var numbers = [4, 38];add(...numbers) // 42 上面代码中，array.push(…items)和add(…numbers)这两行，都是函数的调用，它们的都使用了扩展运算符。该运算符将一个数组，变为参数序列。 由于扩展运算符可以展开数组，所以不再需要apply方法，将数组转为函数的参数了。// ES5的写法function f (x, y, z)&#123;&#125;var args = [0, 1, 2];f.apply(null, args);// ES6的写法function f (x, y, z)&#123;&#125;var args = [0, 1, 2];f(...args); 一个实际的例子： &gt; let a=[1,23,12,31,23,12,31,23,123,12,31,24,]'use strict'&gt; Math.max(...a)123//ES5要实现同样的功能则需要Math.max.apply(null,a); 扩展运算符可以简化很多种ES5的写法 // ES5[1, 2].concat(more)// ES6[1, 2, ...more]// ES5list.push.apply(list, [3, 4])// ES6list.push(...[3, 4])// ES5list = [1,2,3,4]var a = list[0], rest = list.slice(1)a = 1,rest = [2,3,4]// ES6 这里是用到了解构赋值var [a, ...rest] = lista = 1,rest = [2,3,4]// ES5new (Date.bind.apply(Date, [null, 2015, 1, 1]))// ES6new Date(...[2015, 1, 1]); 需要注意的是，如果将扩展运算符用于数组赋值，只能放在参数的最后，否则会报错。（这是肯定的嘛，否则程序怎么知道扩展运算符的长度是多少）。 扩展运算符可以将字符串转为数组(Array.from()也可以)。 &gt; [...'hello'][ 'h', 'e', 'l', 'l', 'o' ] 4.箭头函数基本用法使用‘箭头’来快速定义函数let fn = f =&gt; f; 相当于let fn = function(f)&#123; return f;&#125; 当不需要参数的时候，或参数大于一个的时候，用括号代表参数部分： var f = () =&gt; 5;//等于var f = function()&#123;return 5&#125;;var sum =(sum1,sum2) =&gt; num1 + num2;//等于var sum = function(sum1,sum2)&#123; return sum1+sum2;&#125; 总之箭头后面就是函数要return的内容。当箭头函数的代码块部分多余一条语句的时候，需要用大括号括起来，并且使用return返回。而由于大括号被解释为代码块，所以如果箭头函数需要返回对象的时候，必须在对象外面加上括号，否则会被解释为代码块。 var sum = (num1,num2) =&gt; &#123;return num1+num2&#125;;var sum1 = sumI =&gt; (&#123;su1:'1',su2:'2'&#125;); 同样，箭头函数可以配合变量的解构赋值。 let person = (&#123;you,i&#125;) =&gt; you + 'love' + i;&gt; person(&#123;you:'y',i:'i'&#125;)'ylovei'//等于var person = function(obj)&#123; return obj.you +'love'+obj.i;&#125; 使用注意点 箭头函数有几个使用注意点。 （1）函数体内的this对象，绑定定义时所在的对象，而不是使用时所在的对象。 （2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。 （3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。 （4）不可以使用yield命令，因此箭头函数不能用作Generator函数。 上面四点中，第一点尤其值得注意。this对象的指向是可变的，但是在箭头函数中，它是固定的。下面的代码是一个例子，将this对象绑定定义时所在的对象。 版权文章中所有代码皆来自或演变自： 阮一峰-ECMAScript 6 入门,本文同样遵循署名-非商用许可证.]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ECMAScript6学习简记（二）- 数组扩展]]></title>
    <url>%2F2015%2F09%2F02%2Flearning-ECMAScript6-Two%2F</url>
    <content type="text"><![CDATA[Array.from()将类数组或可迭代对象转换为真正的数组。 可转换的类别Dom集合let ps = document.querySelectAll('p'); //通过Array.from 转换后可以使用forEach方法Array.from(ps).forEach(function(p,index)&#123; "use strict";trueconsole.log(p,index)&#125;); arguments对象function foo() &#123; "use strict";truevar args = Array.from(arguments); //可以替代以前下面这种方式来转换truevar argvs = Array.prototype.slice.call(arguments);trueconsole.log(argvs, args);&#125;foo(1, 2, 3, 4); //[ 1, 2, 3, 4 ] [ 1, 2, 3, 4 ] 拥有length属性的对象var obj = &#123;true0: 'a',true1: 'b',true2: 'c',truelength: 3&#125;;var obj1 = &#123;true0: 'a',true1: 'b',true2: 'c'&#125;;console.log(Array.from(obj)); //['a','b','c']console.log(Array.from(obj1)); //[] 没有length属性，无法转换 注意，对象的属性值必须是数字，否则转换的数组内容都是undefined let obj2=&#123;true'a':1,true'b':2,true'c':3,truelength:3&#125;;console.log(Array.from(obj2)); //[ undefined, undefined, undefined ] 同时Array.from()接受第二个参数，作用类似于map方法console.log(Array.from(obj, x=&gt;x + '1')); //[ 'a1', 'b1', 'c1' ] 类似于map方法 #Array.of()可将一组值转换为数组Array.of(3, 12, 2, 3, 24, 2); //[ 3, 12, 2, 3, 24, 2 ] 将一组值转换为数组Array.of(3, &apos;12&apos;, [2], 3, 24, 2); //[ 3, &apos;12&apos;, [ 2 ], 3, 24, 2 ] 这个方法的目的是为了弥补数组构造函数的Array()的不足，因为当参数个数不同时，它会产生不同的效果Array(8) // [ , , , , , , , ]Array(3,11) // [3, 11] find()和findIndex() 数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。 var found = [1, 2, 3, 4, -1].find(n=&gt;n &lt; 0); //find 找出第一个返回值为true的成员var founded = [1, 2, 3, 4, -1].find(function (b) &#123;truereturn b &gt; 3&#125;);console.log('result:', found, founded); //result: -1 4 findIndex返回第一个符合条件的值的index,如果没找到则返回 -1. var foundIndex = [1,2,324,5,34].findIndex(function(value,index,arr)&#123; "use strict";truereturn value &gt; 100;&#125;);console.log(foundIndex); //2 这两个方法都可以发现NaN，而IndexOf是不能发现的。 console.log([2,3,4,NaN].indexOf(NaN)); //-1console.log([1,2,NaN].find(value=&gt;Object.is(NaN,value))); //NaNconsole.log([1,2,3,4,NaN].findIndex(value=&gt;Object.is(NaN,value))); //4 Array.fill()使用给定值，填充一个数组[1,2,3,4].fill('a'); //[ 'a', 'a', 'a', 'a' ]new Array(6).fill(3); //[ 3, 3, 3, 3, 3, 3 ] fill()还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。[1,2,3,4].fill(8,1,2) //[1,8,3,4][1,2,3,4].fill(8,1,3) //[ 1, 8, 8, 4 ] entries()，keys()和values()这三个方法都是用来遍历数组，可以使用for...of来进行遍历，keys()用来遍历键名，values()用来遍历键值，entries()对键值对遍历。 for (let index of ['a', 'b'].keys()) &#123;trueconsole.log(index);&#125;// 0// 1for (let elem of ['a', 'b'].values()) &#123;trueconsole.log(elem);&#125;// 'a'// 'b'for (let [index, elem] of ['a', 'b'].entries()) &#123;trueconsole.log(index, elem);&#125;// 0 "a"// 1 "b" 个人感觉意义不大，和以前的forEach是一样的功能，有个不同的地方是如果不适用for...of遍历的话，可以使用next来手动遍历。let word = ['h','e','l','l','o'];let entries = word.entries();console.log(entries.next().value); [0,'h']console.log(entries.next().value); [1,'e'] 其他方法这些都属于ES7要实现的内容 include判断一个数组是否包含给定的值，返回的是一个布尔值。 数组推导感觉这里跟python越来越像了。 var a1 = [1, 2, 3, 4];var a2 = [for (i of a1) i * 2];a2 // [2, 4, 6, 8] for…of 后面还可以附加if语句，用来设定循环的限制条件。 var years = [ 1954, 1974, 1990, 2006, 2010, 2014 ];[for (year of years) if (year &gt; 2000) year];// [ 2006, 2010, 2014 ][for (year of years) if (year &gt; 2000) if(year &lt; 2010) year];// [ 2006][for (year of years) if (year &gt; 2000 &amp;&amp; year &lt; 2010) year];// [ 2006] Array.observe()，Array.unobserve()用于监听和数组的变化，制定回调函数。比较期待这个方法，作用会很大。 #版权文章中所有代码皆来自或演变自： 阮一峰-ECMAScript 6 入门,本文同样遵循署名-非商用许可证.]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ECMAScript6学习简记（一）-变量声明·字符串扩展·数值扩展]]></title>
    <url>%2F2015%2F08%2F21%2FLearning-ECMAScript6-One%2F</url>
    <content type="text"><![CDATA[let 和 const 命令let 命令let 声明的变量，只存在与所声明的代码块内。 &#123; let a = 10; var b = 11;&#125;console.log(a) //ReferenceError: a is not definedconsole.log(b) //11 可以看到，在代码块外面，是不能访问到用 let 声明的变量，也就是说 let 声明的变量是基于块级作用域的。这样就可以避免一些变量声明的问题。 var arr = [1,2,3]for(let i = 0;i&lt;arr.length;i++)&#123;&#125;console.log(i) //ReferenceError: a is not defined 可见上面的的代码 for 循环外面是不能访问到变量 i 的。而下面的代码用 var 声明，最后会输出10。 var a = [];for (var i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 10 而如果使用 let，则会输出6。而以前要做到这样，可能会需要使用立即执行函数才行。 var a = [];for (let i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 6 而且 let 不会像 var 一样发生‘变量提升’现象。 function a()&#123; console.log(b) //ReferenceError let b = 2;&#125;function c()&#123; console.log(d); //undefined var d = 2; 在块级作用域内，使用 let 声明的变量，会当定在这个区域，不会受到外部的影响。 var temp = 123;let temp1 = 222;var temp2 = 555;if(true)&#123; let temp =333; let temp1 =444; console.log(temp); //333 console.log(temp1); //444 console.log(temp2) //ReferenceError let temp2 = 555;&#125; let 在一个作用域内不允许重复声明同一个变量 function()&#123; let a = 10; var a = 1;&#125;function()&#123; let a = 11; let a = 212;&#125; const 命令const 同 let 类似，只是用 const 声明的变量是常量，一旦声明就不可更改。 const a = 1;a //1a =3;a //1const a = 12a //1 需要注意的是，const 命令只是指向变量所在的地址，所以将对象声明为常量时需要注意。 const foo = &#123;&#125;;foo.prop = 1;foo.prop //1const a = [];a.push("Hello"); // 可执行a.length = 0; // 可执行a = ["Dave"]; // 报错 上面代码中，常量foo储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。 也就是说将一个对象或数组声明为常量时，它本身是不可赋值的，但是可以给它添加方法。因为不变的只是它本身的地址。 全局对象的属性 ES6规定，var命令和function命令声明的全局变量，属于全局对象的属性；let命令、const命令、class命令声明的全局变量，不属于全局对象的属性。 var a = 1;// 如果在node环境，可以写成global.a// 或者采用通用方法，写成this.awindow.a // 1let b = 1;window.b // undefined 变量的解构赋值ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构。感觉这里跟 python 挺像的。 数组的解构赋值var [a,b] = [1,2];console.log(a,b);//1 2let [c,d] = [3,4];console.log(c,d);//3 4 实际上，它属于‘模式匹配’，也就是说，只要等号两边的模式相同，那么左边的变量就会被赋予相应的值。 var [a,b,[c,d]] = [1,2,[3,4]];//a = 1,b = 2,c = 3,d = 4var [aa,bb,cc] = [,,3]//aa = undefined,bb = undefined,cc = 3;let [one,...more] = [1,2,3,4,5,6]//one = 1,more = [2,3,4,5,6] 可以看到上面的代码，只要他们的结构相同，那么左边相应位置的变量就会被赋值为右边的对应的值。如果没有对应的值，那么就是 undefined.以下情况属于解构不成功，都会报 TypeError 的错，然后变量的值会等于 undefined. 以上几种情况都属于解构不成功，foo的值都会等于undefined。这是因为原始类型的值，会自动转为对象，比如数值1转为new Number(1)，从而导致foo取到undefined。 var [foo] = [];var [foo] = 1;var [foo] = false;var [foo] = NaN;var [bar, foo] = [1];let [foo] = undefined;let [foo] = null; 解构赋值允许指定默认值。当数组成员严格等于 undefined 时，默认值就会生效。 var [foo = true] = [];foo // true[x, y='b'] = ['a'] // x='a', y='b'[x, y='b'] = ['a', undefined] // x='a', y='b'[x, y='b'] = [1 ,null ] // x= 1,y=null 对象的解构赋值结构同样作用于对象,于数组不同的地方在于：数组的元素的取值由它的位置决定；对象属性因为没有顺序，所以变量名需要与属性同名，才能取到正确的值。 var &#123; foo, bar &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;foo // "aaa"bar // "bbb"//注意两者区别var &#123; foo, bar &#125; = &#123; bar: "aaa", foo: "bbb" &#125;;foo // "bbb"bar // "aaa"var &#123;fos&#125; = &#123;foo:'aaa'&#125;;fos // undefined 可以看到上面的代码，赋值只与属性名有关，与顺序无关。如果属性名对不上，就会等于 undefined.而如果需要在变量名与属性名不一致情况下赋值，需要用下面的方法。 var &#123;foo:abs&#125;=&#123;foo:'sss'&#125;abs // 'sss' 同样也可以对有嵌套结构的对象解构 let obj = &#123; p:[ 'Hello', &#123;y:'World'&#125; ]&#125;;let &#123;p:[x,&#123;y&#125;]&#125; = obj;console.log(x,y);//Hello World 和数组一样，对象的解构也可以指定默认值，只要对要赋值对象相对应的对象属性严格等于 undefined，默认值就会成立。 var &#123;a =3&#125; = &#123;&#125;;a //3var &#123;b=4,y&#125; = &#123;y:4&#125;;b,y //4,4 对象的解构赋值给我们提供了较大的方便。 var obj = &#123; method1: function()&#123;&#125;, method2: function()&#123;&#125;&#125;var &#123;method1,method2&#125; = obj;//以前的写法var method1 = obj.method1;var method2 = obj.method2; 字符串的解构赋值字符串同样可以进行解构，在进行解构的时候，字符串会被转换成类数组对象。 let [f,g,h] = 'length';console.log(f,g,h);//l,e,nlet &#123;length:len&#125;='length';console.log(len);//6 函数参数的解构赋值函数参数是一个类数组对象，同样可以解构赋值 function a([x,y])&#123; return x + y;&#125;add([1,2]) //3 也同样可以设置默认值 function move(&#123;x=0,y=0&#125;=&#123;&#125;)&#123; "use strict"; console.log([x,y]);&#125;move(&#123;x:3,y:4&#125;); //[3,4]move(&#123;x:3&#125;); //[3,0]move(&#123;&#125;); //[0,0]move(); //[0,0]function remove(&#123;x,y&#125;=&#123;x:0,y:0&#125;)&#123; "use strict"; console.log(x,y);&#125;remove(&#123;x:1,y:2&#125;); //1,2remove(&#123;x,y&#125;); //Hello Worldremove(&#123;&#125;); //undefined undefinedremove(); // 0 0 函数参数的解构方法会根据参数类型来自动选择，数组就按照数组解构，对象就按照对象解构。 function fc([x,y,z])&#123; "use strict"; console.log(x,y,z);&#125;fc([1,2,3]); //1,2,3function nf(&#123;x,y,z&#125;)&#123; "use strict"; console.log(x,y,z);&#125;nf(&#123;y:1,z:2,x:3&#125;); //3,1,2 用途提取JSON数据var jsonDate = &#123; id: 42, status: "notOK", data: [12, 32]&#125;;let &#123;id,status,data&#125; = jsonDate;console.log(id, status, data); //42 'notOK' [12,32] ###遍历Map结构var map = new Map();map.set('first', 'HELLO');map.set('second', 'WORLD');for (let [key,value] of map) &#123; console.log(key + ' is ' + value);&#125;// first is HELLO// second is WORLDfor (let key of map) &#123; console.log(key);&#125;//['first','HELLO']//[ 'second', 'WORLD' ] 版权文章中所有代码皆来自或演变自： 阮一峰-ECMAScript 6 入门,本文同样遵循署名-非商用许可证.]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[被终止的项目]]></title>
    <url>%2F2015%2F08%2F16%2Fproject-termination%2F</url>
    <content type="text"><![CDATA[在五月份公司接到一个客户的手机钱包项目，这个项目得到了公司很大的重视，因为这是公司手机端继其它俩个主要项目后开辟的一个新的产品线。老大给了我机会，让我全权负责这个项目的前端部分。 当时我的内心是很兴奋的，不敢怠慢，认认真真的把项目做了出来。开发过程中遇到了很多以前没有遇到过的问题，但也都被我一一克服了，很有成就感。项目定格在1.2版本后，就交给了后台开发，然后自己就一直再期待这个项目的上线。 大概在上个月下旬后台开发完毕，然后就上了测试环境进行测试。上周二测试妹妹过来找我，说页面在低版本安卓上出现了一些兼容性问题，给我提了几个 issue 让我改。兼容性问题，在所难免嘛。然后我就哼哧哼哧去改 issue 了，费了好大劲改好了。提交代码后，我去通知后台。 然后就接到一个令人蛋疼的消息：项目被砍掉了。 这真是太突然了，前一秒我还在埋头改 bug ，下一秒就得知项目就被砍掉了，挂了。这意味我的工作也都付诸东流了，这感觉真是很不好。就好像大家商量好周末要在你家聚餐，为此你准备了很丰盛的饭菜，结果突然聚餐取消了…… 而项目被砍的原因竟然是因为前段时间，证监会发布的一条新规定。 我该说点什么好呢]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>项目终止</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 异步编程]]></title>
    <url>%2F2015%2F07%2F04%2Fasynchronous-javascript-ajax%2F</url>
    <content type="text"><![CDATA[工作中需要实现一个功能，简化一下大概是这么一个逻辑。 bills.getData = function (monthNow) { //DONE Get data of monthNow. //url = 通过 monthNow 来决定 url 地址 var url = &quot;api/data.json&quot;; //noinspection JSUnusedGlobalSymbols $.ajax({ url: url, dataType: &quot;json&quot;, type: &quot;GET&quot;, success: function (d) { Data = d; }, error: function (d) { window.console.log(&quot;error&quot;); } }); return Data }; data = bills.getData(monthNow); 结果测试的时候发现完全不对。调试了一下发现，当 bills.getData 执行完毕将 Data return 出去并且跟着的赋值语句也执行完毕后，才触发了 ajax 中 success 事件。这样明显是错误的，分析一下原因：由于 ajax 请求是异步的，所以实际的情况是， bills.getDate() 里的 success 还没有执行完毕， Data 就已经已经 return 了。导致最后的赋值语句其实是错误的，它并没有被赋值为 ajax 请求成功结果，这没有达到我们的预期。所以这里需要对代码结构进行改变，我们需要在确认 ajax 请求完毕成功后，再执行赋值语句。这里有两种方法了达到效果，分别是 callback 和 promise 。为了方便，我这里选择了 callback 的形式。那么代码就是下面这个样子 // Data 是全局变量 bills.getData = function (monthNow, callback) { //DONE Get data of monthNow. //url = 通过 monthNow 来决定 url 地址 var url = &quot;api/data.json&quot;; //noinspection JSUnusedGlobalSymbols $.ajax({ url: url, dataType: &quot;json&quot;, type: &quot;GET&quot;, success: function (d) { Data = d; if (typeof callback === &apos;function&apos;) { callback(); } }, error: function (d) { window.console.log(&quot;error&quot;); } }); }; bills.getData(monthNow,doSomeThing); function doSomeThing(){ //doSomeThing with Data } 这样就可以保证 callback 中的 data 是 ajax 请求成功后的结果。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>async</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[learnyounode]]></title>
    <url>%2F2015%2F06%2F11%2Flearnyounode%2F</url>
    <content type="text"><![CDATA[Learn You The Node.js For Much Win!花了几天业余时间做完这个 Node.js 入门的题目，梳理一下知识点。 HELLO WORLD 编写一个程序，在终端（标准输出 stdout）打印出 “HELLO WORLD”。 学习一门语言的最好方法就是先写一个 Hello Wolrd 程序。这道题很简单，每个人都会。 console.log(&quot;HELLO WORLD&quot;) BABY STEPS 编写一个简单的程序，使其能接收一个或者多个命令行参数，并且在终端（标准输出 stdout）中打印出这些参数的总和。 接受的参数可以通过 process.argv 来访问，它是一个数组。前两位是固定的，第一位是 node ，第二位是文件的路径，后面就是程序输入的内容的了。 首先，请先编写一个包含如下带简易代码的程序来熟悉一下： console.log(process.argv) 通过执行命令 node program.js 并在后面多加几个参数，来运行我们的程序，比如： $ node program.js 1 2 3 这样，你就会得到这样一个数组： [ ‘node’, ‘/path/to/your/program.js’, ‘1’, ‘2’, ‘3’ ] 那么有了这些知识后，程序写起来也就很简单了。 var result = 0; process.argv.forEach(function(el,index){ if (index&gt;1) { result += +el; } }); console.log(result); MY FIRST I/O! 编写一个程序，执行一个同步的文件系统操作，读取一个文件，并且在终端（标准输出 stdout）打印出这个文件中的内容的行数。类似于执行 cat file | wc -l 这个命令。 所要读取的文件的完整路径会在命令行第一个参数提供。 首先要对一个文件进行操作，需要用到 fs 这个模块，我们可以用 var fs = require(&#39;fs&#39;); 来引入。然后可以通过 fs 这个变量来访问整个 fs 模块了。 在 fs 中，所有的同步（或者阻塞）的操作文件系统的方法名都会以 ‘Sync’ 结尾。要读取一个文件，你将需要使用 fs.readFileSync(‘/path/to/file’) 方法。这个方法会返回一个包含文件完整内容的 Buffer 对象。Buffer 对象是 Node 用来高效处理数据的方式，无论该数据是 ascii 还是二进制文件，或者其他的格式。Buffer 可以很容易地通过调用 toString() 方法转换为字符串。如：var str = buf.toString()。 这样我们要做的就是先引入 fs 模块，然后读取输入的数据。我们的目的是计算行数，可以知道，每行末尾其实都是有一个 \n 的，我们只要计算 \n 的个数就可以了。 var fs = require(&apos;fs&apos;); var data = fs.readFileSync(process.argv[2]); var str = data.toString(); var array = str.split(&apos;\n&apos;); console.log(array.length-1); MY FIRST ASYNC I/O! 编写一个程序，执行一个异步的对文件系统的操作：读取一个文件，并且在终端（标准输出 stdout）打印出这个文件中的内容的行数。类似于执行 cat file | wc -l 这个命令。 所要读取的文件的完整路径会在命令行第一个参数提供。 这道题上一道几乎一样，只是变成了异步的读取。这是就需要用到 fs.readFile() ，而不是 fs.readFileSync() 。 记住，我们习惯中的 Node.js 回调函数都有像如下所示的特征： function callback (err, data) { / … / } 所以，你可以通过检查第一个参数的真假值来判断是否有错误发生。如果没有错误发生，你会在第二个参数中获取到一个 Buffer 对象。和 readFileSync() 一样，你可以传入 ‘utf8‘ 作为它的第二个参数，然后把回调函数作为第三个参数，这样，你得到的将会是一个字符串，而不是 Buffer。 var fs = require(&apos;fs&apos;); var data = fs.readFile(process.argv[2],function(err,data){ if(err){ throw console.error(err); } var list = data.toString().split(&apos;\n&apos;); console.log(list.length-1); }); FILTERED LS 编写一个程序来打印出指定目录下的文件列表，并且以特定的文件名扩展名来过滤这个列表。这次会有两个参数提供给你，第一个是所给的文件目录路径（如：path/to/dir），第二个参数则是需要过滤出来的文件的扩展名。 举个例子：如果第二个参数是 txt，那么你需要过滤出那些扩展名为 .txt的文件。 注意，第二个参数将不会带有开头的 .。 你需要在终端中打印出这个被过滤出来的列表，每一行一个文件。另外，你必须使用异步的 I/O 操作。 这个也很简单，把文件名通过 . 来分成两个部分，后面的就是后戳名了。 var fs = require(&apos;fs&apos;); var path = process.argv[2]; var extname = process.argv[3]; fs.readdir(path,function(err,list){ if(err){ throw err; }else{ list.forEach(function(file){ if(file.split(&apos;.&apos;)[1] === extname){ console.log(file); } }); } }); MAKE IT MODULAR 这个问题和前面一个一样，但是这次会介绍模块的概念。你将需要创建两个文件来解决这个问题。 编写一个程序来打印出所给文件目录的所含文件的列表，并且以特定的文件名后缀来过滤这个列表。这次将会提供两个参数，第一个参数是要列举的目录，第二个参数是要过滤的文件扩展名。你需要在终端中打印出过滤出来的文件列表（一个文件一行）。此外，你必须使用异步 I/O。 你得编写一个模块 文件去做大部分的事情。这个模块必须导出（export）一个函数，这个函数将接收三个参数：目录名、文件扩展名、回调函数，并按此顺序传递。文件扩展名必须和传递给你的程序的扩展名字符串一模一样。也就是说，请不要把它转成正则表达式或者加上 “.” 前缀或者做其他的处理，而是直接传到你的模块中去，在模块中，你可以做一些处理来使你的过滤器能正常工作。 这个回调函数必须以 Node 编程中惯用的约定形式（err, data）去调用。这个约定指明了，除非发生了错误，否则所传进去给回调函数的第一个参数将会是 null，第二个参数才会是你的数据。在本题中，这个数据将会是你过滤出来的文件列表，并且是以数组的形式。如果你接收到了一个错误，如：来自 fs.readdir() 的错误，则必须将这个错误作为第一个，也是唯一的参数传递给回调函数，并执行回调函数。 你绝对不能直接在你的模块文件中把结果打印到终端中，你只能在你的原始程序文件中编写打印结果的代码。 当你的程序接收到一些错误的时候，请简单的捕获它们，并且在终端中打印出相关的信息 这里有四则规定，你的模块必须遵守： 导出一个函数，这个函数能准确接收上述的参数。 当有错误发生，或者有数据的时候，准确调用回调函数。 不要改变其他的任何东西，比如全局变量或者 stdout。 处理所有可能发生的错误，并把它们传递给回调函数。 遵循一些约定的好处是，你的模块可以被任何其他也遵守这些约定的人所使用。因此，这里你新建的模块可以被其他 learnyounode 的学习者使用，或者拿去验证，都会工作得很好。 首先是我们的模块文件，可以从上一题改造过来,并命名为 ‘program-6-require.js’ 。它要做的事情就是返回一个过滤后的文件名的数组。 var fs = require(&apos;fs&apos;); module.exports = function(path, extname, callback) { fs.readdir(path, function(err, list) { if (err) { return callback(err, null); } else { list = list.filter(function(file) { return file.split(&apos;.&apos;)[1] === extname; }); } callback(null, list); }); }; 然后在程序文件中调用这个模块，将模块中返回数组的内容打印出来就可以了。 var mymodule = require(&apos;./program-6-require&apos;); var path = process.argv[2]; var extname = process.argv[3]; mymodule(path,extname,function(err,files){ if(err){ return console.log(err); } files.forEach(function(file){ console.log(file); }); }); HTTP CLIENT 编写一个程序来发起一个 HTTP GET 请求，所请求的 URL 为命令行参数的第一个。然后将 每一个 “data” 事件所得的数据，以字符串形式在终端（标准输出 stdout）的新的一行打印出来。 完成这个练习，你需要使用 Node.js 核心模块之一：http。 http.get() 方法是用来发起简单的 GET 请求的快捷方式，使用这个方法可以一定程度简化 你的程序。http.get() 的第一个参数是你想要 GET 的 URL，第二个参数则是回调函数。 与其他的回调函数不同，这个回调函数有如下这些特征： function callback (response) { / … / } response 对象是一个 Node 的 Stream 类型的对象，你可以将 Node Stream 当做一个会触 发一些事件的对象，其中我们通常所需要关心的事件有三个： “data”，”error” 以及 “end “。你可以像这样来监听一个事件： response.on(“data”, function (data) { / … / }) ‘data’ 事件会在每个数据块到达并已经可以对其进行一些处理的时候被触发。数据块的大 小将取决于数据源。 你从 http.get() 所获得的 response 对象/Stream 还有一个 setEncoding() 的方法。如 果你调用这个方法，并为其指定参数为 utf8，那么 data 事件中会传递字符串，而不是标 准的 Node Buffer 对象，这样，你也不用再手动将 Buffer 对象转换成字符串了。 有了上面那些提示，实现起来还是很容易的。 var http = require(&apos;http&apos;); http.get(process.argv[2],function(response){ response.setEncoding(&apos;utf8&apos;); response.on(&quot;data&quot;,function(data){ console.log(data); }); response.on(&quot;error&quot;,function(err){ throw err; }); response.on(&quot;end&quot;,function(){ // console.log(date); }); }); HTTP COLLECT 编写一个程序，发起一个 HTTP GET 请求，请求的 URL 为所提供给你的命令行参数的第一个。收集所有服务器所返回的数据（不仅仅包括 “data” 事件）然后在终端（标准输出 stdout）用两行打印出来。 你所打印的内容，第一行应该是一个整数，用来表示你所收到的字符串内容长度，第二行则是服务器返回给你的完整的字符串结果。 我们要做的就是先把所有的数据都收集起来，然后在请求结束后把他们凭借起来就可以了。 var http = require(&apos;http&apos;); var url = process.argv[2]; http.get(url,function(response){ var list = []; // response.setEncoding(&apos;utf8&apos;); response.on(&quot;data&quot;,function(data){ list.push(data.toString()); }); response.on(&quot;error&quot;,function(err){ throw err; }); response.on(&quot;end&quot;,function(){ var str = &apos;&apos;; list.forEach(function(s){ str += s; }); console.log(str.length); console.log(str); }); }); JUGGLING ASYNC 这次的问题和之前的问题（HTTP 收集器）很像，也是需要使用到 http.get() 方法。然而，这一次，将有三个 URL 作为前三个命令行参数提供给你。 你需要收集每一个 URL 所返回的完整内容，然后将它们在终端（标准输出 stdout）打印出来。这次你不需要打印出这些内容的长度，仅仅是内容本身即可（字符串形式）；每个 URL 对应的内容为一行。重点是你必须按照这些 URL 在参数列表中的顺序将相应的内容排列打印出来才算完成。 这里有几个问题： 1 要收集每个 url 返回的完整内容 2 判断是否所有请求完成 3 按 url 顺序打印出所获得内容 第一个问题这个很简单，和前面的题一样。 第二个问题要判断所有请求是否都完成了，我们需要一个列表来存放发的状态，如果它的请求完成了，就给他标注出来。 第三个问题要按照 url 的顺序打印出内容，那么我们在保存数据的时候就要记录下它的 index ，最后按照这个 index 打印就可以了。 var http = require(&apos;http&apos;); var urls = process.argv.slice(2,process.argv.length); var datas = []; var end = []; var is = false; urls.forEach(function(url,index){ http.get(url,function(response){ var list = []; response.setEncoding(&apos;utf8&apos;); response.on(&quot;data&quot;,function(data){ list.push(data); }); response.on(&quot;error&quot;,function(err){ throw err; }); response.on(&quot;end&quot;,function(){ var str = &apos;&apos;; list.forEach(function(s){ str += s; }); datas[index] = str; end.push(true); if (isEnd()) { for (var i = 0; i &lt; datas.length; i++) { console.log(datas[i]); } } }); }); }); function isEnd(){ if (end.length === urls.length) { end.forEach(function(blo){ if(blo){ is = true; }else{ is = false; } }); } return is; } 这道题，我的方法略显繁琐。下面附上官方答案，以并参考。 var http = require(&apos;http&apos;) var bl = require(&apos;bl&apos;) var results = [] var count = 0 function printResults () { for (var i = 0; i &lt; 3; i++) console.log(results[i]) } function httpGet (index) { http.get(process.argv[2 + index], function (response) { response.pipe(bl(function (err, data) { if (err) return console.error(err) results[index] = data.toString() count++ if (count == 3) printResults() })) }) } for (var i = 0; i &lt; 3; i++) httpGet(i) TIME SERVER 编写一个 TCP 时间服务器 你的服务器应当监听一个端口，以获取一些 TCP 连接，这个端口会经由第一个命令行参数传递给你的程序。针对每一个 TCP 连接，你都必须写入当前的日期和24小时制的时间，如下格式： “YYYY-MM-DD hh:mm” 然后紧接着是一个换行符。 月份、日、小时和分钟必须用零填充成为固定的两位数： “2013-07-06 17:42” 官方的提示： 这次练习中，我们将会创建一个 TCP 服务器。这里将不会涉及到任何 HTTP 的事情，因此我们只需使用 net 这个 Node 核心模块就可以了。它包含了所有的基础网络功能。 net 模块拥有一个名叫 net.createServer() 的方法，它会接收一个回调函数。和 Node 中其他的回调函数不同，createServer() 所用的回调函数将会被调用多次。你的服务器每收到一个 TCP 连接，都会调用一次这个回调函数。这个回调函数有如下特征： function callback (socket) { / … / } net.createServer() 也会返回一个 TCP 服务器的实例，你必须调用 server.listen(portNumber) 来让你的服务器开始监听一个特定的端口。 一个典型的 Node TCP 服务器将会如下所示： var net = require(‘net’) var server = net.createServer(function (socket) { // socket 处理逻辑 }) server.listen(8000) 记住，请一定监听由第一个命令行参数指定的端口。 socket 对象包含了很多关于各个连接的信息（meta-data），但是它也同时是一个 Node 双工流（duplex Stream），所以，它即可以读，也可以写。对这个练习来说，我们只需要对socket 写数据和关闭它就可以了。 使用 socket.write(data) 可以写数据到 socket 中，用 socket.end() 可以关闭一个 socket。另外， .end() 方法也可以接收一个数据对象作为参数，因此，你可简单地使用 socket.end(data) 来完成写数据和关闭两个操作。 有了官方提示，一切都很简单了。 var net = require(&apos;net&apos;); var port = process.argv[2]; var getTime = function(){ var date = new Date(), year = date.getFullYear(), month = formate(date.getMonth()+1), day = formate(date.getDate()), hour = formate(date.getHours()), minute = formate(date.getMinutes()); var time = year + &quot;-&quot;+month+&quot;-&quot;+day+&quot; &quot;+hour+&quot;:&quot;+minute; function formate(time){ return (time.toString().length&gt;1?&apos;&apos;:&apos;0&apos;)+time; } return time; }; var server = net.createServer(function(socket){ socket.write(getTime()+&apos;\n&apos;); socket.end(); }); server.listen(port); HTTP FILE SERVER 编写一个 HTTP 文件 服务器，它用于将每次所请求的文件返回给客户端。 你的服务器需要监听所提供给你的第一个命令行参数所制定的端口。 同时，第二个会提供给你的程序的参数则是所需要响应的文本文件的位置。在这一题中，你必须使用 fs.createReadStream() 方法以 stream 的形式作出请求相应。 这里需要用到 http 的 http.createServer() 方法，和前面的 net 类似，不同的是它使用 HTTP 协议进行通讯。还有下面这个fs的方法。 fs 这个核心模块也含有一些用来处理文件的流式（stream） API。你可以使用 fs.createReadStream() 方法来为命令行参数指定的文件创建一个 stream。这个方法会返回一个 stream 对象，该对象可以使用类似 src.pipe(dst) 的语法把数据从 src流传输(pipe) 到 dst流中。通过这种形式，你可以轻松地把一个文件系统的 stream 和一个 HTTP 响应的 stream 连接起来。 var fs = require(&apos;fs&apos;), http = require(&apos;http&apos;); var port = process.argv[2], path = process.argv[3]; var fileStream = fs.createReadStream(path); var server = http.createServer(function(req,res){ res.writeHead(200,{&apos;content-type&apos;:&apos;text/plain&apos;}); fileStream.pipe(res); }); server.listen(port); HTTP UPPERCASERER 编写一个 HTTP 服务器，它只接受 POST 形式的请求，并且将 POST 请求主体（body）所带的字符转换成大写形式，然后返回给客户端。 你的服务器需要监听由第一个命令行参数所指定的端口。 这里只要知道 toUpperCase() 这个方法就可以了。 var http = require(&apos;http&apos;); var port = process.argv[2]; var server = http.createServer(function(req,res){ var post = &apos;&apos;; // console.log(req.method); if (req.method !== &quot;POST&quot;) { return res.end(&quot;The method must be POST&quot;); } res.writeHead(200,{&apos;content-type&apos;:&apos;text/plain&apos;}); req.on(&apos;data&apos;,function(data){ post += data; }); req.on(&apos;end&apos;,function(){ res.end(post.toString().toUpperCase()); }); }); server.listen(port); HTTP JSON API SERVER 编写一个 HTTP 服务器，每当接收到一个路径为 ‘/api/parsetime’ 的 GET 请求的时候，响应一些 JSON 数据。我们期望请求会包含一个查询参数（query string），key 是 “iso”，值是 ISO 格式的时间。 如: /api/parsetime?iso=2013-08-10T12:10:15.474Z 所响应的 JSON 应该只包含三个属性：’hour’，’minute’ 和 ‘second’。例如： { “hour”: 14, “minute”: 23, “second”: 15 } 然后增再加一个接口，路径为 ‘/api/unixtime’，它可以接收相同的查询参数（query string），但是它的返回会包含一个属性：’unixtime’，相应值是一个 UNIX 时间戳。例如: { “unixtime”: 1376136615474 } 你的服务器需要监听第一个命令行参数所指定的端口。 首先我们要有俩个方法来分别将时间转换为相应格式的 JSON 文件。然后我们需要用到 url 这个模块，可以用它来解析请求。 var http = require(&apos;http&apos;), url = require(&apos;url&apos;); var port = process.argv[2]; var parseTime = function(time){ return{ &quot;hour&quot;: time.getHours(), &quot;minute&quot;: time.getMinutes(), &quot;second&quot;: time.getSeconds() }; }; var getUnixTime = function(time){ return{ &quot;unixtime&quot;: time.getTime() }; }; var server = http.createServer(function(req,res){ // console.log(url.parse(req.url,true)); var queryString = url.parse(req.url,true).query, time = new Date(queryString.iso), pathname = url.parse(req.url,true).pathname, result; if (req.method != &quot;GET&quot;) { res.end(&apos;Method must be GET&apos;); } if (pathname === &apos;/api/parsetime&apos;) { result = parseTime(time); }else if(pathname === &apos;/api/unixtime&apos;){ result = getUnixTime(time); } if (result) { res.writeHead(200,{&apos;Content-Type&apos;:&apos;application/json&apos;}); res.end(JSON.stringify(result)); }else{ res.writeHead(404); res.end(&apos;404,not found&apos;); } }); server.listen(Number(port)); 最后因为我也是第一次接触，所以对代码有问题的。欢迎与我讨论，互相学习。 以上所有的代码都整合放在这里了;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3 实现人物赛跑动画]]></title>
    <url>%2F2015%2F05%2F20%2Fincome-plan-animation%2F</url>
    <content type="text"><![CDATA[最近公司的一个手机项目里面有一个动画，就是一个人在跑道上跑步。为了能在手机端发挥更好的性能，选择了全部用CSS3来做一个动画。因为是第一次做，碰到了很多问题，记录下来。效果图是这样的： 分析拿到效果图先分析一下，可以看到动画分为一下四个部分： 跑动的小人 运动的路 左边的路牌 收益的牌子 小人小人很好解决，通过使用一张跑步的分解图片，然后通过逐帧的变动它的`background-position’就可以了，真是简单啊。 .person { width: 62px; height: 110px; background: url(../imgs/plan/person1.png) -7px 0 no-repeat; background-size: auto 110px; animation: run .5s infinite; //要注意加上各种浏览器的前戳，尤其是-webkit-，在这我就不加了 position: absolute; top: 40%; left: 110*.84px; } @keyframes run { 0% { background-position: -7px 0 } 25% { background-position: -79px 0 } 50% { background-position: -150px 0 } 75% { background-position: -216px 0 } 100% { background-position: -283px 0 } } 然而小人就成这样了了，简直惨不忍睹，分析原因，原来是因为keyframes默认是有过渡的。也就是说，我的background-position是从-7线性的渐变到-283，这当然不是我想要的结果。想到这样该是动画时间函数的问题，就去查animation-timing-funciton的取值： linear：线性过渡。等同于贝塞尔曲线(0.0, 0.0, 1.0, 1.0)ease：平滑过渡。等同于贝塞尔曲线(0.25, 0.1, 0.25, 1.0)ease-in：由慢到快。等同于贝塞尔曲线(0.42, 0, 1.0, 1.0)ease-out：由快到慢。等同于贝塞尔曲线(0, 0, 0.58, 1.0)ease-in-out：由慢到快再到慢。等同于贝塞尔曲线(0.42, 0, 0.58, 1.0)step-start：等同于 steps(1, start)step-end：等同于 steps(1, end)steps([, [ start | end ] ]?)：接受两个参数的步进函数。第一个参数必须为正整数，指定函数的步数。第二个参数取值可以是start或end，指定每一步的值发生变化的时间点。第二个参数是可选的，默认值为end。cubic-bezier(, , , )：特定的贝塞尔曲线类型，4个数值需在[0, 1]区间内 step这个属性就是我们想要的，让他从一个状态直接跳到另个状态，而不是过渡过去。给上面的.person再加上这条属性就可以了 animation-timing-function: step-start; 这样小人跑步就解决了。 路路一开始还想不到好的方法，本来想的是直接截一大段，弄两张图，然后让两张图交替的出现。但是这样图片会很大，即耗费网络资源又感觉方法很笨。看着跑道分析了一下，想到了一个好方法。通过截取跑道的最小组成部分，纵向平铺，然后让他的background-position每次挪此图高度的一半就可以了。这样跑道也解决了。 左边的路牌这个很简单，给她设置绝对定位，然后更改top值就可以了。要注意的是，最后一块牌子要在到中间后停在那，加上这个属性就可以了。 animation-fill-mode: forwards; animation-fill-mode 属性规定动画在播放之前或之后，其动画效果是否可见。取值none： 不改变默认行为。forwards： 当动画完成后，保持最后一个属性值（在最后一个关键帧中定义）。backwards： 在 animation-delay 所指定的一段时间内，在动画显示之前，应用开始属性值（在第一个关键帧中定义）。both： 向前和向后填充模式都被应用。 收益的牌子和左边的路标一样，很简单。就是出现和消失而已。 组合将动画的四个部分解决后，剩下的就是将他们组合起来了。上图是第一块路标从屏幕出现到消失过程的流程图，其他两块路标的过程只需要将动画延迟相应的时间段就可以了。这中间还有一个问题，就是让小人和路定点停下来。这个用CSS3貌似实现不了，于是退而求其次，选择了用js来控制。通过给它的设置属性webkit-animation-play-state: paused和webkit-animation-play-state: running就可让它停下来后继续动了。最后要在动画完成后，弹出一个弹窗。这个通过检测animationEnd事件来实现,下面是实现方法。 /* From Modernizr */ function whichAnimationEvent(){ var t; var el = document.createElement(&apos;fakeelement&apos;); var animations = { &apos;animation&apos;:&apos;animationend&apos;, &apos;OAnimation&apos;:&apos;oAnimationEnd&apos;, &apos;MozAnimation&apos;:&apos;animationend&apos;, &apos;WebkitAnimation&apos;:&apos;webkitAnimationEnd&apos; } for(t in animations){ if( el.style[t] !== undefined ){ return animations[t]; } } } /* Listen for a transition! */ var transitionEvent = whichAnimationEvent(); whichAnimationEvent &amp;&amp; e.addEventListener(whichAnimationEvent, function() { //doSomething }); /* The &quot;whichTransitionEvent&quot; can be swapped for &quot;animation&quot; instead of &quot;transition&quot; texts, as can the usage :) */ 效果这是最后的完成效果。点这儿看动画]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
        <tag>奔跑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js函数表达式和函数声明的区别]]></title>
    <url>%2F2015%2F02%2F08%2FjsFunction-expression-declaration%2F</url>
    <content type="text"><![CDATA[JavaScript中的两种函数定义方式： 函数表达式：var foo = function(){ conlose.log(&apos;Message&apos;); }; 函数声明：function foo(){ console.log(&apos;Message&apos;); }; 两种方法都可以定义一个相同的函数，但是却有一些区别： 函数表达式中：var foo和一般的var定义的变量一样被提到了函数或脚本顶部，但是函数体却还是在原来的地方。所以必须在函数体后调用函数。 var foo = function(){ console.log(&apos;Message&apos;); }; foo() // 输出结果为&apos;Message&apos; foo(); var foo = function(){ console.log(&apos;Message&apos;); }; // 会报错TypeError: Property &apos;test&apos; of object #&lt;Object&gt; is not a function 上面的第二段代码其实和下面的是一样，所以会报错 var foo; foo(); var foo = function(){ console.log(&apos;Message&apos;); }; 函数声明中：foo()函数的整个函数块都被提到了整个函数或脚本的顶部，在整个函数或脚本中都是可见的。也就是说可以在函数定义之前调用函数。 foo() function foo(){ console.log(&apos;Message&apos;) } //输出结果为&apos;Message&apos; 以后在实际使用中，要特别注意两者的区别。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery插件-changeBg]]></title>
    <url>%2F2015%2F02%2F07%2FjQuery-plugin-changeBg%2F</url>
    <content type="text"><![CDATA[把上篇博客中写的jQuery题改进了一下，做成了一个新插件ChangeBg。可以给某标签下的所有奇数行的子元素(注意：是子元素，而非后代元素)设置背景颜色，同时给所有子元素添加鼠标移入移出时更改背景和字体颜色的事件。 调用方法：$(&#39;select&#39;).ChangeBg(bgCol, chBgCl, chCol);或直接$(&#39;select&#39;).ChangeBg();函数有三个参数，分别为： bgCol 奇数行要设置的背景颜色,默认为&#39;#EEE&#39; chBgCl 鼠标移入时背景颜色，默认为&#39;#0066CC&#39; chCol 鼠标移入时的字体颜色，默认为&#39;#FFF&#39; 下载请点我]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试题(1)]]></title>
    <url>%2F2015%2F02%2F06%2FF2E-interview-question(1)%2F</url>
    <content type="text"><![CDATA[在群里有人分享了一套试题，拿来练练手。 1、请用HTML5标准完成以下布局 HTML: &lt;header&gt;HEADER&lt;/header&gt; &lt;nav&gt;NAV&lt;/nav&gt; &lt;aside&gt;ASIDE&lt;/aside&gt; &lt;section&gt;SECTION&lt;/section&gt; &lt;footer&gt;FOOTER&lt;/footer&gt; CSS: body{ color: white; font-size: 14px; text-align: center; } header{ background-color: black; } nav{ background-color: gray; } aside{ width: 30%; height: 200px; float: left; background-color: red; } section{ width: 70%; height: 200px; margin-left: 30%; background-color: blue; } footer{ background-color: orange; } 2、相应框架布局css编写，实现以下两种情况即可。 HTML: &lt;div class=&quot;box1&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;box2&quot;&gt;2&lt;/div&gt; CSS: div{width: 600px;height: 50px} .box1{background-color: red;} .box2{background-color: blue;} @media screen and (min-width:1024px ) { div{ float: left; } } @media screen and (max-width: 1024px) { div{ float: none; } } 3、实现一行数据中同时含有图片和文字垂直居中（不能使用table，注意兼容性）HTML: &lt;div class=&quot;box1&quot;&gt; &lt;div class=&quot;wrap1&quot;&gt; &lt;p&gt;我要居中&lt;/p&gt; &lt;img src=&quot;http://images.cnitblog.com/blog/607355/201408/100022249123500.png&quot; alt=&quot;liveReload&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;box2&quot;&gt; &lt;div class=&quot;wrap2&quot;&gt; &lt;p&gt;我也要居中&lt;/p&gt; &lt;img src=&quot;http://images.cnitblog.com/blog/607355/201408/100022249123500.png&quot; alt=&quot;liveReload&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;box3&quot;&gt; &lt;div class=&quot;wrap3&quot;&gt; &lt;p&gt;我也要居中&lt;/p&gt; &lt;img src=&quot;http://images.cnitblog.com/blog/607355/201408/100022249123500.png&quot; alt=&quot;liveReload&quot;&gt; &lt;/div&gt; &lt;/div&gt; CSS: .box1,.box2,.box3,.box4{ width: 33%; height: 300px; float: left; border: 1px solid #00FFFF } /*方法1，用display:table*/ .box1{ display: table; } .wrap1{ display: table-cell; vertical-align: middle; text-align: center; } /*方法2，用绝对定位法*/ .box2{ position: relative; } .wrap2{ width: 150px; height: 150px; border: 1px solid black; position: absolute; left: 0; right: 0; top: 0; bottom: 0; margin: auto; } /*方法3，用translate方法*/ .box3{ position: relative; } .wrap3{ position: absolute; top: 50%; left: 50%; -webkit-transform: translate(-50%,-50%); -moz-transform: translate(-50%,-50%); -ms-transform: translate(-50%,-50%); -o-transform: translate(-50%,-50%); transform: translate(-50%,-50%); } 4、请描述一下cookie，sessionStorage和localStorage的异同点。共同点：都是保存在浏览器端的数据。区别：cookie 数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。而sessionStorage和 localStorage不会自动把数据发给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下。存储大小限制也不同，cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。数据有效期不同， sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持； localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据； cookie在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。作用域不同， sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面； localStorage 在所有同源窗口中都是共享的；cookie也是在 所有同源窗口中都是共享的。 5、请指出以下代码的性能问题，并进行优化。var str=&quot; 123&quot;; str +=&quot; 456 ,&quot;; str +=&quot; 789 ,&quot;; str +=&quot; 012&quot; ; 不知如何解答，-_- 6、编写一个用户类，需求如下： 属性：id、name、password、age 方法：获取用户脚本信息，返回json字符串GetUserInfo 方法：验证用户登录信息，ajax实现，返回结果提示登录成功或失败即可CheckLogin 创建一个用户类的一个对象，并重写GetUserInfo方法 代码： var Person = { id: &apos;ID&apos;, name: &apos;Name&apos;, password: &apos;PassWord&apos;, $age: null, get age() { if (this.$age == undefined) { return new Date().getFullYear() - 1993; } else { return this.$age; } }, set age(val) { if (!isNaN(+val) &amp;&amp; +val &gt; 0 &amp;&amp; +val &lt; 120) { this.$age = +val; } else { throw new Error(val + &apos;不是正确的年龄&apos;); } }, GetUserInfo: function () { return { id: this.id, name: this.name, password: this.password, age: this.age }; }, CheckLogin: function (data,success,error) { //data为用户数据，success和error分别是成功和失败的回调函数 var xmlhttp; if (window.XMLHttpRequest) { xmlhttp = new XMLHttpRequest(); } else { //for IE6 xmlhttp = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); } xmlhttp.onreadystatechange = function () { if (xmlhttp.readyState == 4 &amp;&amp; xmlhttp.status == 200) { if (xmlHttp.responseText === &quot;OK&quot;) { if (typeof success === &apos;function&apos;) { success(); console.log(&apos;登陆成功&apos;); } } else { error(); console.log(&apos;登录错误&apos;) } } }; xmlhttp.open(&quot;POST&quot;, &quot;Login&quot;, true); xmlhttp.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;); xmlhttp.send(data); }, }; var me = Object.create(Person); me.id = &apos;123&apos;; me.name = &apos;kisnows&apos;; me.password = &apos;kPassword&apos;; var myData = me.GetUserInfo(); console.log(myData); me.GetUserInfo = function () { console.log(&apos;Rewrite GetUserInfo&apos;); }; 7、jQuery插件开发，有一数据列表页面，需求如下： 奇数行无背景色 偶数行背景色#EEE 鼠标移入某行时背景色#0066CC，文字颜色变为白色，移出还原 假设是给ul下的li设置背景，代码如下： (function($) { $.fn.extend({ &quot;ChageBg&quot;: function() { var lis = $(this).find(&apos;li&apos;); var bfBg,bfCl; for (var i = lis.length - 1; i &gt;= 0; i--) { lis[i].index = i; if (i % 2 === 0) { $(lis[i]).css(&apos;backgroundColor&apos;, &apos;#EEE&apos;); // lis[i].style.backgroundColor = &apos;#EEE&apos;; } $(lis[i]).mouseover( function() { bfBg = $(this).css(&apos;backgroundColor&apos;); // console.log($(this),bfBg) bfCl = $(this).css(&apos;color&apos;); $(this).css({ backgroundColor: &apos;#0066CC&apos;, color: &apos;#FFF&apos; }); } ); $(lis[i]).mouseout( function(pro) { $(this).css({ backgroundColor: bfBg, color: bfCl }); } ); } } }); })(jQuery); 8、用HTML5播放一段视频或音频，并支持打点功能（从指定开始时间播放之制定结束时间，如一段视频长度为10秒，从第2s开始播放至第8s结束）HTML: &lt;video id=&quot;video1&quot; controls=&quot;controls&quot;&gt; &lt;source src=&quot;/example/html5/mov_bbb.mp4&quot; type=&quot;video/mp4&quot;&gt; &lt;source src=&quot;/example/html5/mov_bbb.ogg&quot; type=&quot;video/ogg&quot;&gt; Your browser does not support HTML5 video. &lt;/video&gt; 只知道如何引入带控制条的音视频，打点功能不了解。网上也没有找到。 希望知道的同学能够告诉我一下，谢谢了。 9、CSS3的transition与Animation动画结束后的结束回调函数是什么。此题答案来自网络http://blog.csdn.net/renfufei/article/details/19617745 ransitionend事件和animationend事件是标准浏览器的动画结束回调函数。基于webkit的浏览器仍然依赖于前缀,我们必须先确定事件的前缀,然后才能调用: /* From Modernizr */ function whichTransitionEvent(){ var t; var el = document.createElement(&apos;fakeelement&apos;); var transitions = { &apos;transition&apos;:&apos;transitionend&apos;, &apos;OTransition&apos;:&apos;oTransitionEnd&apos;, &apos;MozTransition&apos;:&apos;transitionend&apos;, &apos;WebkitTransition&apos;:&apos;webkitTransitionEnd&apos;, &apos;MsTransition&apos;:&apos;msTransitionEnd&apos; } for(t in transitions){ if( el.style[t] !== undefined ){ return transitions[t]; } } } /* 监听 transition! */ var transitionEvent = whichTransitionEvent(); transitionEvent &amp;&amp; e.addEventListener(transitionEvent, function() { console.log(&apos;Transition 完成! 原生JavaScript回调执行!&apos;); }); /* 在 &quot;whichTransitionEvent&quot; 中,可以将 &quot;transition&quot;文本替换为 &quot;animation&quot;,则处理的就是动画,此处代码省略...) */ 总结 第四题做之前理解没有那么深,只知道它们都是存在浏览器端的本地数据，且sessionStorage和localStorage为HTML5的新特性，sessionStorage为短期存储，localStorage为长期存储。 第六题中的CheckLogin方法不知具体如何实现。 第八题打点功能不了解。 第九题之前没听说过。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简易计算器]]></title>
    <url>%2F2015%2F02%2F04%2Fsimple-calculate%2F</url>
    <content type="text"><![CDATA[做简单的计算器，只提供最基本的运算，不过满足日常生活需求是够了。运行效果点这里]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速排序的实现]]></title>
    <url>%2F2015%2F01%2F29%2Fquick-sort%2F</url>
    <content type="text"><![CDATA[快速排序是一种经常用到的排序方法，它的时间复杂度为O(nlogn)。因为大多数情况下速度都比一般的排序方法快，用的比较多，自己就琢磨着实现了一下。 原理快速排序用到了分治法的原理：&emsp;&emsp;从数组中随机取出一个数字，将这个数组分为两个部分。将取出的数字作为基准数，小于基准数的放到它的左边，大于基准数的放到它的右边。这样基准数左边的都是比它小的，右边的都是比它大的。然后再对基准数的左边和右边重复前面的过程，直到每个部分的数组长度为1。最后再将这些分开的数组组合起来就成功了。步骤如下： 从数组中随机抽取一个数组作为基准数，将数组中的每个数字与基准数比较，小于基准数的放到基准数左边，大于基准数的放到基准数右边。 对上面结束后的左右两个部分重复步骤1。 当所有部分的长度为1时停止。 实现下面是自己熟悉的语言的实现(用第一个数作为基准数,并且采用递归的方法)： Python版本def quick_sort(lst,left,right): i = left; j = right if i &gt;= j: return lst k = lst[i] while i &lt; j: while i &lt; j and lst[j] &gt;= k: #lst[j]&lt;=k时，循环结束，并将其值赋给lst[i] j -= 1 lst[i] = lst[j] while i &lt; j and lst[i] &lt;= k: #lst[i]&gt;=k时，循环结束，并将其值赋给lst[j] i += 1 lst[j] = lst[i] lst[i] = k #当i&gt;=j时，将k的值赋给lst[i] quick_sort(lst,left,i-1) quick_sort(lst,j+1,right) return lst JavaScript版function quick_sort (lst,l,r) { var i = l, j = r, k = lst[l]; if (i&gt;=j) {return lst}; while(i &lt; j){ for(;i&lt;j;j--){ if (lst[j]&lt;=k) { lst[i] = lst[j]; i++; break } } for(;i&lt;j;i++){ if (lst[i]&gt;=k) {lst[j] = lst[i]; j--; break } } } lst[i] = k; quick_sort(lst,l,i-1); quick_sort(lst,j+1,r); return lst; } C语言版void qucik_sort(int lst[],int l,int r) { if(l &lt; r) { int i = l, j = r, k = lst[l]; while (i &lt; j){ for (; i &lt; j; --j) { if (lst[j] &lt;= k) { lst[i] = lst [j]; i++; break; } } for (; i &lt; j; ++i) { if (lst[i] &gt;= k) { lst[j] = lst[i]; j--; break; } } } lst[i] = k; qucik_sort(lst, l, i-1); qucik_sort(lst, j+1, r); } }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[硬盘文件整理]]></title>
    <url>%2F2015%2F01%2F29%2Ffile-management%2F</url>
    <content type="text"><![CDATA[看着自己电脑里的文件越来越多，文件的存放也变越来越混乱，如何整理文件成了一个大问题，是该花点时间好好整理整理了。 磁盘分区我的电脑是两个硬盘，一个128G的固态和650G的机械硬盘，分别设置为C盘和D盘两个盘。其中。 C盘：安装系统和所有的应用软件。 D盘：用来存放数据，包括文档、音乐、电影等。 为什么不设置E、F等多个分区呢，因为多分区会造成空间的浪费。举个例子：假设有一个600G的硬盘，分为C、D、E三个分区，其中C盘100G，D盘200G，E盘300G。然后C盘放了95G，D盘放了198G，E盘放了287G。现在有一个大小为20G的文件，你说你放哪？C、D、还是E？哪里都不放下，可是明明600G的空间，我现在只用了580G，明明还有20G的空余空间。可是就是没地方放。这就是多分区造成的空间浪费，所以为了空间最大化利用，就是分最少的区。理想情况下，只存在一个C盘就够了。可是有的时候系统出问题需要格式化C盘，假如没有备份会造成数据丢失。所以退而求其次，分为两个盘是一个折中的办法。 文件管理分区搞定了，文件该怎么存放呢。是通过文件类型来存放，还是通过文件功能来存放呢？ 通过文件类型来存放将所有的音乐文件放在一个文件夹，所有的电影放在一个文件夹，所有的文档放在一个文件夹…… 乍看起来挺好的，但是有时会有冲突。比如所有的文档放在一个文件夹，工作、学习、娱乐文档都放在一块，要找一个文件的时候还是会麻烦。有人会说，我用搜索啊。用搜索是个好办法，但是需要你知道你要找的文件的名字，除非你有非常良好的文件命名习惯，比如’a项目-b分支-c文件’这样，那用搜索是一个非常好的办法（比如everything的搜索速度就神快）。所以如果没有良好的命名习惯，那么通过文件类型存放是行不通的。 通过文件功能来存放首先将文件类型分为四大类： 工作 生活 学习 备份 然后在这个分类下面，在通过类型进行划分。所有和工作有关的划分到工作类中，和工作无关的其他学习划分到学习中，其他的音乐、电影、图片等都属于生活。然后在各个大类下面，再通过各自的功能进行进一步的划分，类似一种递归的思想。然后将重要的东西定期更新到备份中，方便文件的复制和拷贝。 我的分类我的最终分类如下图：我这C盘是不是用的有点太狠了。*^_^*]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>文件管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网易云课堂考试题-python]]></title>
    <url>%2F2015%2F01%2F28%2Fpython-neteasy-exam%2F</url>
    <content type="text"><![CDATA[题目内容： 两位整数相乘形成的最大回文数是 9009 = 99 × 91。编写程序，求得任意输入的 n 位整数相乘形成的最大回文数。 输入格式: 正整数 n 输出格式： n 位整数相乘形成的最大回文数 输入样例： 2 输出样例： 9009 程序： def is_palindrome(num): #判断是否是回文 n = str(num) if n == n[::-1]: return True else: return False n = int(input()) a = 1 arr1 = [] arr2 = [] while len(str(a)) &lt; n + 1: #将n位数的数字加到数组中，同时抛弃n-1位数 if len(str(a)) &gt; n - 1: arr1.append(a) arr2.append(a) a = a + 1 maxPalindrome = 1 for i in arr1[::-1]: #从后面往前开始遍历，取得最大的回文数 for j in arr2[::-1]: if i*j &gt; maxPalindrome and is_palindrome(i*j): maxPalindrome = i*j print(maxPalindrome) 总结感觉算法太粗暴，运行效率较低，但一时还没想到更好的算法。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[翘边阴影制作方法]]></title>
    <url>%2F2015%2F01%2F25%2Frase-shadow%2F</url>
    <content type="text"><![CDATA[一些特殊阴影的制作方法，其实就是将多个图形叠加在一起，然后通过z-index调整前后顺序，最后实现效果。HTML： &lt;li&gt;&lt;img src=&quot;img/1.gif&quot; alt=&quot;img&quot;&gt;&lt;/li&gt; CSS： li::after{ content: &quot;&quot;; width: 90%; height: 80%; left: 1.6%; bottom: 4.6%; position: absolute; background-color: transparent; box-shadow: 0px 8px 20px rgba(0,0,0,.6); -webkit-transform: rotate(-4deg) skew(-8deg); -moz-transform: rotate(-4deg) skew(-8deg); -ms-transform: rotate(-4deg) skew(-8deg); -o-transform: rotate(-4deg) skew(-8deg); transform: rotate(-4deg) skew(-8deg); z-index: -1; } li::before{ content: &quot;&quot;; width: 90%; height: 80%; right: 1.6%; bottom: 4.6%; position: absolute; background-color: transparent; box-shadow: 0px 8px 20px rgba(0,0,0,.6); -webkit-transform: rotate(4deg) skew(8deg); -moz-transform: rotate(4deg) skew(8deg); -ms-transform: rotate(4deg) skew(8deg); -o-transform: rotate(4deg) skew(8deg); transform: rotate(4deg) skew(8deg); z-index: -1; } 其实就是将两个平行四边形分别左右旋转后放在原图的下面（如下示意图），并给它设置阴影，最后就会实现图片中阴影效果。可以点击这里查看DEMO]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css3选择器整理]]></title>
    <url>%2F2015%2F01%2F21%2Fcss3-seletor%2F</url>
    <content type="text"><![CDATA[属性选择器 E[att^=&quot;val&quot;]：选择att属性值以val开头的E元素。 E[att$=&quot;val&quot;]：选择att属性值以val结尾的E元素。 E[att*=&quot;val&quot;]：选择att属性值包含val的E元素。 结构性伪类选择器:root: 根选择器，匹配元素所在文档的根元素。在HTML中，根元素始终为&lt;html&gt;。:not : 否定选择器，选择某元素以外的所有元素。下面的代码，最终会为type=button的元素设置红色的背景。 &lt;style&gt; input:not([type=&quot;text&quot;]){background-color: red}; &lt;/style&gt; &lt;body&gt; &lt;input type=&apos;text&apos;&gt; &lt;input type=&apos;text&apos;&gt; &lt;input type=&apos;button&apos;&gt; &lt;/body&gt; :empty: 空选择器，选择内容为空的元素。空元素为里面什么都没有的元素，包括空格。:target: 目标选择器，匹配文档的url的某个标志符的目标元素。下面的代码可以给每个a添加点击事件，当点击a1时，id=’a1’元素的背景会变成红色，其他同理。 &lt;style&gt; #a1:target{background-color: red} #a2:target{background-color: blue} #a3:target{background-color: yellow} &lt;/style&gt; &lt;body&gt; &lt;a href=&quot;#a1&quot;&gt;a1&lt;/a&gt; &lt;a href=&quot;#a2&quot;&gt;a2&lt;/a&gt; &lt;a href=&quot;#a3&quot;&gt;a3&lt;/a&gt; &lt;div id=&quot;a1&quot;&gt;a1&lt;/div&gt; &lt;div id=&quot;a2&quot;&gt;a2&lt;/div&gt; &lt;div id=&quot;a3&quot;&gt;a3&lt;/div&gt; &lt;/body&gt; :first-child: 选择父元素的第一个子元素,ul li:first-child，选择ul下的第一个li元素。:last-child: 与上一个选择相反，选择最后一个子元素。nth-child(n): 选择父元素下的一个或多个指定的子元素。其实n是一个参数，可以是一个数字，也可以是一个表达式。选择ul下序号为偶数（即第二个和第四个，n从零算起）的li，并将其字体设置为黄色。 li:nth-child(2n){color:yellow;} &lt;ul&gt; &lt;li&gt;Hello World&lt;/li&gt; &lt;li&gt;Hello World&lt;/li&gt; &lt;li&gt;Hello World&lt;/li&gt; &lt;li&gt;Hello World&lt;/li&gt; &lt;li&gt;Hello World&lt;/li&gt; &lt;/ul&gt; nth-last-child(n): 和上一个选择器相反，从父元素的最后一个子元素开始算起，来选择指定的元素。first-of-type: 选择父元素下第一个指定tpye的元素，div p:first-of-type,选择一个div里的第一个p元素。nth-of-type(n): 与nth-child(n)类似，选择父元素中指定type的指定位置的元素。div p:nth-of-type(3),选择div下第3个p元素。last-of-type: 与first-of-type类似，不过选择是父元素下最后指定type的元素。nth-last-of-type(n): 与nth-of-type(n)类似，不同的是从父元素的后面开始选择。only-child: div p:only-child当有多个div时，选择仅有一个元素的div下的p元素。仅第一个ul下的li的颜色会变成橘色，其他li的不变。 li:only-child{color: orange} &lt;ul&gt; &lt;li&gt;你好&lt;/li&gt; &lt;/ul&gt; &lt;ul&gt; &lt;li&gt;Hello World&lt;/li&gt; &lt;li&gt;Hello World&lt;/li&gt; &lt;li&gt;Hello World&lt;/li&gt; &lt;li&gt;Hello World&lt;/li&gt; &lt;li&gt;Hello World&lt;/li&gt; &lt;/ul&gt; only-of-type: 与上一个类似，不同之处为选择父级下只有一个指定type的元素的子元素。 其他选择器:enable: 表单中，有可用（“:enabled”）和不可用（“:disabled”）两种状态。此选择其选择可用状态的元素。:disbale: 与上一个选择器类似，选择不可用状态的元素。checked: 单选按钮和复选按钮都具有选中和未选中状态。此选择器选择选中状态下的按钮。selection: 伪元素是用来匹配突出显示的文本(即用鼠标选则文本时的文本)。浏览器默认情况下，用鼠标选择网页文本是以“蓝色背景，白色字体”显示。::selection{color:black;},将选中的文本夜色变为黑色。read-only: 选择只读状态的元素。即设置了”readonly=’readonly’”,(在html5中为直接设置readonly的元素)。read-write: 与read-only相反，选择处于可读写状态的元素。before: 用来给元素前面插入内容。after: 给元素后面插入内容。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[elefixed]]></title>
    <url>%2F2015%2F01%2F21%2FjQuery-plugin-elefixed%2F</url>
    <content type="text"><![CDATA[写了一款js插件，可以让一个元素在随着页面向下滚动到达浏览器顶部时，固定在那，向上滚动时又回到原来的状态。具体介绍可以点击这里查看：eleFixed本插件提供原生js和jQuery两个版本：使用方法: 原生js版：首先在html中引入elefixed.js文件，然后这样调用它:elefixed(&quot;ele&quot;);，其中的&quot;ele&quot;可以换为你要设置元素的id。 jQuery版：直接在元素后面调用该方法即可，像这样$(&quot;ele&quot;).elefixed(),这里的&quot;ele&quot;不再像原生版一样需要id值了，只要能选中该元素即可。 下载地址：]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>jQuery</tag>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[借助gulp自动化前端开发]]></title>
    <url>%2F2015%2F01%2F18%2FF2E-tools-gulp%2F</url>
    <content type="text"><![CDATA[gulp是一款小巧的自动化构建工具，可以帮助我们自动运行大量乏味重复性的任务，比如代码压缩、合并等等，可以为我们节约大量的时间。在制作简历过程中，因为需要用到less，而less需要编译，所以就简单学习了这款工具。 安装Gulp.js因为gulp基于node构建，所以必须先装上node。安装好node后，通过npm来安装gulp： npm install -g gulp 在项目中配置因为我需要编译less，所以先要安装gulp的less插件： npm install --save-dev gulp gulp-less 命令中的--save-dev可以将安装的包添加到包配置文件package.json中： &quot;dependencies&quot;: { &quot;gulp&quot;: &quot;^3.8.10&quot;, &quot;gulp-livereload&quot;: &quot;^3.4.0&quot;, &quot;gulp-less&quot;: &quot;^2.0.1&quot;, &quot;less-plugin-autoprefix&quot;: &quot;^1.3.0&quot; }, 如果项目中没有这个文件，可以通过npm init初始化命令来创建。在项目下的根目录下创建Gulpfile.js文件，这个文件用来定义用到什么插件，执行哪些任务等。在我制作简历过程中，需要将通过bower管理的两个依赖库复制到特定文件夹下，同时监控并编译less文件。所以配置文件如下： var gulp = require(&apos;gulp&apos;), less = require(&apos;gulp-less&apos;); //引入less插件 // 定义 less 任务 gulp.task(&apos;less&apos;, function() { gulp.src(&apos;./less/main.less&apos;) .pipe(less()) .pipe(gulp.dest(&apos;./style&apos;)); }); //复制文件到特定目录 gulp.task(&apos;depends&apos;, function() { gulp.src([&apos;./bower_components/pagepiling.js/jquery.pagepiling.min.js&apos;, &apos;./bower_components/pagepiling.js/jquery.pagepiling.css&apos;]) .pipe(gulp.dest(&apos;./depends&apos;)); }); //监控less文件，一旦有更改，就执行less编译任务 gulp.task(&apos;watch&apos;,function(){ gulp.watch(&apos;less/*.less&apos;,[&apos;less&apos;]); }); //默认任务 gulp.task(&apos;default&apos;,[&apos;less&apos;,&apos;depends&apos;,&apos;watch&apos;]); 其中： gulp.task()就是定义任务的函数，需要两个参数，一个是任务名，一个是回调函数。 gulp.src()是引入文件函数，用来将需要执行的文件路劲引入函数。 .pipe()将引入的文件传递给执行函数，比如.pipe(less())将gulp.src(&#39;./less/main.less&#39;)中得文件传递给less()函数。 gulp.desk()输出函数，将文件输出到指定目录 gulp.watch()监控函数，一旦发现指定文件有了变化，就会执行相应的函数。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>gulp</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[知乎前端面试题解答]]></title>
    <url>%2F2015%2F01%2F14%2Fzhihu-interview-question%2F</url>
    <content type="text"><![CDATA[第一题：请使用Javascript实现以下动态效果 可以使用任何你喜欢的方式和库，尽量使用你认为优雅的实现，并在代码完成说简要说明此方案的优点和不足。这是我用原生js实现的，用到了input标签的readonly属性，实现如下： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;第一题&lt;/title&gt; &lt;style&gt; body{width: 900px;margin: 0 auto;line-height: 30px;} a{ text-decoration: none; } .head{background-color: #059ED3;} .row{ height: 30px; border-bottom: 1px solid #888; } input{ margin-left: 10px; margin-top: 6px; border: none; outline: none; float: left; } .title{ border: 1px solid #999; } a{float: right;} ###add{ background-color: #CCCCCC; width: 100%; height: 30px; } ###add a{ display: block; text-align: right; font-size: 14px; font-weight: bolder; color: #008000; margin-right: 10px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;head&quot;&gt;现在共有:&lt;strong&gt;4&lt;/strong&gt; 个条目&lt;/div&gt; &lt;div id=&quot;list&quot;&gt; &lt;div class=&quot;row&quot;&gt;&lt;input type=&quot;text&quot; value=&quot;标题&quot; /&gt;&lt;a href=&quot;javascript:;&quot; class=&quot;change&quot;&gt;修改&lt;/a&gt;&lt;/div&gt; &lt;div class=&quot;row&quot;&gt;&lt;input type=&quot;text&quot; value=&quot;标题&quot; /&gt;&lt;a href=&quot;javascript:;&quot; class=&quot;change&quot;&gt;修改&lt;/a&gt;&lt;/div&gt; &lt;div class=&quot;row&quot;&gt;&lt;input type=&quot;text&quot; value=&quot;标题&quot; /&gt;&lt;a href=&quot;javascript:;&quot; class=&quot;change&quot;&gt;修改&lt;/a&gt;&lt;/div&gt; &lt;div class=&quot;row&quot;&gt;&lt;input type=&quot;text&quot; value=&quot;标题&quot; /&gt;&lt;a href=&quot;javascript:;&quot; class=&quot;change&quot;&gt;修改&lt;/a&gt;&lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;add&quot;&gt;&lt;a href=&quot;javascript:;&quot;&gt;新增条目&lt;/a&gt;&lt;/div&gt; &lt;script&gt; window.onload = function(){ change(); add(); }; change = function(){ var list = document.getElementById(&apos;list&apos;); var titles = list.getElementsByTagName(&apos;input&apos;); var changes = list.getElementsByTagName(&apos;a&apos;); for (var i = titles.length - 1; i &gt;= 0; i--) { titles[i].readOnly = &quot;readonly&quot;; }; for (var j = changes.length - 1; j &gt;= 0; j--) { changes[j].index = j; changes[j].onclick = function(){ if (this.text == &quot;修改&quot;) { this.text = &quot;保存&quot;; titles[this.index].readOnly = &quot;&quot;; titles[this.index].className = &quot;title&quot;; }else{ this.text = &quot;修改&quot;; titles[this.index].readOnly = &quot;readonly&quot;; titles[this.index].className = &quot;&quot;; }; } }; }; add = function(){ var addBtn = document.getElementById(&apos;add&apos;).getElementsByTagName(&quot;a&quot;)[0]; addBtn.onclick = function(){ var newRow = document.createElement(&quot;div&quot;); newRow.className = &quot;row&quot;; newRow.innerHTML = &apos;&lt;input type=&quot;text&quot; value=&quot;未命名&quot; /&gt;&lt;a href=&quot;javascript:;&quot; class=&quot;change&quot;&gt;修改&lt;/a&gt;&apos;; var list = document.getElementById(&quot;list&quot;); // console.log(&quot;click&quot;,list); // e = e || window.event; list.appendChild(newRow); change(); // e.cancelBubble = true; update(); } } update = function(){ var list = document.getElementById(&apos;list&apos;); var lth = list.getElementsByTagName(&apos;div&apos;).length; var count = document.getElementsByTagName(&apos;strong&apos;)[0]; count.innerHTML = lth; } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 第二题：请说明要输出正确的myName的值要如何修改程序?并解释原因foo = function() { this.myName = &quot;Foo function.&quot;; } foo.prototype.sayHello = function() { alert(this.myName); } foo.prototype.bar = function() { setTimeout(this.sayHello, 1000); } var f = new foo; f.bar(); 因为this指向的是当前调用这个方法的对象,代码中setTimeout是一个全局函数,全写是window.setTimeout，所以setTimeout(func,time)中的func参数中的this应该指向window。可以用如下的修改方法： foo.prototype.bar = function(){ var That = this; setTimeout(function(){ That.sayHello(); },1000); } 第三题：请按下列要求写出相应的 Html 和 CSS现有并列的三列布局结构，从左至右依次为 A, B, C, 宽度分别为180px, 600px, 180px。要求在不改变 Html 结构的情况下用CSS实现：ABC，CBA，BAC 三种布局及在CBA排列下使B宽度自适应（三列总宽度100%），不能使用针对浏览器的CSS Hack. &lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh-cn&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;第三题&lt;/title&gt; &lt;style&gt; .content{ width:auto; margin: 0 auto; position: relative; height: 50px; overflow: auto; } .a{ background-color: red; width: 160px; } .b{ background-color: blue; width: 600px; } .c{ background-color: yellow; width: 160px; } .a,.b,.c{ height: 50px; } /* ABC*/ .a1,.b1,.c1{ float: left; } /* CBA*/ .c2{ position: absolute; top: 0; left: 0; } .a2{ float: right; } .b2{ margin-left: 160px; width: auto; } /* BAC*/ .b3{ float: left; } .a3{ position: absolute; top: 0; left:600px; } .c3{ float: right; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;从左至右依次为 A, B, C, 宽度分别为180px, 600px, 180px。用CSS实现：ABC，CBA，BAC 三种布局及在CBA排列下使B宽度自适应（三列总宽度100%）.&lt;/p&gt; &lt;p&gt;ABC，结构&lt;/p&gt; &lt;div class=&quot;content&quot;&gt; &lt;div class=&quot;a a1&quot;&gt;A&lt;/div&gt; &lt;div class=&quot;b b1&quot;&gt;B&lt;/div&gt; &lt;div class=&quot;c c1&quot;&gt;C&lt;/div&gt; &lt;/div&gt; &lt;p&gt;CBA,B宽度自适应&lt;/p&gt; &lt;div class=&quot;content&quot;&gt; &lt;div class=&quot;a a2&quot;&gt;A&lt;/div&gt; &lt;div class=&quot;b b2&quot;&gt;B&lt;/div&gt; &lt;div class=&quot;c c2&quot;&gt;C&lt;/div&gt; &lt;/div&gt; &lt;p&gt;BAC结构&lt;/p&gt; &lt;div class=&quot;content&quot;&gt; &lt;div class=&quot;a a3&quot;&gt;A&lt;/div&gt; &lt;div class=&quot;b b3&quot;&gt;B&lt;/div&gt; &lt;div class=&quot;c c3&quot;&gt;C&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 总结第一题中，因为用到了readonly属性，实现起来比较简单。但是根据原题目的演示，猜测到他的实现方法是动态的添加input标签，同时控制input的display属性来实现，感觉太麻烦就没有用那种方法。第二题中，关于js中this的指向问题，我的理解还是不够深刻，需要继续深入了解。第三题，很轻松的就解决了。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>JavaScript</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端开发学习笔记六]]></title>
    <url>%2F2015%2F01%2F13%2Flearning-note-6%2F</url>
    <content type="text"><![CDATA[前言终于搞定了一个电商整站临摹，共四张页面，实现了基本的交互功能，同时也应用了less这个新学的css预处理语言。之前也做过一个电商首页点这儿。但是因为只是单页面，处理起来比较简单。但是在制作这个整站的过程中，更加深刻的理解一些之前学过的内容：比如样式结构的分离，js设计时的分层思想等。点击这里查看网页效果，或者下面有效果图(图好丑)： 结构首先说结构，拿到设计图时，先要进行分析。比如这四张页面，是典型的上中下结构，其除了中间正文部分，头部和脚部都是完全一样的，而且除了商品详细页面外，其他的正文部分都分为左右结构，可先将这部分相同的结构写好后作为模版，在写其他页面时只需要在模版的基础上填充内容就可以了。 &lt;body&gt; &lt;div id=&quot;head&quot;&gt;&lt;!-- 完全一样的 --&gt; &lt;/div&gt; &lt;div id=&quot;content&quot;&gt; &lt;!-- 部分一样 --&gt; &lt;/div&gt; &lt;div id=&quot;footer&quot;&gt;&lt;!-- 完全一样 --&gt; &lt;/div&gt; &lt;/body&gt; 样式因为在写样式过程中用了less这个css高级语言，写起来方便了许多，不用再去将一些重复的东西写上一遍又一遍，省去诸多麻烦。我对Css也惊醒了分层，先针对模版写一份样式名为mian.js，接下在针对不同的页面写不同的样式，最后在页面中同时引入进来就可以了。其实还可以再进一步细分，比如针对头部和页脚的，banner部分的，页码部分的等等。 逻辑最后是js，在分析中发现，不同的页面中用的许多的逻辑都是一样的、比如几个banner部分的自动切换、模拟下拉菜单等。这时，将整个js代码分为以下三个层来写： 工具层这里是一些最基础的东西，比如获取元素的class shop.tools = {}; shop.tools.getByClass = function(par, cla) {};//获取相应class元素 shop.tools.onmouseover = function(ele,eles,select){};//参数为子元素，和父元素，最终为当前元素添加active状态 shop.tools.onclick = function(ele,eles){}; 用户界面层这里写一下会多处用到的UI层： shop.ui = {}; shop.ui.fadeIn = function(ele, time, opacity) {}; shop.ui.fadeOut = function(ele, time, opacity) {}; 应用层这里就是页面会直接用的交互层： shop.app = {}; shop.app.tip = function() {}; shop.app.banner = function() {}; shop.app.chose = function(){ var specification = document.getElementById(&apos;specification&apos;); var color = document.getElementById(&apos;color&apos;); var speSpans = specification.getElementsByTagName(&apos;span&apos;); var colorSpans = color.getElementsByTagName(&apos;span&apos;) for (var i = speSpans.length - 1; i &gt;= 0; i--) { shop.tools.onmouseover(speSpans[i],speSpans); shop.tools.onclick(speSpans[i],speSpans); } for (var j = colorSpans.length - 1; j &gt;= 0; j--) { shop.tools.onmouseover(colorSpans[j],colorSpans); shop.tools.onclick(colorSpans[j],colorSpans); }; } shop.app.chose_screen = function(){ var top = document.getElementById(&apos;top&apos;); var a = top.getElementsByTagName(&apos;a&apos;); for (var i = a.length - 1; i &gt;= 0; i--) { if (a[i].innerHTML == &quot;更多&quot;) {continue} else{ shop.tools.onmouseover(a[i],a,&quot;active&quot;); } }; }; 代码太多就不全贴了，可以看到在这里会多次用到之前tools和ui里面的函数，这样就提高了代码的利用率，使结构看起来清晰，易于他人理解和维护。最后在页面中，哪里用到，哪里直接引用就可以了。 总结在这个过程中也认识到自己很多方面还是不够熟练，需要继续加油啊。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初试chrome应用]]></title>
    <url>%2F2015%2F01%2F11%2Fchrome-extension-firsttime%2F</url>
    <content type="text"><![CDATA[众所周知，onedrive是微软提供的一款个人网络硬盘，对老用户提供25GB的免费空间，新注册用户提供7GB的空间，要是这个空间可以用来做博客的图床就太好不过了。毕竟微软这么一个财大气粗的公司，而且在国内也不会随随便便就被墙掉，所以稳定性有保证。但是onedrive提供的公开链接并不能直接插入博客，需要做一定的格式转换才可以。在网上找到了转换连接的办法，但是要是手动转换，太麻烦了，于是想着做一个chrome扩展，毕竟方便嘛。粗略的看了一下chrome提供的api，发现如果只是做一个简单的应用其实很简单。那么说干就干，下面是做好的效果图。我也直接将内容嵌入进来，可以直接在这转换： 公开链接： 文件类型： 转换后地址： 它的功能：输入从onedrive获取的公开链接和文件的类型，就可以得到这个文件的可直接访问的地址。它由四个基本文件组成，分别为： manifest.json popup.html popup.css popup.js 其中第一个文件是应用的描述信息，后面的三个文件分别是应用的内容、样式以及逻辑，其实就和一个网页是一样的。 因为暂时没有开通开发者账号，所以不能提交到应用商店。不过可以在这里下载：点这里,下载后不能直接安装，需要手动拖动到插件管理处，然后就可以尽情使用了。 如果你对源码感兴趣，那么：点这里]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>chrome</tag>
        <tag>onedrive</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[借助Hexo和Github搭建一个博客]]></title>
    <url>%2F2015%2F01%2F08%2Fhexo-blog%2F</url>
    <content type="text"><![CDATA[花了两天时间，总算把博客搭起来了。期间碰到了很多问题，还好有伟大的Google，也都一一化解。现将其间过程写下来，也好帮助像我一样需要帮助的人。 框架选择一开始打算搭建博客，先要思考你要搭建那种类型的网站：动态网站还是静态网站。考虑到我只是想有一个可以记录自己想法的空间，所以就选择了静态网站。而静态网站也有很多框架可供选择，github推荐的jekyll，基于jekyll开发的octopress，以及使用·node·编写的hexo。 jekyll Jekyll 是一个简单的博客形态的静态站点生产机器。它有一个模版目录，其中包含原始文本格式的文档，通过 Markdown（或者 Textile以及Liquid 转化成一个完整的可发布的静态网站，你可以发布在任何你喜爱的服务器上。Jekyll 也可以运行在 GitHub Page 上，也就是说，你可以使用 GitHub的服务来搭建你的项目页面、博客或者网站，而且是完全免费的。 本来打算用jekyll，但是在配置过程中出现了一些问题，windows下安装jekyll各种失败，百般不得求解，最终放弃。 octopress Octopress是利用Jekyll博客引擎开发的一个博客系统，生成的静态页面能够很好的在github page上展现。号称是hacker专属的一个博客系统(Ablogging framework for hackers.) hexo hexo是由Node.js驱动的一款快速、简单且功能强大的博客框架。它和jekyll相比，更快，更轻量。其出自台湾大学生tommy351之手，编译上百篇文字只需要几秒。hexo生成的静态网页可以直接放到GitHub Pages，BAE，SAE等平台上。 因为它的小巧轻便，易于配置，而且功能同样强大，最终选择了hexo。 环境准备需要安装nods.js，git，和一款编辑器。这些直接找相应的官网，一路安装就行了。 安装HEXO以上软件安装好后，直接执行以下代码： npm install -g hexo 初始化执行init命令初始化hexo到你指定的目录,比如我是在D盘的blog文件夹下(以下默认都在这个路径下)： D:\blog&gt;hexo init 安装过程就完了，是不是很简单呢？ 生成页面D:\blog&gt;hexo generate 本地启动D:\blog&gt;hexo server 在浏览器中输入http://localhost:4000就可以看到你自己的博客了。 写博客执行new命令 D:\blog&gt;hexo new [layout] &quot;postName&quot;#其中layout为模版类型，默认为post，“postName”为你的文章名 接下来在hexo\source\_posts\中就可以找到相应的文件，接下来就可书写文章了。 部署可以选择github page，免费300m的空间，而且不限流量。方法也很简单，在你的github下，新建一个username.github.io的仓库，然后在hexo目录下名为的_config.yml的配置文件里： deploy: deploy: type: github repository: https://github.com/kisnows/kisnows.github.io.git branch: master #此处将kisnows替换为你的github账号名 一切就ok了。 常用命令hexo new &quot;postName&quot; #新建文章 hexo new page &quot;pageName&quot; #新建页面 hexo generate #生成静态页面至public目录 简写：hexo g hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server） 简写：hexo s hexo deploy #将.deploy目录部署到GitHub 简写：hexo d hexo d -g #组合命令，先生成页面，后部署到Github]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>网站建设</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端开发学习笔记五]]></title>
    <url>%2F2015%2F01%2F01%2Flearning-note-5%2F</url>
    <content type="text"><![CDATA[幽灵按钮最近很流行，就寻思着做了一个，它有如下一些效果。 其中按钮上的线条和图标的旋转完全用CSS3中的transtion和transform来实现，其中图标的旋转效果实现过程如下： .link .img{ display: block; width:180px; height:180px; margin-bottom: 20px; -webkit-transition:all 0.5s cubic-bezier(0, .18, 0, .97); //为了兼容chrome和Safari transition:all 0.5s cubic-bezier(0, .18, 0, .97); //定义动画属性，包括要变化的属性，时间，以及变化曲线（linear、ease、ease-out或者自定义等） } .mis .img{ background: url(../images/mission.png) no-repeat center 0; } .link .img:hover{ -webkit-transform: rotate(360deg) scale(1.2); -ms-transform: rotate(360deg) scale(1.2); transform: rotate(360deg) scale(1.2); } 按钮的线条效果与上面的方法类似，而按钮上的提示文字使用js来实现的。 主要原理就是通过js获取按钮上相应的title（即要显示的文字），然后将其增加在提示框内，在通过判定当前按钮的位置来设置提示框要出现的相应位置。 $(function(){ $(&quot;.link .btn&quot;).hover(function(){ var title = $(this).attr(&quot;data-title&quot;); $(&quot;.tip em&quot;).text(title); var left = $(this).position().left; var dis = Math.abs(($(&quot;.tip&quot;).outerWidth()-$(this).outerWidth())/2); var now = left -dis; console.log(&quot;title=&quot;+title+&quot; &quot;,&quot;left=&quot;+left,&quot;dis=&quot;,dis,&quot;now=&quot;+now,&quot;this&quot;+$(&quot;.tip&quot;).outerWidth()); $(&quot;.tip&quot;).css({&quot;left&quot;:now+&quot;px&quot;}).animate({&quot;top&quot;:130,&quot;opacity&quot;:1},300); }, function(){ $(&quot;.tip&quot;).animate({&quot;top&quot;:100,&quot;opacity&quot;:0},300); } ) }) //用了jQuery框架中的hover(function(),function())函数，前一个函数为鼠标放上去的动作，后一个为鼠标离开时的动作。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>学习笔记</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端开发学习笔记四]]></title>
    <url>%2F2014%2F12%2F30%2Flearning-note-4%2F</url>
    <content type="text"><![CDATA[固定导航栏根据页面滚动条距离来自动定位的效果，其中心思想就是通过判定当前滚动条的值与页面中相应内容值大小的关系来选择。js代码如下（用到了jQuery库）： $(document).ready(function () { $(window).scroll(function () { var top = $(window).scrollTop(); var menu = $(&quot;#menu&quot;); var items = $(&quot;#content&quot;).find(&quot;.item&quot;); //滚动条发生滚动时，要获取相应的值。 var currentId = &quot;&quot;; //让导航菜单实现在滚动条滚动的时候自动设置焦点 items.each(function () { var This = $(this); var itemTop = This.offset().top; if (top &gt; itemTop - 200) { currentId = This.attr(&quot;id&quot;); } else { return false; } }) //给相应楼层的a 设置 current，取消其他链接的current var currentLink = menu.find(&quot;.current&quot;); if (currentId &amp;&amp; currentId != &quot;#&quot;+currentLink.attr(&quot;href&quot;)) { currentLink.removeClass(&quot;current&quot;); menu.find(&quot;[href=#&quot; + currentId + &quot;]&quot;).addClass(&quot;current&quot;); } }) })]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端开发学习笔记三]]></title>
    <url>%2F2014%2F12%2F26%2Flearning-note-3%2F</url>
    <content type="text"><![CDATA[把慕课的首页临摹了一下，感觉还不错。顺便推荐一个前端编辑器，Adobe出的Brackets，可以实时预览，再也不用老是切换加f5了，可以极大的提高编写速度。 下载地址： http://brackets.io/]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端开发学习笔记二]]></title>
    <url>%2F2014%2F12%2F24%2Flearning-note-2%2F</url>
    <content type="text"><![CDATA[前几天把之前做的购物网页的js效果写了出来。如图所示，分别为以下几个效果： 搜索按钮的文字效果 轮播图 模拟下拉菜单 鼠标点击按钮，图片进行左右滚动 在学习过程中，思想很重要。写一个效果之前，现对其进行设计，然后分析，最后再实现。 比如很简单的一个轮播图，让图片淡入淡出的切换。它的原理就是，先让所有的图片淡出，然后让当前要显示的图片淡入就可以了。理解了它的工作原理，写起来就很简单了。 shop.app.Banner=function(){ //Banner轮播图效果 var ad=document.getElementById(&quot;ad&quot;); var ul=ad.getElementsByTagName(&quot;ul&quot;)[0]; var li=ul.getElementsByTagName(&quot;li&quot;); var iNow=0; var timer=setInterval(auto,3000); function auto() //自动切换效果 { if(iNow==li.length-1) { iNow=0; } else{ iNow++; } for(var i=0;i&lt;li.length;i++) { shop.ui.fadeOut(li[i]); } shop.ui.fadeIn(li[iNow]); } }; 还有一个就是，在写整个页面的代码的时候，要对齐进行分层。比如分为作为底层的工具层，多处都会用到的UI层，以及最终的应用层。这样写可以减少代码的重复，使文档看起来结构清晰，也易于别人的理解和后期的维护。在这里，我跟随教程采用了命名空间的方法来编写这个页面。整个代码如下： window.onload=function(){ //调用函数 shop.app.Banner(); shop.app.search(); shop.app.sort(); shop.app.Run(); }; var shop={}; //命名空间 shop.tools={}; shop.tools.getByClass=function(Par,Cla) //获取对应class的对象 { var allEle=Par.getElementsByTagName(&quot;*&quot;); var arr=[]; for(i=0;i&lt;allEle.length;i++) { if(allEle[i].className==Cla) { arr.push(allEle[i]); } } return arr; }; shop.tools.getStyle=function(obj,attr) //获取对象属性 { if(obj.currentStyle) { return obj.currentStyle[attr]; } else { return getComputedStyle(obj,false)[attr]; } }; shop.ui={}; shop.ui.fadeIn=function(obj) //淡入效果 { var attr=shop.tools.getStyle(obj,&apos;opacity&apos;); if(attr==1) { return false; }; var value=0; clearInterval(obj.timer); obj.timer=setInterval(function(){ var speed=5; if(value==100){ clearInterval(obj.timer); } else { value+=speed; obj.style.opacity=value/100; } },30); }; shop.ui.fadeOut=function(obj) //淡出效果 { var attr=shop.tools.getStyle(obj,&apos;opacity&apos;); if(attr==0) { return false; }; var value=100; obj.timer=setInterval(function(){ var speed=-5; if(value==0) { clearInterval(obj.timer); } else { value+=speed; obj.style.opacity=value/100; }; },30); }; shop.ui.textChange=function(obj,str){ //清空默认文字 obj.onfocus=function(){ if(this.value==str){ this.value=&quot;&quot;; } }; obj.onblur=function(){ if(this.value==&quot;&quot;){ this.value=str; } }; }; shop.ui.moveLeft=function(obj,old,now){ //对象位置左移 clearInterval(obj.timer); obj.timer=setInterval(function(){ var speed=(now-old)/15; speed=Math.round(speed); if(now==old){ clearInterval(obj.timer); } else{ old+=speed; obj.style.left=old+&quot;px&quot;; } },30); }; shop.app={}; shop.app.Banner=function(){ //Banner轮播图效果 var ad=document.getElementById(&quot;ad&quot;); var ul=ad.getElementsByTagName(&quot;ul&quot;)[0]; var li=ul.getElementsByTagName(&quot;li&quot;); var iNow=0; var timer=setInterval(auto,3000); function auto() { if(iNow==li.length-1) { iNow=0; } else{ iNow++; } for(var i=0;i&lt;li.length;i++) { shop.ui.fadeOut(li[i]); } shop.ui.fadeIn(li[iNow]); } }; shop.app.search=function(){ var s1=document.getElementById(&quot;search1&quot;); var s2=document.getElementById(&quot;search2&quot;); shop.ui.textChange(s1,&quot;Search website&quot;); shop.ui.textChange(s2,&quot;Search website&quot;); }; shop.app.sort=function(){ //模拟下拉菜单 var sor=document.getElementById(&quot;sort&quot;); var sordd=sor.getElementsByTagName(&quot;dd&quot;); var sorul=sor.getElementsByTagName(&quot;ul&quot;); var sorh4=sor.getElementsByTagName(&quot;h4&quot;); for(var i=0;i&lt;sordd.length;i++){ sordd[i].index=i; sordd[i].onclick=function(ev){ var ev=ev||window.event; var This=this; for(var n=0;n&lt;sorul.length;n++){ sorul[n].style.display=&quot;none&quot;; } sorul[this.index].style.display=&quot;block&quot;; document.onclick=function(){ sorul[This.index].style.display=&apos;none&apos;; }; ev.cancelBubble=true; } }; for(var i=0;i&lt;sorul.length;i++){ sorul[i].index=i; (function(ul){ var sorli=ul.getElementsByTagName(&quot;li&quot;); for(var i=0;i&lt;sorli.length;i++){ sorli[i].onmouseover=function(){ this.className=&quot;active&quot;; }; sorli[i].onmouseout=function(){ this.className=&quot;&quot;; }; sorli[i].onclick=function(ev){ var ev = ev || window.event; sorh4[this.parentNode.index].innerHTML=this.innerHTML; ev.cancelBubble = true; this.parentNode.style.display=&quot;none&quot;; }; } })(sorul[i]); }; }; shop.app.Run=function(){ //点击左移效果 var slide=document.getElementById(&apos;slide&apos;); var ul=slide.getElementsByTagName(&apos;ul&apos;)[0]; var li=ul.getElementsByTagName(&apos;li&apos;); var pre=shop.tools.getByClass(slide,&quot;pre&quot;)[0]; var next=shop.tools.getByClass(slide,&quot;next&quot;)[0]; var iNow=0; ul.innerHTML+=ul.innerHTML; ul.style.width=li.length*li[0].offsetWidth+&quot;px&quot;; pre.onclick = function(){ if(iNow == 0){ iNow = li.length/2; ul.style.left = -ul.offsetWidth/2 + &apos;px&apos;; } shop.ui.moveLeft(ul,-iNow*li[0].offsetWidth,-(iNow-1)*li[0].offsetWidth); iNow--; }; next.onclick = function(){ if(iNow == li.length/2){ iNow = 0; ul.style.left = 0; } shop.ui.moveLeft(ul,-iNow*li[0].offsetWidth,-(iNow+1)*li[0].offsetWidth); iNow++; }; };]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端开发学习笔记一]]></title>
    <url>%2F2014%2F12%2F11%2Flearning-note-1%2F</url>
    <content type="text"><![CDATA[刚刚花了点时间学完html和css，同时粗略的看了一点javascript。于是看了一遍教程后，就动手做了下面这个页面。（这是原效果图）其中有些问题，比如教程中的一些圆角按钮，是用一个三层嵌套然类似&lt;ahref=&#39;&#39;&gt;&lt;strong&gt;&lt;span&gt;HOME&lt;/span&gt;&lt;/strong&gt;&lt;/a&gt;后分别给每个标签设置背景图片来实现。感觉有点得不偿失，其实完全可以用border-radius加上一个平铺背景来实现，即简单代码看起来又清爽，而且符合html的语义化: &lt;a&gt;HOME&lt;/a&gt;，然后只需要在css中设置a{border-radius:5px}，就可以了。实现图如下： 还有一个问题，就是整个页面的主题部分的背景，是一个圆角的有阴影效果的白色图片。教程中同样是用切三张图加上html的三层嵌套来实现。其实这里也可以不那么麻烦，用一个圆角边框加上背景白色，再设置一个阴影效果就可以了。 #Content{ background:#fff; box-shadow:0 3px 5px#e4e4e4; border-radius:25px25px 0 0; } 效果图如下： 不过上面的这些解决方法有一个问题，就是都用到了css3中的新特性，在较老的浏览器中效果会大打折扣，要考虑到需求在决定用那种方法。最后放上整体做好后的页面图，和最上面那张比一下，感觉还是不错的。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
</search>
