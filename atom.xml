<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>抹桥的博客</title>
  
  <subtitle>Seize the day.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.kisnows.com/"/>
  <updated>2018-06-15T14:02:09.096Z</updated>
  <id>https://blog.kisnows.com/</id>
  
  <author>
    <name>抹桥</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>泰国懒人游</title>
    <link href="https://blog.kisnows.com/2018/06/09/thailand-travel-notes/"/>
    <id>https://blog.kisnows.com/2018/06/09/thailand-travel-notes/</id>
    <published>2018-06-09T07:57:12.000Z</published>
    <updated>2018-06-15T14:02:09.096Z</updated>
    
    <content type="html"><![CDATA[<h1 id="泰国"><a href="#泰国" class="headerlink" title="泰国"></a>泰国</h1><h2 id="落地签"><a href="#落地签" class="headerlink" title="落地签"></a>落地签</h2><p>我是飞到曼谷素万那普机场，下机后跟着人流直走，头上有指示牌，可以一路走到办理落地签的地方。<br>办理落地签有两个通道，一个普通通道，一个快速通道。快速通道 2200🐖，普通通道 2000🐖。<br>建议走快速通道，能省很多时间。<br><img src="/2018/06/09/thailand-travel-notes/1.jpg" title="机场"></p><h2 id="机场大巴"><a href="#机场大巴" class="headerlink" title="机场大巴"></a>机场大巴</h2><p>从扶梯下来，好像是到一楼，然后会看到大巴售票点。<br><img src="/2018/06/09/thailand-travel-notes/2.png" title="机场"></p><p>然后会看到大巴售票点，就长下图这个样子，有到芭堤雅和华欣的大巴，大概每小时一班车。<br><img src="/2018/06/09/thailand-travel-notes/3.jpg" title="大巴售票点"><br>然后面向大巴售票点左手边有吃饭的地方，在这个位置。<br><img src="/2018/06/09/thailand-travel-notes/4.jpg" title="机场饭厅"></p><p>里面东西很便宜，进去要换票，一个人的话100🐖就够了。能吃很多东西，我当时吃了一碗面，一罐可乐，还剩了 15🐖。<br><img src="/2018/06/09/thailand-travel-notes/5.jpg" title="机场"><br><img src="/2018/06/09/thailand-travel-notes/6.jpg" title="机场"></p><a id="more"></a><h2 id="曼谷-gt-芭堤雅"><a href="#曼谷-gt-芭堤雅" class="headerlink" title="曼谷 -&gt; 芭堤雅"></a>曼谷 -&gt; 芭堤雅</h2><p>在大巴售票点买好票，售票员说 1.30 发车，我问了下在哪里，他指了个地方，说到 1.30 会有人领你们过去。<br>从曼谷到芭堤雅大概两个小时的样，在芭堤雅有好几个下车点，分别是 North Pattaya Road（芭提雅北路）和 Central Pattaya Road（芭提雅中路）、South Pattaya Road（芭提雅南路）、 Thepprasit Road 和 Thappraya Road。下车点其实挺多的，特别是 Pattaya Road 的北、中、南路（都靠近海边的Beach Road），就是芭提雅的中心地带了，在这三个地点下车都很方便。<br>我当时在 Central Pattaya Road（芭提雅中路）下车，然后就有一个摩的师傅上来拉活。我问了下价格，他说 one two zero ，我一开始半天没理解他们说什么，以为是 ‘three hundred’ 300 🐖。就拿出计算器按数字给他们看，他说不是，按了个 120 上去，我一想也行，就上车了。女生的话不怎么建议座这个，总感觉不是很安全的样子。<br></p><h1 id="芭堤雅"><a href="#芭堤雅" class="headerlink" title="芭堤雅"></a>芭堤雅</h1><p>摩的直接把我载到了酒店，给钱的时候发生了一件很有意思的事情。我拿出一张 50 和 20 给他，我以为那张 50 是 100. 然后师傅一直在说什么我听不懂的语言，我还以为要坑我。两人瞎扯了半天，我才发现我给的钱不对，赶紧补上了 100 。<br>进酒店办理入住，放下东西就先睡了一觉，哈哈。</p><p>一觉睡到了五点多，给饿醒了。就出去觅食，附近随便找了找，吃的东西还是很多的，也不是很贵，下面这个 200 🐖。<br><img src="/2018/06/09/thailand-travel-notes/8.jpg" title="菠萝饭"></p><p>吃完出去到海边走了走，就回去了。<br><img src="/2018/06/09/thailand-travel-notes/9.jpg" title="海滩-芭堤雅"></p><h2 id="交通"><a href="#交通" class="headerlink" title="交通"></a>交通</h2><p>芭堤雅海边的交通还是很方便的，直接座双条车就好了，但是都是单行。<br><img src="/2018/06/09/thailand-travel-notes/10.jpg" title="双条车-芭堤雅"><br>南北走向， 1st rd 南行，2nd rd北行，双条招手即停，只要不问司机目的地和加钱，默认 10🐖，看好下车点按铃下车，先下车再付费。如果问了司机能不能去哪里，默认为包车价，但是要记得砍价。<br></p><h2 id="趣事"><a href="#趣事" class="headerlink" title="趣事"></a>趣事</h2><p>在芭堤雅的第二天就海边瞎逛了一天，中午在大众点评上定了个西餐，就从酒店出发去餐厅了。</p><p>里面的服务员都很礼貌，我上去说操着蹩脚的英语 I have a preorder ,结果他们没听懂。正当我打算打开翻译看看我提前预定了这句话怎么说时，一位服务员拿了一打订单过来问我叫什么名字，我说 ab 他们疑惑了一下 指着 ba 问是不是我，哈哈，我都忘了要先名后姓。<br>然后就发生了很有意思的事情，他们端上来了一个很大的汉堡，就像图里这样：<br><img src="/2018/06/09/thailand-travel-notes/food.jpg" title="food-芭堤雅"><br>我一看这么大，犹豫了半天不知道怎么吃，然后就做出了很可笑的事情。叫来服务员，问了一句：”How to eat it?”<br>女服务员姐姐直接笑了，然后跟我说用刀叉切，我傻逼的就去拿刀叉切了。刚切了一块，经理过来说你想怎么吃就怎么么吃，it’s up to you. 然后我就直接上手了。<br>我都服了我，怎么能问出怎么吃这种问题，哈哈。</p><p>中途进来了几个跟团游的国人，我还帮他们当了下翻译，就我这蹩脚的英语，哈哈。不过不得不说，国人确实一进来大吵大闹的，感觉很不好，可能是因为都是大爷大妈，平时都习惯了的原因吧。</p><p>吃完逛了一圈，去商场买了条腰带，顺便帮一个网友到了她要的面膜。就回酒店休整了。</p><h2 id="人"><a href="#人" class="headerlink" title="人"></a>人</h2><p>下午去海边散步，认识了两个国内来的妹子，聊的很开心。<br><img src="/2018/06/09/thailand-travel-notes/12.jpg" title="妹子"></p><p>晚上打算去吃饭，被妹子拉着去步行街（红灯区）逛了一圈，红灯区里一看你是中国人，就会有很多人拿着不堪入目的牌子上来问你，说看不看什么表演之类的。不要去理就好了，就算你真抱着猎奇的心理去看，也不建议跟着这些推销的人去，很容易被宰。<br><img src="/2018/06/09/thailand-travel-notes/13.jpg" title="步行街-芭堤雅"><br><img src="/2018/06/09/thailand-travel-notes/14.jpg" title="步行街-芭堤雅"></p><p>不过吃饭的时候遇到了一点不愉快，我们大老远从芭堤雅市区走了好久然后打车才到那个店打算吃海鲜。<br>结果我们一进去人家说了什么一堆乱七八糟的英语，我们三个人没一个人听懂，然后说我们找错地方了，带我们出去给我指路说在那边。<br>然而在她手指的方向根本什么都没有，看起来应该是被餐厅莫名其妙的拒绝接待了。就下图这个餐厅： Maggic Restaurant, 最后只能打车回市区吃饭。<br><img src="/2018/06/09/thailand-travel-notes/maggic.jpg" title="拒绝我们的餐厅"><br>吃完饭就跟妹子分道扬镳了。</p><h2 id="可兰岛"><a href="#可兰岛" class="headerlink" title="可兰岛"></a>可兰岛</h2><p>第三天报了个可兰岛一日游，玩的很嗨，全程有人接送，不用操什么心，哈哈。什么滑翔伞、海底漫步、浮潜乱七八糟的加起来才不到四百块，简直太便宜了。玩的也很舒服，就是师傅游艇开的很快，晕船的人要提前备好晕船药，看到船上有人晕的不行。<br><img src="/2018/06/09/thailand-travel-notes/15.jpg" title="可兰岛-芭堤雅"><br>这中间又认识了一个妹子，太强了，一个人出来玩，还玩了跳伞。佩服的不行，我本来也想玩的，可最后还是怂了，一是真的贵 3000 大洋，而是三千米跳下来还是很可怕的，我承认我一个人有点怂，哈哈。</p><h2 id="芭堤雅-gt-曼谷"><a href="#芭堤雅-gt-曼谷" class="headerlink" title="芭堤雅 -&gt; 曼谷"></a>芭堤雅 -&gt; 曼谷</h2><p>第四天早上就从芭堤雅往曼谷走，还是做大巴。酒店前台帮忙找了个摩的师傅把我拉过去，80🐖。<br><br>进站买票后，就在候车室等候，车票上会写发车时间和座位号，按照要求走就行了。<br><img src="/2018/06/09/thailand-travel-notes/17.jpg" title="候车室-芭堤雅"><br><img src="/2018/06/09/thailand-travel-notes/18.jpg" title="车票-芭堤雅"></p><p>又是两个小时，到了车站下来，我就去找 bts ，跟着地图走就行，下图这个就是 ekkamai 站入口。<br><br>进去后买票等车，买票的话可以选择自动售卖机，但是只收硬币。也可以选择人工窗口，给纸币然后说要去那个站点就好了。<br><img src="/2018/06/09/thailand-travel-notes/20.jpg" title="bts-曼谷"><br>候车的时候问了个泰妹，我要去的站是从那边做，因为怕做错。泰妹跟我说就这里，然而上车后还是怕做错站，就盯着这个指示和到站语音提醒看我做的方向对不对，还好是对的，果然漂亮的小姐姐不会骗人。<br><img src="/2018/06/09/thailand-travel-notes/21.jpg" title="bts-曼谷"><br>因为住在老城区，bts 不直达，到站后打了个的士才到酒店，座的士去酒店的路上中间还发生了一点小插曲。<br>提醒一下，打的的话要注意，一定让他打表 ‘by meter’ ，如果他不打表，那么要提前讲好价，否则容易被宰。或者选择用 Grab 这个打车软件，后来几天我就是用这个的，很方便，不过一定要看准定位，毕竟你们语言不通，司机就是打电话找你你也不知道对方在说什么。</p><h1 id="曼谷"><a href="#曼谷" class="headerlink" title="曼谷"></a>曼谷</h1><p>到酒店收拾了一下，就去跟在芭堤雅新认识的一个也来了曼谷的朋友汇合。在暹罗广场吃了个饭，瞎逛了一会。商场里面竟是豪车，然而可能这辈子都买不起了，悲伤啊。<br><img src="/2018/06/09/thailand-travel-notes/22.jpg" title="商场-曼谷"></p><p>晚上和之前约好的一个妹子去考山路逛了一圈，真的是纯逛了一圈，都没有坐下来喝点东西感受一下气氛。<br><img src="/2018/06/09/thailand-travel-notes/23.jpg" title="考山路-曼谷"></p><h2 id="水上市场"><a href="#水上市场" class="headerlink" title="水上市场"></a>水上市场</h2><p>第二天报了一个水上市场一日游，全程有人接送，懒懒散散的逛了一圈，挺适合我，不用赶时间。里面可以买些小物件，挺好的。<br><img src="/2018/06/09/thailand-travel-notes/24.jpg" title="水上市场-曼谷"></p><p>虽然行程懒散，但时间还是挺长的，晚上看完萤火虫已经八点多了，回酒店休整了一下，然后在附近按了下脚就回酒店睡觉了。</p><h2 id="市区"><a href="#市区" class="headerlink" title="市区"></a>市区</h2><p>第三天在泰国市区逛了一圈，有个地方好多日本人，店里面的点单也都是日文加泰文，可能附近很多日本人定居在这里吧。</p><p>晚上从 phone 逛完，本来打算座 bts 然后再打车回去的，路上却碰到了一排摩的师傅，就上去问了下去考山路多少钱。一个师傅说200，我说太贵，150行不行，他说不行，至少170，我也懒得坎价了，就打算跟他走了。结果有意思的是，不是跟我讲价师傅载我，而是另一个人载我，我还纳闷着呢，结果在我的师傅说我们两个一起送我过去，我一脸懵逼，我这么牛逼吗。然后带上头盔就上了车。那个跟我讲价的师傅就先走了，在我的师傅跟在后面。坐摩的感觉真的是很危险，穿梭在各种车与车之间，好几次我都害怕说这他妈撞了怎么办。庆幸自己戴头盔是一个非常正确的选择。路上还看到了一个bmw的摩托出了车祸，被一辆小轿车撞了，还好人都没事，带了头盔。</p><p>到了一个红灯前，跟我讲价的师傅和在我的师傅在那用泰语说什么，看起来像指路的样子。</p><p>然后讲价的师傅跟我说， I am teacher , I teach him. 才知道，原来他们是兄弟弟弟第一次出来开摩的，我座的就是弟弟骑的，哥哥跟我说我坐的这个是刚新买的摩托。我一看，还真是，本田的踏板摩托。</p><p>曼谷这边基本都是本田丰田，无论轿车或者摩托，目测百分之八十以上都是这两个日本品牌。轿车里面看到了好多思域，别说，还真帅。<br>红灯完了，一群摩的 嗡 的就都冲出去了。那个新司机师傅一直在跟我说什么，然而我一句没听懂，都不知道他说的是泰语还是英语。<br><img src="/2018/06/09/thailand-travel-notes/30.jpg" title="车流中的摩的-曼谷"></p><h2 id="射击"><a href="#射击" class="headerlink" title="射击"></a>射击</h2><p>第四天去附近陆军练习场玩了下射击，真的很爽，那手枪后坐力，bong~ bong~ bong~ 的。玩完那个军官跟我说想不想玩长枪，当然想啊，毕竟淘宝上只有手枪的套餐。不过，50发 M4A1 3200🐖，相当于一发子弹十几块人民币，还是挺贵的，不过想想来都来了，玩！<br>遂打算刷卡，结果人家只收现金，而我只有可怜的 500🐖，无奈就只能回去了。<br><img src="/2018/06/09/thailand-travel-notes/25.jpg" title="射击场-曼谷"><br><img src="/2018/06/09/thailand-travel-notes/26.jpg" title="帅哥-曼谷"></p><p>谁知出门走出去200米就下起了暴雨，我竟然没带伞，尴尬。在路边蹲了一个小时等雨停，雨停了赶紧跑了回去，果然以后出门得看天气预报啊。<br></p><h2 id="交通-1"><a href="#交通-1" class="headerlink" title="交通"></a>交通</h2><p>说说曼谷的交通吧，这边摩的很多，也很方便，因为曼谷的交通非常堵，如果打的的话经常被堵在路上好久，但是座摩的就不一样，很多路都可以走。<br><img src="/2018/06/09/thailand-travel-notes/28.jpg" title="摩托-曼谷"></p><p>不过女生一个人玩的话，不是很推荐座摩的，不怎么安全。如果一定要做摩的记得认准这个小马甲，这种是正规的，每个人身后都写着名字和代号，晚上座摩的的话，可以拍照发家人以免万一。<br>上车一定要带头盔，因为路上看到了有人出了交通事故，要是不带头盔还是很危险的。价格方面，摩的跟打的价格差不多，上车前一定要问价格，一定要砍价,价格水分还是很大的。<br><img src="/2018/06/09/thailand-travel-notes/29.png" title="摩的-曼谷"></p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>第五天早上就用 Grab 打了个车去机场回国了。</p><p>整体下来 9 天 8 晚的样子，花了大概 1.2W. 主要都花在酒店和机票上了，因为一个人出来玩，所以酒店都定的比较好，毕竟安全第一。<br>整体上玩的还是很开心的，人都很亲切，毕竟微笑国度。而且也挺便宜，在那边花钱我也没有什么概念，基本就是大手大脚的花了，比国内便宜多了。</p><p>回国就要继续搬砖了，哈哈。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;泰国&quot;&gt;&lt;a href=&quot;#泰国&quot; class=&quot;headerlink&quot; title=&quot;泰国&quot;&gt;&lt;/a&gt;泰国&lt;/h1&gt;&lt;h2 id=&quot;落地签&quot;&gt;&lt;a href=&quot;#落地签&quot; class=&quot;headerlink&quot; title=&quot;落地签&quot;&gt;&lt;/a&gt;落地签&lt;/h2&gt;&lt;p&gt;我是飞到曼谷素万那普机场，下机后跟着人流直走，头上有指示牌，可以一路走到办理落地签的地方。&lt;br&gt;办理落地签有两个通道，一个普通通道，一个快速通道。快速通道 2200🐖，普通通道 2000🐖。&lt;br&gt;建议走快速通道，能省很多时间。&lt;br&gt;&lt;img src=&quot;/2018/06/09/thailand-travel-notes/1.jpg&quot; title=&quot;机场&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;机场大巴&quot;&gt;&lt;a href=&quot;#机场大巴&quot; class=&quot;headerlink&quot; title=&quot;机场大巴&quot;&gt;&lt;/a&gt;机场大巴&lt;/h2&gt;&lt;p&gt;从扶梯下来，好像是到一楼，然后会看到大巴售票点。&lt;br&gt;&lt;img src=&quot;/2018/06/09/thailand-travel-notes/2.png&quot; title=&quot;机场&quot;&gt;&lt;/p&gt;
&lt;p&gt;然后会看到大巴售票点，就长下图这个样子，有到芭堤雅和华欣的大巴，大概每小时一班车。&lt;br&gt;&lt;img src=&quot;/2018/06/09/thailand-travel-notes/3.jpg&quot; title=&quot;大巴售票点&quot;&gt;&lt;br&gt;然后面向大巴售票点左手边有吃饭的地方，在这个位置。&lt;br&gt;&lt;img src=&quot;/2018/06/09/thailand-travel-notes/4.jpg&quot; title=&quot;机场饭厅&quot;&gt;&lt;/p&gt;
&lt;p&gt;里面东西很便宜，进去要换票，一个人的话100🐖就够了。能吃很多东西，我当时吃了一碗面，一罐可乐，还剩了 15🐖。&lt;br&gt;&lt;img src=&quot;/2018/06/09/thailand-travel-notes/5.jpg&quot; title=&quot;机场&quot;&gt;&lt;br&gt;&lt;img src=&quot;/2018/06/09/thailand-travel-notes/6.jpg&quot; title=&quot;机场&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="https://blog.kisnows.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="游记" scheme="https://blog.kisnows.com/tags/%E6%B8%B8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>2017年终总结</title>
    <link href="https://blog.kisnows.com/2018/03/28/2017-year-end-summary/"/>
    <id>https://blog.kisnows.com/2018/03/28/2017-year-end-summary/</id>
    <published>2018-03-28T06:03:41.000Z</published>
    <updated>2018-06-09T07:56:32.438Z</updated>
    
    <content type="html"><![CDATA[<h1 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h1><p>年初，公司经历大的变动，整个理财业务线都干掉了，一大批人转岗的转岗、离职的离职。前端技术部这里，人也走了几个，六楼本来 5 个前端，最后只剩下了 3 个。原来的项目也都不做了，开始做的新的项目网易白条。风风火火做了将近一年，现在产品的数字还比较好看，年后就会上公开申请制对外正式开放，前景还是不错的。</p><p>只是，现在楼上两个前端年后又要走一个人，流动性那么大，没有一点归属感。加上阿里很多部门给我打电话让我过去面试，想想网易比较低的工资，有时候都有点动心，但还是一一拒绝了。起码在网易待满三年，好好沉淀一下。也磨练一下自己的性子，否则天天换工作，也不利于长久的职业发展。只是最近新上的区块链项目，虽然我没参与，但能让我感觉整个部门非常的浮躁，又在犹豫呆下去是否是正确的。</p><h1 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h1><p>今年整体上还是过的像一碗白开水，中间偶有放点糖，但很快也就没有味道。</p><p>身体上已经明显能感觉到开始横向发展了，体重上了五六公斤，但是身体素质却下降了，引体向上只能做一个，我的天呐，大学的时候好歹也能轻松做十个的，这衰减的也太快了。说要锻炼身体，然而基本上只停留在嘴上，锻炼一次中间能间隔一个月，哈哈。</p><p>有时候觉得无聊，就想给自己培养个爱好，想来想去最后决定学个口琴，投入小，见效快。然后就买琴网上找教程，刚开始的几个月，还比较上心，基本天天练习，到现在不复杂的曲子都可以吹，而且自我感觉还不错。就是因为学的是布鲁斯口琴，低音的 6 需要压音，到现在也不能很好的压出好听的声音，更别提融入到曲子中去了，还需要继续练习啊。现在最喜欢的吹的曲子有两个，一个是 《alone》 一个是 《you are my sunshine》，心情不好的时候就自己吹给自己听。</p><h2 id="日本旅游"><a href="#日本旅游" class="headerlink" title="日本旅游"></a>日本旅游</h2><p>11 月左右，公司组织我们出国旅游，有三个地方可选：日本、塞班岛、澳洲。最后我选了日本，也是第一次出国，还是很开心。</p><p>去了北海道，日本的大农村，第一天入住的小镇下午五点大街上就一个人都没有了，跟同事出逛了一圈最后发现酒店附近的居酒屋七点以后开门。一群人进去想去感受日本当地的居酒屋文化，只是老板就一个人，而且跟我们语言不通，完全照顾不过来，看起来有点不是很开心的样子，不过我们喝的倒是很开心。</p><p>第二天去的第一个景点就是个动物园，这也是我第一次去动物园，看到了企鹅、狼、海豹、河马、长颈鹿，就是出来的时候差点掉队找不到组织。</p><p>后来又去了北海道厅、洞爷湖、熊厂、地狱谷、当天晚上入住的洞爷湖酒店环境真好。</p><img src="/2018/03/28/2017-year-end-summary/landscape.jpg" title="洞爷湖酒店"><p>中间还去了哪都忘了，最后落脚在札幌市区，然后第二天自由活动。白天逛街买东西，几个大商场同事们都买了好多东西，都是土豪啊，哈哈。</p><p>期间有件很意思的事情，我想买个 SONY 1000x ，结果和售货员就这个耳机的输入电压是多少沟通了好久，用各种翻译软件都不行，说英语不行、说汉语也不行。<br><a id="more"></a><br>最后还是找了个湾湾过来，才成功的解决了输入电压的问题，人家是 usb 充电的，不牵扯 110v 还是 220v，然后才成功买到了耳机。</p><p>晚上和同事一起点了个 2w 日元的帝王蟹，看起来很不错，只是实在不怎么好吃。后来还上了电视塔，看了看札幌全貌。</p><p>整个日本一周游，也就到这结束了，玩的很开心。</p><h2 id="换房子"><a href="#换房子" class="headerlink" title="换房子"></a>换房子</h2><p>年末，房子到期。房东要把房租从 5000 涨到 6500 ，我的天呐，30% 的涨幅，去年我年度绩效是 A 也就 10% 的工资涨幅。这一看，住不下去了。就和几个合租的室友商量了一下，不租了。</p><p>好吧，又是 TMD 的换房子，真 TM 烦。</p><p>由于时间比较紧急，只有两个周末时间。所以看的房子也不多，一开始想的说找个好一点的小区，不住这些吹拉弹唱的回迁房了。然后看了几个高端小区的房子，结果大多都是隔断，而且价格还很坑爹。没办法，就继续在园小区附近找。房源不是很多，我们周末两天就去各个小区门口贴的小广告上找房子，最后的周末看了三个房子。两个都在路边，太吵，但其他环境还行。一个不靠路，但是在一楼，看房的时候挺安静的。当时就选了这个一楼的看起来挺安静的房子，然而这一切都是噩梦的开始啊。</p><img src="/2018/03/28/2017-year-end-summary/me.jpg" title="搬家"><p>搬进去睡的第一天，早上我突然听到一个陌生的声音在我耳边说话，我还以为房间来了什么人，吓了一跳。睁眼一看，一个人都没有，但说话的声音还在持续。拉开帘子一看窗外，我靠，小区起的早的人在楼下聊天，由于住在一楼，而且房子的单层玻璃隔音效果非常差，那声音就跟在我跟前说话差不多。当时都有点崩溃了，看来懒觉以后都睡不了了。而且，最近三月份左右，房间很潮，每天晚上躺床上的时候都能感觉到褥子潮潮的，睡着非常不舒服。这几天就找了个除湿器放房间里面除潮。新租的的房子搬进来也差不多两个月了，得出的结论就是，一楼的房子真心不适合居住啊。</p><h2 id="感情"><a href="#感情" class="headerlink" title="感情"></a>感情</h2><p>反正很曲折就是了，懒得说。</p><h1 id="去年的目标"><a href="#去年的目标" class="headerlink" title="去年的目标"></a>去年的目标</h1><ol><li>每个月至少一篇博客</li><li>每个月都要出去走走，哪怕一个人</li><li>书还是要看的，那就三个月一本书吧</li><li>身体还是要锻炼的，心里有这个事情就行</li><li>写一个个人项目，并发布出来，无论项目多水</li></ol><p>去年的目标也就完成了 50% 的样子，1 没完成、2 完成了、3 完成了、4 只能算偶尔会想起来、 5 写了个自动交易程序，确实够水，不过也算完成了。总体执行力实在是有点差，指定的计划基本很难执行。</p><p>这工作也快四年了，已经没有太大的心劲了，总觉得缺乏动力。所以今年就一个目标，给自己找点动力，具体下来，那就是找个女朋友，结束单身狗的生活。</p><p>PS： 一个年终总结拖了几个月， 2018 都过去 1/3 才勉强凑出来，实在是烦心的事情太多了，总之就这样吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;工作&quot;&gt;&lt;a href=&quot;#工作&quot; class=&quot;headerlink&quot; title=&quot;工作&quot;&gt;&lt;/a&gt;工作&lt;/h1&gt;&lt;p&gt;年初，公司经历大的变动，整个理财业务线都干掉了，一大批人转岗的转岗、离职的离职。前端技术部这里，人也走了几个，六楼本来 5 个前端，最后只剩下了 3 个。原来的项目也都不做了，开始做的新的项目网易白条。风风火火做了将近一年，现在产品的数字还比较好看，年后就会上公开申请制对外正式开放，前景还是不错的。&lt;/p&gt;
&lt;p&gt;只是，现在楼上两个前端年后又要走一个人，流动性那么大，没有一点归属感。加上阿里很多部门给我打电话让我过去面试，想想网易比较低的工资，有时候都有点动心，但还是一一拒绝了。起码在网易待满三年，好好沉淀一下。也磨练一下自己的性子，否则天天换工作，也不利于长久的职业发展。只是最近新上的区块链项目，虽然我没参与，但能让我感觉整个部门非常的浮躁，又在犹豫呆下去是否是正确的。&lt;/p&gt;
&lt;h1 id=&quot;生活&quot;&gt;&lt;a href=&quot;#生活&quot; class=&quot;headerlink&quot; title=&quot;生活&quot;&gt;&lt;/a&gt;生活&lt;/h1&gt;&lt;p&gt;今年整体上还是过的像一碗白开水，中间偶有放点糖，但很快也就没有味道。&lt;/p&gt;
&lt;p&gt;身体上已经明显能感觉到开始横向发展了，体重上了五六公斤，但是身体素质却下降了，引体向上只能做一个，我的天呐，大学的时候好歹也能轻松做十个的，这衰减的也太快了。说要锻炼身体，然而基本上只停留在嘴上，锻炼一次中间能间隔一个月，哈哈。&lt;/p&gt;
&lt;p&gt;有时候觉得无聊，就想给自己培养个爱好，想来想去最后决定学个口琴，投入小，见效快。然后就买琴网上找教程，刚开始的几个月，还比较上心，基本天天练习，到现在不复杂的曲子都可以吹，而且自我感觉还不错。就是因为学的是布鲁斯口琴，低音的 6 需要压音，到现在也不能很好的压出好听的声音，更别提融入到曲子中去了，还需要继续练习啊。现在最喜欢的吹的曲子有两个，一个是 《alone》 一个是 《you are my sunshine》，心情不好的时候就自己吹给自己听。&lt;/p&gt;
&lt;h2 id=&quot;日本旅游&quot;&gt;&lt;a href=&quot;#日本旅游&quot; class=&quot;headerlink&quot; title=&quot;日本旅游&quot;&gt;&lt;/a&gt;日本旅游&lt;/h2&gt;&lt;p&gt;11 月左右，公司组织我们出国旅游，有三个地方可选：日本、塞班岛、澳洲。最后我选了日本，也是第一次出国，还是很开心。&lt;/p&gt;
&lt;p&gt;去了北海道，日本的大农村，第一天入住的小镇下午五点大街上就一个人都没有了，跟同事出逛了一圈最后发现酒店附近的居酒屋七点以后开门。一群人进去想去感受日本当地的居酒屋文化，只是老板就一个人，而且跟我们语言不通，完全照顾不过来，看起来有点不是很开心的样子，不过我们喝的倒是很开心。&lt;/p&gt;
&lt;p&gt;第二天去的第一个景点就是个动物园，这也是我第一次去动物园，看到了企鹅、狼、海豹、河马、长颈鹿，就是出来的时候差点掉队找不到组织。&lt;/p&gt;
&lt;p&gt;后来又去了北海道厅、洞爷湖、熊厂、地狱谷、当天晚上入住的洞爷湖酒店环境真好。&lt;/p&gt;
&lt;img src=&quot;/2018/03/28/2017-year-end-summary/landscape.jpg&quot; title=&quot;洞爷湖酒店&quot;&gt;
&lt;p&gt;中间还去了哪都忘了，最后落脚在札幌市区，然后第二天自由活动。白天逛街买东西，几个大商场同事们都买了好多东西，都是土豪啊，哈哈。&lt;/p&gt;
&lt;p&gt;期间有件很意思的事情，我想买个 SONY 1000x ，结果和售货员就这个耳机的输入电压是多少沟通了好久，用各种翻译软件都不行，说英语不行、说汉语也不行。&lt;br&gt;
    
    </summary>
    
      <category term="随笔" scheme="https://blog.kisnows.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="年终总结" scheme="https://blog.kisnows.com/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>indexedDB 不完全指南</title>
    <link href="https://blog.kisnows.com/2017/12/06/step-into-indexdb/"/>
    <id>https://blog.kisnows.com/2017/12/06/step-into-indexdb/</id>
    <published>2017-12-06T06:49:52.000Z</published>
    <updated>2018-07-28T12:29:22.741Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>引用 MDN 的介绍：</p><blockquote><p>IndexedDB 是一个事务型数据库系统，类似于基于 SQL 的 RDBMS。 然而不同的是它使用固定列表，IndexedDB是一个基于JavaScript的面向对象的数据库。 IndexedDB允许您存储和检索用键索引的对象; 可以存储structured clone algorithm支持的任何对象。 您只需要指定数据库模式，打开与数据库的连接，然后检索和更新一系列事务中的数据。</p></blockquote><blockquote><p>IndexedDB 是一种低级API，用于客户端存储大量结构化数据(包括, 文件/ blobs)。该API使用索引来实现对该数据的高性能搜索。虽然 Web Storage 对于存储较少量的数据很有用，但对于存储更大量的结构化数据来说，这种方法不太有用。IndexedDB 提供了一个解决方案。</p></blockquote><h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><p>这是我整理的 WebStorage 和 indexedDB 的之间区别，有问题的地方还请指出。<br><img src="/2017/12/06/step-into-indexdb/diff.png" title="indexedDB和WebStorage的区别"></p><h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><h2 id="1-打开数据库"><a href="#1-打开数据库" class="headerlink" title="1. 打开数据库"></a>1. 打开数据库</h2><a id="more"></a><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> DB_NAME = <span class="string">'Netease'</span></span><br><span class="line"><span class="keyword">const</span> DB_VERSION = <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> OB_NAMES = &#123;</span><br><span class="line">  UseKeyPath: <span class="string">'UseKeyPath'</span>,</span><br><span class="line">  UseKeyGenerator: <span class="string">'UseKeyGenerator'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * <span class="doctag">NOTE:</span></span></span><br><span class="line"><span class="comment">  * 1. 第一次打开可能会提示用户获取 indexedDB 的权限</span></span><br><span class="line"><span class="comment">  * 2. 浏览器隐身模式不会存在本地，只会存储在内存中</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">const</span> request = <span class="built_in">window</span>.indexedDB.open(DB_NAME, DB_VERSION)</span><br></pre></td></tr></table></figure><p><code>indexedDB.open</code> 接收两个参数，分别为数据库名称和版本，返回的是一个 <code>IDBOpenDBRequest</code> 对象。可以以 DOM 事件的方式监听它的 success 和 error 来获取到它的结果。几乎所有对 indexedDB 的异步操作都是这种以事件的方式进行，返回一个拥有结果或错误的 <code>IDBRequest</code> 对象。在这里，<code>open</code> 方法得到的结果是一个 <code>IDBDatabase</code> 的实例。</p><p>第二个参数是数据库的版本。版本决定了数据库的模式：存储在里面的 object store 和它们的结构。当第一次通过 <code>open</code> 方法打开数据库时，会触发一个 <code>onupgradeneeded</code> 事件，我们可以也只能在这里设置数据库模式。当数据库已经存在，而我们打开一个更高版本时，同样会触发 <code>onupgradeneeded</code>  事件，用来更新数据库模式。</p><h3 id="添加处理方法"><a href="#添加处理方法" class="headerlink" title="添加处理方法"></a>添加处理方法</h3><p>我们可以通过监听它的 <code>success</code>, <code>error</code> 以及 <code>upgradeneeded</code> 事件来做相应的操作。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">request.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Do something with request.errorCode!</span></span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">'open request failed'</span>,event.target.error)</span><br><span class="line">&#125;</span><br><span class="line">request.onsuccess = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Do something with request.result!</span></span><br><span class="line">  <span class="comment">// console.log('open request success', event)</span></span><br><span class="line">  <span class="keyword">var</span> db = event.target.result</span><br><span class="line">  db.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">'Database error: '</span>, e.target.error)</span><br><span class="line">  &#125;</span><br><span class="line">  db.onclose = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">'Database close:'</span>, e.target.error)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以在 <code>success</code> 事件里面拿到 db 对象，这个是后续操作的主体。</p><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>由于是基于 DOM 事件模式的，所以所有的错误是会冒泡的。也就是说在一个特定 request 的上引发的错误会依次冒泡到事务，然后到 db 对象。<br>如果为了简化错误处理，可以直接在 db 对象上添加错误处理：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">db.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 可以处理这个数据库上所有的错误</span></span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">'Database error: '</span>, e.target.error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-创建或更新数据库版本"><a href="#2-创建或更新数据库版本" class="headerlink" title="2. 创建或更新数据库版本"></a>2. 创建或更新数据库版本</h2><p>前面已经说过，当创建或者增大数据库版本的时候，会触发 <code>onupgradeneeded</code> 事件。在事件内部，可以拿到 db 对象来创建或更新 object store , 具体如下。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">    request.onupgradeneeded = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * <span class="doctag">NOTE:</span></span></span><br><span class="line"><span class="comment">       * 1. 创建新的 objectStore</span></span><br><span class="line"><span class="comment">       * 2. 删除旧的不需要的 objectStore</span></span><br><span class="line"><span class="comment">       * 3. 如果需要更新已有 objectStore 的结构，需要先删除原有的 objectStore ，然后重新创建</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="comment">// The IDBDatabase interface</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'onupgradeneeded'</span>, event)</span><br><span class="line">      <span class="keyword">var</span> db = event.target.result</span><br><span class="line">      <span class="comment">// Create an objectStore for this database</span></span><br><span class="line">      <span class="keyword">const</span> objectStore = db.createObjectStore(OB_NAMES.UseKeyPath, &#123;</span><br><span class="line">        keyPath: <span class="string">'time'</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2 id="3-构建数据库"><a href="#3-构建数据库" class="headerlink" title="3. 构建数据库"></a>3. 构建数据库</h2><p>indexedDB 是以对象存储（object store）而不是以表结构存储的，一个数据库可以存储任意多个存储对象。每当有一个值存储在 object store 里面，就必须和一个 key 关联起来。有几种提供 key 的方法，取决于 object store 使用 <strong>key path</strong> 还是 <strong>key generator</strong>.</p><p>它们之间区别，借用 MDN 的一个表格来看一下：</p><table><thead><tr><th>Key Path (keyPath)</th><th>Key Generator (autoIncrement)</th><th>Description</th></tr></thead><tbody><tr><td>No</td><td>No</td><td>This object store can hold any kind of value, even primitive values like numbers and strings. You must supply a separate key argument whenever you want to add a new value.</td></tr><tr><td>Yes</td><td>No</td><td>This object store can only hold JavaScript objects. The objects must have a property with the same name as the key path.</td></tr><tr><td>No</td><td>Yes</td><td>This object store can hold any kind of value. The key is generated for you automatically, or you can supply a separate key argument if you want to use a specific key.</td></tr><tr><td>Yes</td><td>Yes</td><td>This object store can only hold JavaScript objects. Usually a key is generated and the value of the generated key is stored in the object in a property with the same name as the key path. However, if such a property already exists, the value of that property is used as key rather than generating a new key.</td></tr></tbody></table><p>来自 <a href="https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API/Using_IndexedDB" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API/Using_IndexedDB</a> </p><p>当存储的是不是基础类型而是 js 对象的时候，我们还可以给 object store 创建索引，这样就可以通过索引属性来查找某一个具体的对象。而且， 索引还能再一定程度上约束要存储的对象。当创建索引的时候通过设置唯一标识，可以确保不会存储拥有两个相同索引值的对象。<br>看一个例子，假设我们有如下日志数据需要存储：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> TestData = [</span><br><span class="line">  &#123;</span><br><span class="line">    event: <span class="string">'NE-TEST1'</span>,</span><br><span class="line">    level: <span class="string">'warning'</span>,</span><br><span class="line">    errorCode: <span class="number">200</span>,</span><br><span class="line">    url: <span class="string">'http://www.example.com'</span>,</span><br><span class="line">    time: <span class="string">'2017/11/8 下午4:53:039'</span>,</span><br><span class="line">    isUploaded: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    event: <span class="string">'NE-TEST2'</span>,</span><br><span class="line">    msg: <span class="string">'测试2'</span>,</span><br><span class="line">    level: <span class="string">'error'</span>,</span><br><span class="line">    errorCode: <span class="number">1000</span>,</span><br><span class="line">    url: <span class="string">'http://www.example.com'</span>,</span><br><span class="line">    time: <span class="string">'2017/11/8 下午4:53:042'</span>,</span><br><span class="line">    isUploaded: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    event: <span class="string">'NE-TEST3'</span>,</span><br><span class="line">    msg: <span class="string">'测试3'</span>,</span><br><span class="line">    level: <span class="string">'info'</span>,</span><br><span class="line">    errorCode: <span class="number">3000</span>,</span><br><span class="line">    url: <span class="string">'http://www.example.com'</span>,</span><br><span class="line">    time: <span class="string">'2017/11/8 下午4:53:043'</span>,</span><br><span class="line">    isUploaded: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    event: <span class="string">'NE-TEST4'</span>,</span><br><span class="line">    mgs: <span class="string">'测试4'</span>,</span><br><span class="line">    level: <span class="string">'info'</span>,</span><br><span class="line">    url: <span class="string">'http://www.example.com'</span>,</span><br><span class="line">    time: <span class="string">'2017/11/8 下午4:53:0423'</span>,</span><br><span class="line">    isUploaded: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这里有两种存储方式，分别是通过 key path 和 key generator.</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">obUseKeypath</span> (<span class="params">db</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> objectStore = db.createObjectStore(OB_NAMES.UseKeyPath, &#123;</span><br><span class="line">    keyPath: <span class="string">'time'</span></span><br><span class="line">  &#125;)</span><br><span class="line">  objectStore.createIndex(<span class="string">'errorCode'</span>, <span class="string">'errorCode'</span>, &#123; <span class="attr">unique</span>: <span class="literal">false</span> &#125;)</span><br><span class="line">  objectStore.createIndex(<span class="string">'level'</span>, <span class="string">'level'</span>, &#123; <span class="attr">unique</span>: <span class="literal">false</span> &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">obUseKeyGenerator</span> (<span class="params">db</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> objectStore = db.createObjectStore(OB_NAMES.UseKeyGenerator, &#123;</span><br><span class="line">    autoIncrement: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">  objectStore.createIndex(<span class="string">'errorCode'</span>, <span class="string">'errorCode'</span>, &#123; <span class="attr">unique</span>: <span class="literal">false</span> &#125;)</span><br><span class="line">  objectStore.createIndex(<span class="string">'time'</span>, <span class="string">'time'</span>, &#123; <span class="attr">unique</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">  objectStore.createIndex(<span class="string">'level'</span>, <span class="string">'level'</span>, &#123; <span class="attr">unique</span>: <span class="literal">false</span> &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-增删改查"><a href="#4-增删改查" class="headerlink" title="4. 增删改查"></a>4. 增删改查</h2><p>为了方便介绍这部分的内容，我们先把上一节的代码包装一下，为了方便后续例子的讲解：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">openindexedDB</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// The call to the open() function returns an IDBOpenDBRequest object with a result (success) or error value that you handle as an event.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">NOTE:</span></span></span><br><span class="line"><span class="comment">     * 1. 第一次打开可能会提示用户获取 indexedDB 的权限</span></span><br><span class="line"><span class="comment">     * 2. 浏览器隐身模式不会存在本地，只会存储在内存中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">const</span> request = <span class="built_in">window</span>.indexedDB.open(DB_NAME, DB_VERSION)</span><br><span class="line">    request.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// Do something with request.errorCode!</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'open request failed'</span>, event)</span><br><span class="line">      <span class="built_in">console</span>.error(event.target.error)</span><br><span class="line">    &#125;</span><br><span class="line">    request.onsuccess = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// Do something with request.result!</span></span><br><span class="line">      <span class="comment">// console.log('open request success', event)</span></span><br><span class="line">      <span class="keyword">var</span> db = event.target.result</span><br><span class="line">      db.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.error(<span class="string">'Database error: '</span>, e.target.error)</span><br><span class="line">        reject(e.target.error)</span><br><span class="line">      &#125;</span><br><span class="line">      db.onclose = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(<span class="string">'Database close:'</span>, e.target.error)</span><br><span class="line">        reject(e.target.error)</span><br><span class="line">      &#125;</span><br><span class="line">      resolve(db)</span><br><span class="line">    &#125;</span><br><span class="line">    request.onupgradeneeded = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * <span class="doctag">NOTE:</span></span></span><br><span class="line"><span class="comment">       * 1. 创建新的 objectStore</span></span><br><span class="line"><span class="comment">       * 2. 删除旧的不需要的 objectStore</span></span><br><span class="line"><span class="comment">       * 3. 如果需要更新已有 objectStore 的结构，需要先删除原有的 objectStore ，然后重新创建</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="comment">// The IDBDatabase interface</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'onupgradeneeded'</span>, event)</span><br><span class="line">      <span class="keyword">var</span> db = event.target.result</span><br><span class="line">      <span class="comment">// Create an objectStore for this database</span></span><br><span class="line">      obUseKeypath(db)</span><br><span class="line">      obUseKeyGenerator(db)</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * <span class="doctag">NOTE:</span></span></span><br><span class="line"><span class="comment">       * transaction</span></span><br><span class="line"><span class="comment">       * 三个事件：</span></span><br><span class="line"><span class="comment">       * 1. error</span></span><br><span class="line"><span class="comment">       * 2. abort</span></span><br><span class="line"><span class="comment">       * 3. complete</span></span><br><span class="line"><span class="comment">       * 两个方法：</span></span><br><span class="line"><span class="comment">       * 1. abort</span></span><br><span class="line"><span class="comment">       * Rolls back all the changes to objects in the database associated with this transaction. If this transaction has been aborted or completed, then this method throws an error event.</span></span><br><span class="line"><span class="comment">       * 2. objectStore</span></span><br><span class="line"><span class="comment">       * Returns an IDBObjectStore object representing an object store that is part of the scope of this transaction.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      db.transaction.oncomplete = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'obj create success'</span>, e)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">obUseKeypath</span> (<span class="params">db</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> objectStore = db.createObjectStore(OB_NAMES.UseKeyPath, &#123;</span><br><span class="line">    keyPath: <span class="string">'time'</span></span><br><span class="line">  &#125;)</span><br><span class="line">  objectStore.createIndex(<span class="string">'errorCode'</span>, <span class="string">'errorCode'</span>, &#123; <span class="attr">unique</span>: <span class="literal">false</span> &#125;)</span><br><span class="line">  objectStore.createIndex(<span class="string">'level'</span>, <span class="string">'level'</span>, &#123; <span class="attr">unique</span>: <span class="literal">false</span> &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">obUseKeyGenerator</span> (<span class="params">db</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> objectStore = db.createObjectStore(OB_NAMES.UseKeyGenerator, &#123;</span><br><span class="line">    autoIncrement: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">  objectStore.createIndex(<span class="string">'errorCode'</span>, <span class="string">'errorCode'</span>, &#123; <span class="attr">unique</span>: <span class="literal">false</span> &#125;)</span><br><span class="line">  objectStore.createIndex(<span class="string">'time'</span>, <span class="string">'time'</span>, &#123; <span class="attr">unique</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">  objectStore.createIndex(<span class="string">'level'</span>, <span class="string">'level'</span>, &#123; <span class="attr">unique</span>: <span class="literal">false</span> &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样每次我们需要对数据库做操作的话只需要调用 <code>openindexedDB</code> 方法就可以了。</p><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>所有对数据库的操作都是建立在事务(transaction)上的，有三种模式(mode)：<code>readonly</code>, <code>readewrite</code>, <code>versionchange</code>.<br>要修改数据库结构的 <strong>schema</strong> ，必须在 <code>versionchange</code> 模式下。读取和修改对应另外两种模式。<br>通过 <code>IDBDatabase.transaction</code> 打开一个 <code>transaction</code>, 接收两个参数：<code>storeNames</code>, <code>mode</code>.<br>所有对数据库的操作都遵循以下流程：</p><ol><li>Get database object</li><li>Open transaction on database</li><li>Open object store on transaction</li><li>Perform operation on object store</li></ol><p>加速事务操作：</p><ul><li>当定义作用域时（scope）， 只定义需要的 object stores. 这样，就可以在不重叠的作用域上并行的执行多个事务。</li><li>只有在需要的时候才开启一个 readwrite 事务。因为在重叠的作用域上可以并发执行多个 readonly 事务，但只能有一个 readwrite 事务。</li></ul><h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><p>方法如下：</p><ol><li>首先拿到 db 对象</li><li>然后打开一个 <code>readwrite</code> 事务</li><li>通过事务拿到 object store 对象</li><li>执行添加数据操作</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 添加数据</span></span><br><span class="line"><span class="comment">* @param &#123;array&#125; docs 要添加数据</span></span><br><span class="line"><span class="comment">* @param &#123;string&#125; objName 仓库名称</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addData</span> (<span class="params">docs, objName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!(docs &amp;&amp; docs.length)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'docs must be a array!'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> openindexedDB().then(<span class="function"><span class="params">db</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> tx = db.transaction([objName], <span class="string">'readwrite'</span>)</span><br><span class="line">    tx.oncomplete = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'tx:addData onsuccess'</span>, e)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(docs)</span><br><span class="line">    &#125;</span><br><span class="line">    tx.onerror = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">      e.stopPropagation()</span><br><span class="line">      <span class="built_in">console</span>.error(<span class="string">'tx:addData onerror'</span>, e.target.error)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(e.target.error)</span><br><span class="line">    &#125;</span><br><span class="line">    tx.onabort = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.warn(<span class="string">'tx:addData abort'</span>, e.target)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(e.target.error)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> obj = tx.objectStore(objName)</span><br><span class="line">    docs.forEach(<span class="function"><span class="params">doc</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> req = obj.add(doc)</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * <span class="doctag">NOTE:</span></span></span><br><span class="line"><span class="comment">       * request</span></span><br><span class="line"><span class="comment">       * 两个事件：</span></span><br><span class="line"><span class="comment">       * 1. success</span></span><br><span class="line"><span class="comment">       * 2. error</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="comment">// req.onsuccess = e =&gt; console.log('obj:addData onsuccess', e.target)</span></span><br><span class="line">      req.onerror = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(<span class="string">'obj:addData onerror'</span>, e.target.error)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要把上面的 TestData 同时使用 key generator 和 key path 方式保存到数据库中，那么方法：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">addData(TestData, OB_NAMES.UseKeyGenerator)</span><br><span class="line">.then(<span class="function"><span class="params">()</span> =&gt;</span> addData(TestData, OB_NAMES.UseKeyPath))</span><br></pre></td></tr></table></figure><h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><p>流程和添加一样：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 删除指定 key 的数据</span></span><br><span class="line"><span class="comment">* @param &#123;string&#125; objName 仓库名称</span></span><br><span class="line"><span class="comment">* @param &#123;*&#125; key 要删除数据的 primary key 值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deleteData</span> (<span class="params">objName, key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> openindexedDB().then(<span class="function"><span class="params">db</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> tx = db.transaction([objName], <span class="string">'readwrite'</span>)</span><br><span class="line">    <span class="keyword">const</span> obj = tx.objectStore(objName)</span><br><span class="line">    <span class="keyword">const</span> req = obj.delete(key)</span><br><span class="line">    req.onsuccess = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`readData success. key:<span class="subst">$&#123;key&#125;</span>,result:`</span>, e.target.result)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(e.target.result)</span><br><span class="line">    &#125;</span><br><span class="line">    req.onerror = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(<span class="string">`readData error. key:<span class="subst">$&#123;key&#125;</span>,error: <span class="subst">$&#123;e.target.errorCode&#125;</span>`</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(e.target.error)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假如要删除 <code>UserKeyGenerator</code> 里 key 为 1 值，那么：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">deleteData(OB_NAMES.UseKeyGenerator, <span class="number">1</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">doc</span> =&gt;</span> <span class="built_in">console</span>.log(doc))</span><br></pre></td></tr></table></figure><h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><p>方法：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 读取给定 key 的数据</span></span><br><span class="line"><span class="comment">* @param &#123;string&#125; objName 仓库名称</span></span><br><span class="line"><span class="comment">* @param &#123;*&#125; key 要读取数据的 primary key 值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readData</span> (<span class="params">objName, key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> openindexedDB().then(<span class="function"><span class="params">db</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> tx = db.transaction([objName])</span><br><span class="line">    <span class="keyword">const</span> obj = tx.objectStore(objName)</span><br><span class="line">    <span class="keyword">const</span> req = obj.get(key)</span><br><span class="line">    req.onsuccess = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`readData success. key:<span class="subst">$&#123;key&#125;</span>,result:`</span>, e.target.result)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(e.target.result)</span><br><span class="line">    &#125;</span><br><span class="line">    req.onerror = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(<span class="string">`readData error. key:<span class="subst">$&#123;key&#125;</span>,error: <span class="subst">$&#123;e.target.errorCode&#125;</span>`</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(e.target.error)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">readData(OB_NAMES.UseKeyGenerator, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3><p>方法：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 更新指定 key 的数据</span></span><br><span class="line"><span class="comment">* @param &#123;string&#125; objName 仓库名称</span></span><br><span class="line"><span class="comment">* @param &#123;*&#125; key 指定的 key</span></span><br><span class="line"><span class="comment">* @param &#123;object&#125; changes 要修改的属性值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateData</span> (<span class="params">objName, key, changes</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> openindexedDB().then(<span class="function"><span class="params">db</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> tx = db.transaction([objName], <span class="string">'readwrite'</span>)</span><br><span class="line">      <span class="keyword">const</span> obj = tx.objectStore(objName)</span><br><span class="line">      <span class="keyword">const</span> req = obj.get(key)</span><br><span class="line">      req.onsuccess = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> doc = e.target.result</span><br><span class="line">        <span class="keyword">let</span> newDoc = <span class="built_in">Object</span>.assign(doc, changes)</span><br><span class="line">        <span class="keyword">const</span> req = obj.put(newDoc)</span><br><span class="line">        req.onsuccess = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">`updateData success, newDoc:`</span>, newDoc, e)</span><br><span class="line">          resolve(e.target.result)</span><br><span class="line">        &#125;</span><br><span class="line">        req.onerror = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">          resolve(e.target.result)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      req.onerror = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">        reject(e.target.error)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">updateData(OB_NAMES.UseKeyGenerator, <span class="number">1</span>, &#123;<span class="attr">time</span>: <span class="string">'123'</span>&#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">doc</span> =&gt;</span> <span class="built_in">console</span>.log(doc))</span><br><span class="line">  .catch(<span class="built_in">console</span>.error)</span><br></pre></td></tr></table></figure><h3 id="使用游标-cursor"><a href="#使用游标-cursor" class="headerlink" title="使用游标 (cursor)"></a>使用游标 (cursor)</h3><p>使用 get 方法需要预先知道一个 key. 如果需要步进整个 object store 的值，那么可以使用 cursor. </p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 通过 cursor 获取制定仓库下的所有数据</span></span><br><span class="line"><span class="comment">* @param &#123;string&#125; objName 仓库名称</span></span><br><span class="line"><span class="comment">* @param &#123;function&#125; [cb] 回调函数，对每次得到的 cursor 进行操作</span></span><br><span class="line"><span class="comment">* @returns &#123;Promise.&lt;array.&lt;object&gt;&#125; 包含所有数据的数组</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAllByCursor</span> (<span class="params">objName, cb</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> openindexedDB().then(<span class="function"><span class="params">db</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> arr = []</span><br><span class="line">    <span class="keyword">const</span> tx = db.transaction([objName])</span><br><span class="line">    <span class="keyword">const</span> obj = tx.objectStore(objName)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">      obj.openCursor().onsuccess = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> cursor = e.target.result</span><br><span class="line">        <span class="keyword">if</span> (cursor) &#123;</span><br><span class="line">          arr.push(cursor.value)</span><br><span class="line">          cb &amp;&amp; cb(cursor)</span><br><span class="line">          cursor.continue()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> resolve(arr)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>openCursor()</code> 方法接收多个参数。</p><ul><li>第一个参数，可以传入一个 key range 对象来限制需要获取值的范围。</li><li>第二个参数，可以设置迭代的方向。</li></ul><p>成功回调函数的 <code>result</code> 值就是 cursor 本身，当前遍历值可以通过 cursor 对象的 <code>key</code> 和 <code>value</code> 值获取。如果要继续往下遍历，那么调用 cursor 的 <code>continue()</code> 方法，当遍历结束时， cursor 也就是 <code>event.target.result</code> 的值为 <code>undefined</code>.<br>如果要获取 UseKeyGenerator 仓库下所有的值，那么可以这样：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getAllByCursor(OB_NAMES.UseKeyGenerator).then(<span class="built_in">console</span>.log)</span><br></pre></td></tr></table></figure><p>除了 <code>openCursor()</code> 外，还可以使用 <code>openKeyCursor()</code> 来获取所有存储对象的主键值，使用方法和 openCursor 一样，</p><h3 id="使用索引-index"><a href="#使用索引-index" class="headerlink" title="使用索引 (index)"></a>使用索引 (index)</h3><p>在建立 object store 时，如果我们给它创建了索引。这时，就可以使用索引来查找某个特定属性的值：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getByIndex</span> (<span class="params">objName, indexName, key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> openindexedDB().then(<span class="function"><span class="params">db</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> index = db.transaction(objName).objectStore(objName).index(indexName)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">      index.get(key).onsuccess = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'getByIndex'</span>, e.target.result)</span><br><span class="line">        <span class="keyword">return</span> resolve(e.target.result)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如，我们要查找 <code>level</code> 为 <code>info</code> 的日志，那么可以这样:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getByIndex(OB_NAMES.UseKeyGenerator, <span class="string">'level'</span>, <span class="string">'info'</span>).then(<span class="function"><span class="params">doc</span> =&gt;</span></span><br><span class="line">  <span class="built_in">console</span>.log(doc)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="设置范围-range-和游标-cursors-的方向"><a href="#设置范围-range-和游标-cursors-的方向" class="headerlink" title="设置范围 (range) 和游标 (cursors) 的方向"></a>设置范围 (range) 和游标 (cursors) 的方向</h3><p>如果需要设置 cursor 遍历的范围，可以使用 <code>IDBKeyRange</code> 对象并把作为第一个参数给 <code>openCursor()</code> 或者 <code>openKeyCursor()</code> .<br>一个 key range 的值，可以认为是一个区间，区间的类型可以是开区间也可以是闭区间。看一些例子：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">NOTE:</span></span></span><br><span class="line"><span class="comment">* 只包括给定的值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">getWithRangeByCursor( OB_NAMES.UseKeyGenerator,<span class="string">'errorCode'</span>,</span><br><span class="line">  IDBKeyRange.only(<span class="number">1000</span>))</span><br><span class="line">  .then(<span class="built_in">console</span>.log)</span><br><span class="line">  .catch(<span class="built_in">console</span>.error)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">NOTE:</span></span></span><br><span class="line"><span class="comment">* 默认是闭区间</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">getWithRangeByCursor( OB_NAMES.UseKeyGenerator,<span class="string">'errorCode'</span>,</span><br><span class="line">  IDBKeyRange.lowerBound(<span class="number">1000</span>))</span><br><span class="line">  .then(<span class="built_in">console</span>.log)</span><br><span class="line">  .catch(<span class="built_in">console</span>.error)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">NOTE:</span></span></span><br><span class="line"><span class="comment">* 设置第二个可选参数为 true，则为开区间</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">getWithRangeByCursor(OB_NAMES.UseKeyGenerator,<span class="string">'errorCode'</span>,</span><br><span class="line">  IDBKeyRange.lowerBound(<span class="number">1000</span>, <span class="literal">true</span>))</span><br><span class="line">  .then(<span class="built_in">console</span>.log)</span><br><span class="line">  .catch(<span class="built_in">console</span>.error)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">NOTE:</span></span></span><br><span class="line"><span class="comment">* 闭区间，如果索引是数字，那么按照数字大小决定升序</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">getWithRangeByCursor(OB_NAMES.UseKeyGenerator,<span class="string">'errorCode'</span>,</span><br><span class="line">  IDBKeyRange.bound(<span class="number">1000</span>, <span class="number">2000</span>)</span><br><span class="line">)</span><br><span class="line">  .then(<span class="built_in">console</span>.log)</span><br><span class="line">  .catch(<span class="built_in">console</span>.error)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">NOTE:</span></span></span><br><span class="line"><span class="comment">* 左闭右开区间：如果索引是字符串，那么安装 array.sort() 的方式决定升序</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">getWithRangeByCursor(OB_NAMES.UseKeyGenerator,<span class="string">'time'</span>,</span><br><span class="line">  IDBKeyRange.bound(<span class="string">'2017/11/8 下午4:53:042'</span>, <span class="string">'2017/11/8 下午4:53:043'</span>, <span class="literal">false</span>, <span class="literal">true</span>)</span><br><span class="line">)</span><br><span class="line">  .then(<span class="built_in">console</span>.log)</span><br><span class="line">  .catch(<span class="built_in">console</span>.error)</span><br></pre></td></tr></table></figure><h3 id="降序迭代"><a href="#降序迭代" class="headerlink" title="降序迭代"></a>降序迭代</h3><p>默认情况下，迭代的方向是升序的。如果需要按照降序规则迭代，那么只要把 <code>prev</code> 作为 <code>openCursor()</code> 的第二个参数就可以了：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getWithDescendingByCursor(OB_NAMES.UseKeyGenerator, <span class="string">'time'</span>)</span><br><span class="line">  .then(<span class="built_in">console</span>.log)</span><br><span class="line">  .catch(<span class="built_in">console</span>.error)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;引用 MDN 的介绍：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;IndexedDB 是一个事务型数据库系统，类似于基于 SQL 的 RDBMS。 然而不同的是它使用固定列表，IndexedDB是一个基于JavaScript的面向对象的数据库。 IndexedDB允许您存储和检索用键索引的对象; 可以存储structured clone algorithm支持的任何对象。 您只需要指定数据库模式，打开与数据库的连接，然后检索和更新一系列事务中的数据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;IndexedDB 是一种低级API，用于客户端存储大量结构化数据(包括, 文件/ blobs)。该API使用索引来实现对该数据的高性能搜索。虽然 Web Storage 对于存储较少量的数据很有用，但对于存储更大量的结构化数据来说，这种方法不太有用。IndexedDB 提供了一个解决方案。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;区别&quot;&gt;&lt;a href=&quot;#区别&quot; class=&quot;headerlink&quot; title=&quot;区别&quot;&gt;&lt;/a&gt;区别&lt;/h1&gt;&lt;p&gt;这是我整理的 WebStorage 和 indexedDB 的之间区别，有问题的地方还请指出。&lt;br&gt;&lt;img src=&quot;/2017/12/06/step-into-indexdb/diff.png&quot; title=&quot;indexedDB和WebStorage的区别&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;用法&quot;&gt;&lt;a href=&quot;#用法&quot; class=&quot;headerlink&quot; title=&quot;用法&quot;&gt;&lt;/a&gt;用法&lt;/h1&gt;&lt;h2 id=&quot;1-打开数据库&quot;&gt;&lt;a href=&quot;#1-打开数据库&quot; class=&quot;headerlink&quot; title=&quot;1. 打开数据库&quot;&gt;&lt;/a&gt;1. 打开数据库&lt;/h2&gt;
    
    </summary>
    
      <category term="技术" scheme="https://blog.kisnows.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Redux 源码解读（长文慎入）</title>
    <link href="https://blog.kisnows.com/2017/10/14/redux-source-code-read/"/>
    <id>https://blog.kisnows.com/2017/10/14/redux-source-code-read/</id>
    <published>2017-10-14T07:27:47.607Z</published>
    <updated>2017-10-14T07:27:47.607Z</updated>
    
    <content type="html"><![CDATA[<p>Redux 的源码非常的精炼，短短几百行代码，去提供了强大的功能。今天，我们就来一探究竟。</p><p>看源码最简单的方式，就是从入口文件来看，看它依赖哪些模块，然后在依次看这些模块的内容，最后也就对整个代码有个清晰的认识了。</p><p>所以我们就从入口文件开始来看：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> createStore <span class="keyword">from</span> <span class="string">'./createStore'</span></span><br><span class="line"><span class="keyword">import</span> combineReducers <span class="keyword">from</span> <span class="string">'./combineReducers'</span></span><br><span class="line"><span class="keyword">import</span> bindActionCreators <span class="keyword">from</span> <span class="string">'./bindActionCreators'</span></span><br><span class="line"><span class="keyword">import</span> applyMiddleware <span class="keyword">from</span> <span class="string">'./applyMiddleware'</span></span><br><span class="line"><span class="keyword">import</span> compose <span class="keyword">from</span> <span class="string">'./compose'</span></span><br><span class="line"><span class="keyword">import</span> warning <span class="keyword">from</span> <span class="string">'./utils/warning'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* This is a dummy function to check if the function name has been altered by minification.</span></span><br><span class="line"><span class="comment">* If the function has been minified and NODE_ENV !== 'production', warn the user.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isCrushed</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 就是根据 isCrushed 是否被压缩了，来警告开发者正在非生产环境使用一个压缩过的代码。</span></span><br><span class="line"><span class="keyword">if</span> (</span><br><span class="line">  process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp;</span><br><span class="line">  <span class="keyword">typeof</span> isCrushed.name === <span class="string">'string'</span> &amp;&amp;</span><br><span class="line">  isCrushed.name !== <span class="string">'isCrushed'</span></span><br><span class="line">) &#123;</span><br><span class="line">  warning(</span><br><span class="line">    <span class="string">'You are currently using minified code outside of NODE_ENV === \'production\'. '</span> +</span><br><span class="line">    <span class="string">'This means that you are running a slower development build of Redux. '</span> +</span><br><span class="line">    <span class="string">'You can use looseenvify (https://github.com/zertosh/looseenvify) for browserify '</span> +</span><br><span class="line">    <span class="string">'or DefinePlugin for webpack (http://stackoverflow.com/questions/30030031) '</span> +</span><br><span class="line">    <span class="string">'to ensure you have the correct code for your production build.'</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  createStore,</span><br><span class="line">  combineReducers,</span><br><span class="line">  bindActionCreators,</span><br><span class="line">  applyMiddleware,</span><br><span class="line">  compose</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到它依赖了下面这几个模块：</p><ul><li>createStore</li><li>combineReducers</li><li>bindActionCreators</li><li>applyMiddleware</li><li>compose</li><li>warning</li></ul><p>其他没什么说的，就是把一些 API 暴露出去。那我们就先按照这个模块依赖顺序，依次进行解读。</p><h2 id="createStore"><a href="#createStore" class="headerlink" title="createStore"></a>createStore</h2><a id="more"></a><p>首先是<code>createStore</code>， 用来创建整个应用的 store .<br>它的依赖模块，都是些工具函数。</p><ul><li>isPlainObject</li><li>$$observable</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">createStore</span>(<span class="params">reducer, preloadedState, enhancer</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> preloadedState === <span class="string">'function'</span> &amp;&amp; <span class="keyword">typeof</span> enhancer === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    enhancer = preloadedState</span><br><span class="line">    preloadedState = <span class="literal">undefined</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> enhancer !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> enhancer !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected the enhancer to be a function.'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> enhancer(createStore)(reducer, preloadedState)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> reducer !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected the reducer to be a function.'</span>)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这里逻辑很简单：</p><p>第一个 if 语句的意思就是说，如果只传入了两个参数，且第二个参数 preloadedState 为函数，那么就认为第二个参数为 enhancer . </p><p>第二个 if 语句确保 enhancer 是一个函数，并且当 enhancer 作为参数传入的时候，返回 enhancer(createStore)(reucer, preloadedState) 作为 createStore 的返回，也就是我们要的 store.</p><p>第三个 if 语句确保 reducer 是一个函数。</p><p>接着往下看：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> currentReducer = reducer</span><br><span class="line"><span class="keyword">let</span> currentState = preloadedState</span><br><span class="line"><span class="keyword">let</span> currentListeners = []</span><br><span class="line"><span class="keyword">let</span> nextListeners = currentListeners</span><br><span class="line"><span class="keyword">let</span> isDispatching = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ensureCanMutateNextListeners</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (nextListeners === currentListeners) &#123;</span><br><span class="line">    nextListeners = currentListeners.slice()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Reads the state tree managed by the store.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * @returns &#123;any&#125; The current state tree of your application.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getState</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> currentState</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，把 <code>preloadState</code> 赋值给 <code>currentState</code> ，可以使应用直接重现某一个状态，也可以用来做服务端渲染时直接由后台计算出来作为应用的初始状态。</p><p><code>ensureCanMutateNextListeners</code> 这个函数在 <code>nextListeners === currentListeners</code> 成立时把 <code>currentListeners</code> 复制了一份赋值给了 <code>nextListeners</code> . 用来做什么还不太清楚，先放着。</p><p>然后定义了一个获取当前 state 的方法。</p><h3 id="subscribe"><a href="#subscribe" class="headerlink" title="subscribe"></a><code>subscribe</code></h3><p>接下来是一个<code>subscribe</code> 方法。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Adds a change listener. It will be called any time an action is dispatched,</span></span><br><span class="line"><span class="comment">    * and some part of the state tree may potentially have changed. You may then</span></span><br><span class="line"><span class="comment">    * call `getState()` to read the current state tree inside the callback.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * You may call `dispatch()` from a change listener, with the following</span></span><br><span class="line"><span class="comment">    * caveats:</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 1. The subscriptions are snapshotted just before every `dispatch()` call.</span></span><br><span class="line"><span class="comment">    * If you subscribe or unsubscribe while the listeners are being invoked, this</span></span><br><span class="line"><span class="comment">    * will not have any effect on the `dispatch()` that is currently in progress.</span></span><br><span class="line"><span class="comment">    * However, the next `dispatch()` call, whether nested or not, will use a more</span></span><br><span class="line"><span class="comment">    * recent snapshot of the subscription list.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 2. The listener should not expect to see all state changes, as the state</span></span><br><span class="line"><span class="comment">    * might have been updated multiple times during a nested `dispatch()` before</span></span><br><span class="line"><span class="comment">    * the listener is called. It is, however, guaranteed that all subscribers</span></span><br><span class="line"><span class="comment">    * registered before the `dispatch()` started will be called with the latest</span></span><br><span class="line"><span class="comment">    * state by the time it exits.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * @param &#123;Function&#125; listener A callback to be invoked on every dispatch.</span></span><br><span class="line"><span class="comment">    * @returns &#123;Function&#125; A function to remove this change listener.</span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">subscribe</span>(<span class="params">listener</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> listener !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected listener to be a function.'</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> isSubscribed = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    ensureCanMutateNextListeners()</span><br><span class="line">    nextListeners.push(listener)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">unsubscribe</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!isSubscribed) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      isSubscribed = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">      ensureCanMutateNextListeners()</span><br><span class="line">      <span class="keyword">const</span> index = nextListeners.indexOf(listener)</span><br><span class="line">      nextListeners.splice(index, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>注释已经说的非常明白了，注册一个 <code>listener</code> 监听函数，把他 push 到当前的监听里列表 <code>nextListener</code> 里面，并返回一个 <code>unsubscribe</code> 方法用来注销当前这个监听函数。</p><h3 id="dispatch"><a href="#dispatch" class="headerlink" title="dispatch"></a>dispatch</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isPlainObject(action)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">      <span class="string">'Actions must be plain objects. '</span> +</span><br><span class="line">      <span class="string">'Use custom middleware for async actions.'</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> action.type === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">      <span class="string">'Actions may not have an undefined "type" property. '</span> +</span><br><span class="line">      <span class="string">'Have you misspelled a constant?'</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isDispatching) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Reducers may not dispatch actions.'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    isDispatching = <span class="literal">true</span></span><br><span class="line">    currentState = currentReducer(currentState, action)</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    isDispatching = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> listeners = currentListeners = nextListeners</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; listeners.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> listener = listeners[i]</span><br><span class="line">    listener()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> action</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <!-- TODO: --><p>用来分发一个 <code>action</code> 来改变当前的 <strong>state</strong> . 也是唯一的改变 <strong>state</strong> 的方法。接受一个用来描述动作的 <code>action</code> 为参数，并且把这个 <code>action</code> 作为函数的返回值。</p><p>从代码前面的判断可以看到，action 必须是一个字面量对象，并且必须包含一个 <code>type</code> 的属性。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (isDispatching) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Reducers may not dispatch actions.'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这里可以看到，如果当前正处于上一个 <code>action</code> 的分发阶段，那么当前这个 <code>action</code> 有可能会分发失败。</p><p>后面进行当前 <strong>state</strong> 的计算，并且按顺序去触发 <code>nextListeners</code> 里面的监听函数。</p><h3 id="replaceReducer"><a href="#replaceReducer" class="headerlink" title="replaceReducer"></a>replaceReducer</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Replaces the reducer currently used by the store to calculate the state.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * You might need this if your app implements code splitting and you want to</span></span><br><span class="line"><span class="comment">  * load some of the reducers dynamically. You might also need this if you</span></span><br><span class="line"><span class="comment">  * implement a hot reloading mechanism for Redux.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * @param &#123;Function&#125; nextReducer The reducer for the store to use instead.</span></span><br><span class="line"><span class="comment">  * @returns &#123;void&#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">replaceReducer</span>(<span class="params">nextReducer</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> nextReducer !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected the nextReducer to be a function.'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  currentReducer = nextReducer</span><br><span class="line">  dispatch(&#123; <span class="attr">type</span>: ActionTypes.INIT &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>替换掉当前的 reducer 并且分发一个用来初始化的内部 action.</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ActionTypes = &#123;</span><br><span class="line">  INIT: <span class="string">'@@redux/INIT'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="observable"><a href="#observable" class="headerlink" title="observable"></a>observable</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Interoperability point for observable/reactive libraries.</span></span><br><span class="line"><span class="comment">  * @returns &#123;observable&#125; A minimal observable of state changes.</span></span><br><span class="line"><span class="comment">  * For more information, see the observable proposal:</span></span><br><span class="line"><span class="comment">  * https://github.com/tc39/proposalobservable</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observable</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> outerSubscribe = subscribe</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * The minimal observable subscription method.</span></span><br><span class="line"><span class="comment">      * @param &#123;Object&#125; observer Any object that can be used as an observer.</span></span><br><span class="line"><span class="comment">      * The observer object should have a `next` method.</span></span><br><span class="line"><span class="comment">      * @returns &#123;subscription&#125; An object with an `unsubscribe` method that can</span></span><br><span class="line"><span class="comment">      * be used to unsubscribe the observable from the store, and prevent further</span></span><br><span class="line"><span class="comment">      * emission of values from the observable.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    subscribe(observer) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> observer !== <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Expected the observer to be an object.'</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">observeState</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (observer.next) &#123;</span><br><span class="line">          observer.next(getState())</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      observeState()</span><br><span class="line">      <span class="keyword">const</span> unsubscribe = outerSubscribe(observeState)</span><br><span class="line">      <span class="keyword">return</span> &#123; unsubscribe &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    [$$observable]() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用来把一个对象变成可 observe 的方法，一般情况下用不到。</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// When a store is created, an "INIT" action is dispatched so that every</span></span><br><span class="line"><span class="comment">// reducer returns their initial state. This effectively populates</span></span><br><span class="line"><span class="comment">// the initial state tree.</span></span><br><span class="line">dispatch(&#123; <span class="attr">type</span>: ActionTypes.INIT &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">  dispatch,</span><br><span class="line">  subscribe,</span><br><span class="line">  getState,</span><br><span class="line">  replaceReducer,</span><br><span class="line">  [$$observable]: observable</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分发一个 <code>INIT</code> 的初始化 action ，用来让所有的 reducer 来返回默认的初始化 <strong>state</strong>.</p><p>然后把上面的函数返回出来，作为通过 <code>createStore</code> 创建出来的 <strong>store</strong> 的 api.</p><h2 id="combineReducers"><a href="#combineReducers" class="headerlink" title="combineReducers"></a>combineReducers</h2><p>这个模块用来合并多个 reducers 到一个 reducer，它的依赖模块：</p><ul><li>ActionTypes</li><li>isPlainObject</li><li>warning</li></ul><p>我们依次来看看 combineReducers 里面的内容。</p><h3 id="getUndefinedStateErrorMessage"><a href="#getUndefinedStateErrorMessage" class="headerlink" title="getUndefinedStateErrorMessage"></a>getUndefinedStateErrorMessage</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUndefinedStateErrorMessage</span>(<span class="params">key, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> actionType = action &amp;&amp; action.type</span><br><span class="line">  <span class="keyword">const</span> actionName = (actionType &amp;&amp; <span class="string">`"<span class="subst">$&#123;actionType.toString()&#125;</span>"`</span>) || <span class="string">'an action'</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="string">`Given action <span class="subst">$&#123;actionName&#125;</span>, reducer "<span class="subst">$&#123;key&#125;</span>" returned undefined. `</span> +</span><br><span class="line">    <span class="string">`To ignore an action, you must explicitly return the previous state. `</span> +</span><br><span class="line">    <span class="string">`If you want this reducer to hold no value, you can return null instead of undefined.`</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个用来生成当 reducer 返回 <code>undefined</code> 时错误内容的函数，没什么好说的。</p><h3 id="getUnexpectedStateShapeWarningMessage"><a href="#getUnexpectedStateShapeWarningMessage" class="headerlink" title="getUnexpectedStateShapeWarningMessage"></a>getUnexpectedStateShapeWarningMessage</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUnexpectedStateShapeWarningMessage</span>(<span class="params">inputState, reducers, action, unexpectedKeyCache</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> reducerKeys = <span class="built_in">Object</span>.keys(reducers)</span><br><span class="line">  <span class="keyword">const</span> argumentName = action &amp;&amp; action.type === ActionTypes.INIT ?</span><br><span class="line">    <span class="string">'preloadedState argument passed to createStore'</span> :</span><br><span class="line">    <span class="string">'previous state received by the reducer'</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (reducerKeys.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="string">'Store does not have a valid reducer. Make sure the argument passed '</span> +</span><br><span class="line">      <span class="string">'to combineReducers is an object whose values are reducers.'</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!isPlainObject(inputState)) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="string">`The <span class="subst">$&#123;argumentName&#125;</span> has unexpected type of "`</span> +</span><br><span class="line">      (&#123;&#125;).toString.call(inputState).match(<span class="regexp">/\s([az|AZ]+)/</span>)[<span class="number">1</span>] +</span><br><span class="line">      <span class="string">`". Expected argument to be an object with the following `</span> +</span><br><span class="line">      <span class="string">`keys: "<span class="subst">$&#123;reducerKeys.join(<span class="string">'", "'</span>)&#125;</span>"`</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> unexpectedKeys = <span class="built_in">Object</span>.keys(inputState).filter(<span class="function"><span class="params">key</span> =&gt;</span></span><br><span class="line">    !reducers.hasOwnProperty(key) &amp;&amp;</span><br><span class="line">    !unexpectedKeyCache[key]</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  unexpectedKeys.forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    unexpectedKeyCache[key] = <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (unexpectedKeys.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="string">`Unexpected <span class="subst">$&#123;unexpectedKeys.length &gt; <span class="number">1</span> ? <span class="string">'keys'</span> : <span class="string">'key'</span>&#125;</span> `</span> +</span><br><span class="line">      <span class="string">`"<span class="subst">$&#123;unexpectedKeys.join(<span class="string">'", "'</span>)&#125;</span>" found in <span class="subst">$&#123;argumentName&#125;</span>. `</span> +</span><br><span class="line">      <span class="string">`Expected to find one of the known reducer keys instead: `</span> +</span><br><span class="line">      <span class="string">`"<span class="subst">$&#123;reducerKeys.join(<span class="string">'", "'</span>)&#125;</span>". Unexpected keys will be ignored.`</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从函数名 “获取未期望State结构错误信息” 可以看出这个函数用来生成当传入的 <code>inputState</code> 组成结构错误时的错误信息。</p><p>Reducer 必须有 key 值（这不废话），<code>inputState</code> 必须是一个字面量对象。且<code>inputState</code> 的 key 都应该在 reducer 的自身属性（OwnProperty, 非原型链上的）中，并且不能在传入的 <code>unexpectedKeyCache</code> 中。</p><h3 id="assertReducerShape"><a href="#assertReducerShape" class="headerlink" title="assertReducerShape"></a>assertReducerShape</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assertReducerShape</span>(<span class="params">reducers</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Object</span>.keys(reducers).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> reducer = reducers[key]</span><br><span class="line">    <span class="keyword">const</span> initialState = reducer(<span class="literal">undefined</span>, &#123; <span class="attr">type</span>: ActionTypes.INIT &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> initialState === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">        <span class="string">`Reducer "<span class="subst">$&#123;key&#125;</span>" returned undefined during initialization. `</span> +</span><br><span class="line">        <span class="string">`If the state passed to the reducer is undefined, you must `</span> +</span><br><span class="line">        <span class="string">`explicitly return the initial state. The initial state may `</span> +</span><br><span class="line">        <span class="string">`not be undefined. If you don't want to set a value for this reducer, `</span> +</span><br><span class="line">        <span class="string">`you can use null instead of undefined.`</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> type = <span class="string">'@@redux/PROBE_UNKNOWN_ACTION_'</span> + <span class="built_in">Math</span>.random().toString(<span class="number">36</span>).substring(<span class="number">7</span>).split(<span class="string">''</span>).join(<span class="string">'.'</span>)</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> reducer(<span class="literal">undefined</span>, &#123; type &#125;) === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">        <span class="string">`Reducer "<span class="subst">$&#123;key&#125;</span>" returned undefined when probed with a random type. `</span> +</span><br><span class="line">        <span class="string">`Don't try to handle <span class="subst">$&#123;ActionTypes.INIT&#125;</span> or other actions in "redux/*" `</span> +</span><br><span class="line">        <span class="string">`namespace. They are considered private. Instead, you must return the `</span> +</span><br><span class="line">        <span class="string">`current state for any unknown actions, unless it is undefined, `</span> +</span><br><span class="line">        <span class="string">`in which case you must return the initial state, regardless of the `</span> +</span><br><span class="line">        <span class="string">`action type. The initial state may not be undefined, but can be null.`</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用来保证传入的 <code>reducers</code> 的结构正确，也就说说每个 <code>reducer</code> 都必须在收到 INIT action 后返回一个不为 <code>undefined</code> 的 <code>initState</code> ，并且这个 <code>action</code> 不能在 <code>reducer</code> 中专门去处理。这也是为什么我们在 reducer 里面一定要指定默认返回的 state 的原因.</p><h3 id="combineReducers-1"><a href="#combineReducers-1" class="headerlink" title="combineReducers"></a>combineReducers</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Turns an object whose values are different reducer functions, into a single</span></span><br><span class="line"><span class="comment">  * reducer function. It will call every child reducer, and gather their results</span></span><br><span class="line"><span class="comment">  * into a single state object, whose keys correspond to the keys of the passed</span></span><br><span class="line"><span class="comment">  * reducer functions.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * @param &#123;Object&#125; reducers An object whose values correspond to different</span></span><br><span class="line"><span class="comment">  * reducer functions that need to be combined into one. One handy way to obtain</span></span><br><span class="line"><span class="comment">  * it is to use ES6 `import * as reducers` syntax. The reducers may never return</span></span><br><span class="line"><span class="comment">  * undefined for any action. Instead, they should return their initial state</span></span><br><span class="line"><span class="comment">  * if the state passed to them was undefined, and the current state for any</span></span><br><span class="line"><span class="comment">  * unrecognized action.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * @returns &#123;Function&#125; A reducer function that invokes every reducer inside the</span></span><br><span class="line"><span class="comment">  * passed object, and builds a state object with the same shape.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">combineReducers</span>(<span class="params">reducers</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> reducerKeys = <span class="built_in">Object</span>.keys(reducers)</span><br><span class="line">  <span class="keyword">const</span> finalReducers = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; reducerKeys.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> key = reducerKeys[i]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> reducers[key] === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">        warning(<span class="string">`No reducer provided for key "<span class="subst">$&#123;key&#125;</span>"`</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> reducers[key] === <span class="string">'function'</span>) &#123;</span><br><span class="line">      finalReducers[key] = reducers[key]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> finalReducerKeys = <span class="built_in">Object</span>.keys(finalReducers)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> unexpectedKeyCache</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">    unexpectedKeyCache = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> shapeAssertionError</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    assertReducerShape(finalReducers)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    shapeAssertionError = e</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">combination</span>(<span class="params">state = &#123;&#125;, action</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (shapeAssertionError) &#123;</span><br><span class="line">      <span class="keyword">throw</span> shapeAssertionError</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache)</span><br><span class="line">      <span class="keyword">if</span> (warningMessage) &#123;</span><br><span class="line">        warning(warningMessage)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> hasChanged = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">const</span> nextState = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; finalReducerKeys.length; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> key = finalReducerKeys[i]</span><br><span class="line">      <span class="keyword">const</span> reducer = finalReducers[key]</span><br><span class="line">      <span class="keyword">const</span> previousStateForKey = state[key]</span><br><span class="line">      <span class="keyword">const</span> nextStateForKey = reducer(previousStateForKey, action)</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> nextStateForKey === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> errorMessage = getUndefinedStateErrorMessage(key, action)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(errorMessage)</span><br><span class="line">      &#125;</span><br><span class="line">      nextState[key] = nextStateForKey</span><br><span class="line">      hasChanged = hasChanged || nextStateForKey !== previousStateForKey</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hasChanged ? nextState : state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>combineReducer</code> 接收一个用来合并成一个 <code>reducer</code> 的对象，执行后返回一个函数，也即是我们的 rootReducer .</p><p>首先把传入的 <code>reducers</code> 按 <code>key</code> 遍历后赋值给 <code>finalReducers</code> . 然后进行一堆错误判断，最后返回一个函数 <code>combination</code>. 也就是合并后的 reducer :</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> hasChanged = <span class="literal">false</span></span><br><span class="line"><span class="keyword">const</span> nextState = &#123;&#125;</span><br><span class="line"><span class="comment">// 遍历 finalReducerKeys</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; finalReducerKeys.length; i++) &#123;</span><br><span class="line"><span class="comment">// 拿到当前的 reducer key</span></span><br><span class="line">    <span class="keyword">const</span> key = finalReducerKeys[i]</span><br><span class="line"><span class="comment">// 根据 reducer key 拿到具体的 reducer 函数</span></span><br><span class="line">      <span class="keyword">const</span> reducer = finalReducers[key]</span><br><span class="line"><span class="comment">// 获取之前的 key 对应的 state</span></span><br><span class="line">      <span class="keyword">const</span> previousStateForKey = state[key]</span><br><span class="line"><span class="comment">// 计算下一个当前 key 对应的 state</span></span><br><span class="line">      <span class="keyword">const</span> nextStateForKey = reducer(previousStateForKey, action)</span><br><span class="line"><span class="comment">// 如果计算出来的 state 为 undefined 那么报错</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> nextStateForKey === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> errorMessage = getUndefinedStateErrorMessage(key, action)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(errorMessage)</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">// 把当前 key 对应的 state 赋值到下一个全局 state</span></span><br><span class="line">      nextState[key] = nextStateForKey</span><br><span class="line"><span class="comment">// 只要有一个 key 对应的 state 发生了变化，那么就认为整个 state 发生了变化</span></span><br><span class="line">      hasChanged = hasChanged || nextStateForKey !== previousStateForKey</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 根据 state 是否发生变化，返回下一个 state 或者上一个 state</span></span><br><span class="line">    <span class="keyword">return</span> hasChanged ? nextState : state</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="bindActionCreators"><a href="#bindActionCreators" class="headerlink" title="bindActionCreators"></a>bindActionCreators</h2><p>这个函数非常简单，是一个辅助函数。用来把 dispatch 绑定到一个 actionCreator 上，这样当就可以通过直接调用绑定后的函数来分发一个 action ，而不需要 <code>dispatch(actionCreator(…))</code> 了。</p><h2 id="applyMiddleware"><a href="#applyMiddleware" class="headerlink" title="applyMiddleware"></a>applyMiddleware</h2><p>这里是重点，也是一般初学者难以理解的地方，我们仔细看看。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> compose <span class="keyword">from</span> <span class="string">'./compose'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Creates a store enhancer that applies middleware to the dispatch method</span></span><br><span class="line"><span class="comment">  * of the Redux store. This is handy for a variety of tasks, such as expressing</span></span><br><span class="line"><span class="comment">  * asynchronous actions in a concise manner, or logging every action payload.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * See `reduxthunk` package as an example of the Redux middleware.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * Because middleware is potentially asynchronous, this should be the first</span></span><br><span class="line"><span class="comment">  * store enhancer in the composition chain.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * Note that each middleware will be given the `dispatch` and `getState` functions</span></span><br><span class="line"><span class="comment">  * as named arguments.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * @param &#123;...Function&#125; middlewares The middleware chain to be applied.</span></span><br><span class="line"><span class="comment">  * @returns &#123;Function&#125; A store enhancer applying the middleware.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">applyMiddleware</span>(<span class="params">...middlewares</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">createStore</span>) =&gt;</span> (reducer, preloadedState, enhancer) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> store = createStore(reducer, preloadedState, enhancer)</span><br><span class="line">    <span class="keyword">let</span> dispatch = store.dispatch</span><br><span class="line">    <span class="keyword">let</span> chain = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> middlewareAPI = &#123;</span><br><span class="line">      getState: store.getState,</span><br><span class="line">      dispatch: <span class="function">(<span class="params">action</span>) =&gt;</span> dispatch(action)</span><br><span class="line">    &#125;</span><br><span class="line">    chain = middlewares.map(<span class="function"><span class="params">middleware</span> =&gt;</span> middleware(middlewareAPI))</span><br><span class="line">    dispatch = compose(...chain)(store.dispatch)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      ...store,</span><br><span class="line">      dispatch</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代码量非常短，依赖了模块 <code>compose</code> .</p><p><code>applyMiddleware</code> 函数接受一系列中间件函数作为参数，返回了一个拥有 <code>createStore</code> 方法的闭包函数。这个函数，接收 <code>reducer</code> ，<code>preloadedState</code> 和 <code>enhancer</code> 为参数。<br>配合 createStore 函数来看：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">createStore</span>(<span class="params">reducer, preloadedState, enhancer</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> preloadedState === <span class="string">'function'</span> &amp;&amp; <span class="keyword">typeof</span> enhancer === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    enhancer = preloadedState</span><br><span class="line">    preloadedState = <span class="literal">undefined</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> enhancer !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> enhancer !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected the enhancer to be a function.'</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> enhancer(createStore)(reducer, preloadedState)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>当我们这样创建 store 的时候：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = createStore(</span><br><span class="line">  reducer,</span><br><span class="line">  applyMiddleware(...middleware)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>createStore 的第二个参数是个函数，所以就会走到<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> enhancer(createStore)(reducer, preloadedState)</span><br></pre></td></tr></table></figure></p><p>也就是由 applyMiddleware(…middleware) 的结果接管了 createStore ,实际的 store 是在 applyMiddleware 里面再次调用 createStore 创建的，此时传入的 preloadedState, enhancer 都是 undefined.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// applyMiddleware</span></span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer, preloadedState, enhancer)</span><br></pre></td></tr></table></figure></p><p>回过头来继续往下看，<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//applyMiddleware</span></span><br><span class="line">dispatch = compose(...chain)(store.dispatch)</span><br></pre></td></tr></table></figure></p><p>这里需要先看一下 <code>compose</code> 这个模块，它的作用就是达到 <code>compose(f, g, h) &gt; (...args) =&gt; f(g(h(...args)))</code> 这么一个目的。</p><p>那么这里的 <code>dispatch</code> 就是在 <code>store.dispatch</code> 基础上经过 <code>middleware</code> 加强封装后的 <code>dispatch</code>.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> middlewareAPI = &#123;</span><br><span class="line">      getState: store.getState,</span><br><span class="line">      dispatch: <span class="function">(<span class="params">action</span>) =&gt;</span> dispatch(action)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把 middlewareAPI 传入到每个中间件中</span></span><br><span class="line">chain = middlewares.map(<span class="function"><span class="params">middleware</span> =&gt;</span> middleware(middlewareAPI))</span><br></pre></td></tr></table></figure></p><p>这里的 <code>dispatch: (action) =&gt; dispatch(action)</code> ，说明每个中间件中的 <code>dispatch</code> 都是独立互不影响的，以免某个中间件中修改了 <code>dispatch</code> 的行为。然后给每个中间件都传入 getState 和 dispatch 作为他们的参数。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">  ...store,</span><br><span class="line">  dispatch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后用加强后的 <code>dispatch</code> 覆盖掉原有 store 中的 <code>dispatch</code>.</p><p>整个中间件的代码看下来，可能比较抽象，我们结合一个例子来看一下：</p><p><strong>errorMiddleware</strong><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (&#123;dispatch, getState&#125;) =&gt; <span class="function"><span class="params">next</span> =&gt;</span> action =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;error, payload&#125; = action</span><br><span class="line">  <span class="keyword">if</span> (error) &#123;</span><br><span class="line">    dispatch(showToast(payload.message || payload.toString()))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> next(action)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这是我们的一个错误处理中间件。它也是一个高阶函数，首先接受 <code>dispatch</code>, <code>getState</code> 为参数，返回一个接受 <code>next</code> 为参数的函数。<code>dispatch</code>, <code>getState</code> 就是在上面代码里通过 middlewareAPI 传入了中间件中。</p><p>然后我们继续看 errorMiddleware 执行后返回的接受 <code>next</code> 为参数的函数，而 <code>next</code> 其实就是下一个要执行的 <code>middleware</code> . </p><p>然后我们需要了解一下中间件的执行顺序，那么为了更清楚的描述一个 action 在中间件中的传播过程，我们假设有以下三个中间件：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mid1 = <span class="function"><span class="params">()</span> =&gt;</span> next =&gt; <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'mid1 before'</span>)</span><br><span class="line">  next(action)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'mid1 after'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> mid2 = <span class="function"><span class="params">()</span> =&gt;</span> next =&gt; <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'mid2 before'</span>)</span><br><span class="line">  next(action)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'mid2 after'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> mid3 = <span class="function"><span class="params">()</span> =&gt;</span> next =&gt; <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'mid3 before'</span>)</span><br><span class="line">  next(action)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'mid3 after'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行 <code>applyMiddleware( mid1, mid2, mid3 )</code>, 那么经过下面代码后<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">dispatch = compose(...chain)(store.dispatch)</span><br></pre></td></tr></table></figure></p><p>就可以得到：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">dispatch = <span class="function">(<span class="params">store.dispatch</span>) =&gt;</span> mid1(mid2(mid3(store.dispatch)))</span><br></pre></td></tr></table></figure><p>其中的 <strong>midx</strong> 都是已经执行了 <code>middleware(middlewareAPI)</code> 后返回的结果。所以 <code>mid3</code> 的 <code>next</code> 的值就是 <code>store.dispatch</code> 。而 <code>mid2</code> 的 <code>next</code> 则是 <code>mid3(store.dispatch)</code> ，以此类推，<code>mid1</code> 的 next 就是 <code>mid2(mid3(store.dispatch))</code> , 这也就是在 <strong>middleware</strong> 调用 <code>next</code> 能够让 <code>action</code> 转到下一个 <strong>middleware</strong> 的原因。</p><p>当我们分发一个 action 时，控制台打印出来的顺序是这样的：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mid1 before</span><br><span class="line">mid2 before</span><br><span class="line">mid3 before</span><br><span class="line">mid3 after</span><br><span class="line">mid2 after</span><br><span class="line">mid1 after</span><br></pre></td></tr></table></figure><p>可以看到它的流程是这样的：</p><ol><li>执行 mid1 中 next 方法调用之前的代码</li><li>执行 mid2 中 next 方法调用之前的代码</li><li>执行 mid3 中 next 方法调用之前的代码</li><li>执行 dispatch 来分发 action</li><li>执行 mid3 中 next 方法调用之后的代码</li><li>执行 mid2 中 next 方法调用之后的代码</li><li>执行 mid1 中 next 方法调用之后的代码</li></ol><p>看一张图，会更明白一点：</p><img src="/2017/10/14/redux-source-code-read/redux-middleware.png" title="reduxmiddleware"><p>其中红色的路径就是我们刚才描述的流程。可以看到其中还有一条黑色路径，也就是如果我们直接在 mid2 中调用 dispatch 会怎么样？我们来改一下 mid2</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mid2 = <span class="function">(<span class="params">&#123; dispatch, getStore &#125;</span>) =&gt;</span> next =&gt; <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'mid2 before'</span>)</span><br><span class="line">  dispatch(action)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'mid2 after'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改成这样，猜猜会怎样？</p><p>答案是，会一直在 mid1 before 和 mid2 before 中死循环，因为调用的 <code>dispatch</code> 会让这个 <code>action</code> 重新走一遍所有的中间件，也就是图中的黑色路径。那么当我们需要在一个中间件中调用 <code>dispatch</code> 的时候，是要对 action 做判断的，只有满足某个条件的时候才调用 <code>dispatch</code> 以免出现死循环。改造一下 mid2</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mid2 = <span class="function">(<span class="params">&#123; dispatch, getStore &#125;</span>) =&gt;</span> next =&gt; <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'mid2 before'</span>)</span><br><span class="line">  <span class="keyword">if</span>(action.isApi) &#123;</span><br><span class="line">    dispatch(&#123;</span><br><span class="line">      isApi: <span class="literal">false</span>,</span><br><span class="line">      ...</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  dispatch(action)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'mid2 after'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，就只有在 action 满足 isApi 条件的时候才会取分发一个不满足 isApi 条件的 action ，这样就不会死循环。一般在异步分发 action 的时候会经常用这个方法。比如我们生产环境用来请求数据的 callAPIMiddleware :</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (&#123;dispatch, getState&#125;) =&gt; &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="params">next</span> =&gt;</span> action =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    types,</span><br><span class="line">    api,</span><br><span class="line">    callType,</span><br><span class="line">    meta,</span><br><span class="line">    body,</span><br><span class="line">    shouldCallAPI</span><br><span class="line">  &#125; = action</span><br><span class="line">  <span class="keyword">const</span> state = getState()</span><br><span class="line">  <span class="keyword">const</span> callTypeList = [<span class="string">'get'</span>, <span class="string">'post'</span>]</span><br><span class="line">  <span class="keyword">if</span> (!api) &#123;</span><br><span class="line">    <span class="keyword">return</span> next(action)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!(types.start &amp;&amp; types.success &amp;&amp; types.failure)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected types has start &amp;&amp; success &amp;&amp; failure keys.'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (callTypeList.indexOf(callType) === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`API callType Must be one of <span class="subst">$&#123;callTypeList&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123;start, success, failure&#125; = types</span><br><span class="line">  <span class="keyword">if</span> (!shouldCallAPI(state)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  dispatch(&#123;</span><br><span class="line">    type: start,</span><br><span class="line">    payload: &#123;</span><br><span class="line">      ...body</span><br><span class="line">    &#125;,</span><br><span class="line">    meta</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">const</span> mapCallTypeToFetch = &#123;</span><br><span class="line">      post: <span class="function"><span class="params">()</span> =&gt;</span> fetch(api, &#123;</span><br><span class="line">        method: <span class="string">'post'</span>,</span><br><span class="line">        <span class="comment">// credentials 设置为每次请求都带上 cookie</span></span><br><span class="line">        credentials: <span class="string">'include'</span>,</span><br><span class="line">        headers: &#123;</span><br><span class="line">          <span class="string">'Accept'</span>: <span class="string">'application/json'</span>,</span><br><span class="line">          <span class="string">'Content-Type'</span>: <span class="string">'application/json'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        body: <span class="built_in">JSON</span>.stringify(bodyWithSource)</span><br><span class="line">      &#125;),</span><br><span class="line">      get: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> toString = <span class="built_in">Object</span>.keys(bodyWithSource).map(<span class="function"><span class="keyword">function</span> (<span class="params">key, index</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">encodeURIComponent</span>(key) + <span class="string">'='</span> + <span class="built_in">encodeURIComponent</span>(bodyWithSource[key])</span><br><span class="line">        &#125;).join(<span class="string">'&amp;'</span>)</span><br><span class="line">        <span class="keyword">return</span> fetch(<span class="string">`<span class="subst">$&#123;api&#125;</span>?<span class="subst">$&#123;toString&#125;</span>`</span>, &#123;</span><br><span class="line">          method: <span class="string">'get'</span>,</span><br><span class="line">          credentials: <span class="string">'include'</span>,</span><br><span class="line">          headers: &#123;</span><br><span class="line">            <span class="string">'Accept'</span>: <span class="string">'application/json'</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> fetching = mapCallTypeToFetch[callType]()</span><br><span class="line">... 省略一堆业务逻辑</span><br><span class="line">  <span class="keyword">return</span> fetching.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    clearTimeout(loadingTimer)</span><br><span class="line">    dispatch(hideLoading())</span><br><span class="line">    <span class="keyword">if</span> (res.ok) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> res.json()</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(err)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      dispatch(showToast(<span class="string">'请求出错'</span>))</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(res.text())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> resBehaviour(res))</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      dispatch(&#123;</span><br><span class="line">        type: success,</span><br><span class="line">        meta,</span><br><span class="line">        payload: &#123;</span><br><span class="line">          ...res.data</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(res)</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(<span class="string">`接口请求出错,<span class="subst">$&#123;err&#125;</span>`</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于中间件就说这么多，大家应该也能理解了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总体上看， Redux 的源码非常短，但是各种实现都非常的精巧。</p><p>而且作者非常重视对开发者的体验，注释非常的详细，整体上读起来比较轻松。错误处理也非常详细，可以帮助开发者更容易的定位错误。</p><p>最后，由于本人能力有限，文中如果有错误的地方，还请指出一起讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redux 的源码非常的精炼，短短几百行代码，去提供了强大的功能。今天，我们就来一探究竟。&lt;/p&gt;
&lt;p&gt;看源码最简单的方式，就是从入口文件来看，看它依赖哪些模块，然后在依次看这些模块的内容，最后也就对整个代码有个清晰的认识了。&lt;/p&gt;
&lt;p&gt;所以我们就从入口文件开始来看：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; createStore &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;./createStore&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; combineReducers &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;./combineReducers&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; bindActionCreators &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;./bindActionCreators&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; applyMiddleware &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;./applyMiddleware&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; compose &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;./compose&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; warning &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;./utils/warning&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/*&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;* This is a dummy function to check if the function name has been altered by minification.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;* If the function has been minified and NODE_ENV !== &#39;production&#39;, warn the user.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;isCrushed&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 就是根据 isCrushed 是否被压缩了，来警告开发者正在非生产环境使用一个压缩过的代码。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  process.env.NODE_ENV !== &lt;span class=&quot;string&quot;&gt;&#39;production&#39;&lt;/span&gt; &amp;amp;&amp;amp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; isCrushed.name === &lt;span class=&quot;string&quot;&gt;&#39;string&#39;&lt;/span&gt; &amp;amp;&amp;amp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  isCrushed.name !== &lt;span class=&quot;string&quot;&gt;&#39;isCrushed&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  warning(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;You are currently using minified code outside of NODE_ENV === \&#39;production\&#39;. &#39;&lt;/span&gt; +&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;This means that you are running a slower development build of Redux. &#39;&lt;/span&gt; +&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;You can use looseenvify (https://github.com/zertosh/looseenvify) for browserify &#39;&lt;/span&gt; +&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;or DefinePlugin for webpack (http://stackoverflow.com/questions/30030031) &#39;&lt;/span&gt; +&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;to ensure you have the correct code for your production build.&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;export&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  createStore,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  combineReducers,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  bindActionCreators,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  applyMiddleware,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  compose&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;可以看到它依赖了下面这几个模块：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;createStore&lt;/li&gt;
&lt;li&gt;combineReducers&lt;/li&gt;
&lt;li&gt;bindActionCreators&lt;/li&gt;
&lt;li&gt;applyMiddleware&lt;/li&gt;
&lt;li&gt;compose&lt;/li&gt;
&lt;li&gt;warning&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其他没什么说的，就是把一些 API 暴露出去。那我们就先按照这个模块依赖顺序，依次进行解读。&lt;/p&gt;
&lt;h2 id=&quot;createStore&quot;&gt;&lt;a href=&quot;#createStore&quot; class=&quot;headerlink&quot; title=&quot;createStore&quot;&gt;&lt;/a&gt;createStore&lt;/h2&gt;
    
    </summary>
    
      <category term="技术" scheme="https://blog.kisnows.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>ReactDOM 是如何把组件渲染到 DOM 中的？</title>
    <link href="https://blog.kisnows.com/2017/09/20/how-react-render-component-to-dom/"/>
    <id>https://blog.kisnows.com/2017/09/20/how-react-render-component-to-dom/</id>
    <published>2017-09-20T11:28:39.000Z</published>
    <updated>2017-10-14T07:27:47.598Z</updated>
    
    <content type="html"><![CDATA[<p>当我们在开发 React 项目中，第一次调用 <code>ReactDOM.render</code> 的时候都发生了什么呢？<br>今天就从源码角度来追踪一下这个问题（主要看流程， 而不纠结与细节）。</p><h2 id="ReactDOMStackEntry"><a href="#ReactDOMStackEntry" class="headerlink" title="ReactDOMStackEntry"></a>ReactDOMStackEntry</h2><p>首先我们可以从 ReactDOM 的入口文件 ReactDOMStackEntry.js 中找到 render 方法。可以看到，<code>render</code> 方法是 ReactMount 组件提供的。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ReactDOMStack = &#123;</span><br><span class="line">  findDOMNode: findDOMNode,</span><br><span class="line">  render: ReactMount.render,</span><br><span class="line">  unmountComponentAtNode: ReactMount.unmountComponentAtNode,</span><br><span class="line">  version: ReactVersion,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* eslint-disable camelcase */</span></span><br><span class="line">  unstable_batchedUpdates: ReactGenericBatching.batchedUpdates,</span><br><span class="line">  unstable_renderSubtreeIntoContainer: ReactMount.renderSubtreeIntoContainer,</span><br><span class="line">  <span class="comment">/* eslint-enable camelcase */</span></span><br><span class="line"></span><br><span class="line">  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: &#123;</span><br><span class="line">    <span class="comment">// For TapEventPlugin which is popular in open source</span></span><br><span class="line">    EventPluginHub: <span class="built_in">require</span>(<span class="string">'EventPluginHub'</span>),</span><br><span class="line">    <span class="comment">// Used by test-utils</span></span><br><span class="line">    EventPluginRegistry: <span class="built_in">require</span>(<span class="string">'EventPluginRegistry'</span>),</span><br><span class="line">    EventPropagators: <span class="built_in">require</span>(<span class="string">'EventPropagators'</span>),</span><br><span class="line">    ReactControlledComponent: <span class="built_in">require</span>(<span class="string">'ReactControlledComponent'</span>),</span><br><span class="line">    ReactDOMComponentTree,</span><br><span class="line">    ReactDOMEventListener: <span class="built_in">require</span>(<span class="string">'ReactDOMEventListener'</span>),</span><br><span class="line">    ReactUpdates: ReactUpdates,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="ReactMount-render"><a href="#ReactMount-render" class="headerlink" title="ReactMount.render"></a>ReactMount.render</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">render: <span class="function"><span class="keyword">function</span>(<span class="params">nextElement, container, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ReactMount._renderSubtreeIntoContainer(</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    nextElement,</span><br><span class="line">    container,</span><br><span class="line">    callback,</span><br><span class="line">  );</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>又调到了 <code>_renderSubtreeIntoContainer</code> 方法, 这个方法核心内容如下：<br><a id="more"></a></p><h2 id="ReactMount-renderSubtreeIntoContainer"><a href="#ReactMount-renderSubtreeIntoContainer" class="headerlink" title="ReactMount._renderSubtreeIntoContainer"></a>ReactMount._renderSubtreeIntoContainer</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">_renderSubtreeIntoContainer: <span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    parentComponent,</span></span></span><br><span class="line"><span class="function"><span class="params">    nextElement,</span></span></span><br><span class="line"><span class="function"><span class="params">    container,</span></span></span><br><span class="line"><span class="function"><span class="params">    callback,</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>) </span>&#123;</span><br><span class="line">    callback = callback === <span class="literal">undefined</span> ? <span class="literal">null</span> : callback;</span><br><span class="line">    <span class="keyword">if</span> (!React.isValidElement(nextElement)) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建下一个 wrapped 元素</span></span><br><span class="line">    <span class="keyword">var</span> nextWrappedElement = React.createElement(TopLevelWrapper, &#123;</span><br><span class="line">      child: nextElement,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> nextContext = getContextForSubtree(parentComponent);</span><br><span class="line">    <span class="comment">// 拿到当前的顶层容器组件</span></span><br><span class="line">    <span class="keyword">var</span> prevComponent = getTopLevelWrapperInContainer(container);</span><br><span class="line">    <span class="comment">// 对于第一次 render 来说，prevComponent 为 null</span></span><br><span class="line">    <span class="keyword">if</span> (prevComponent) &#123;</span><br><span class="line">      <span class="keyword">var</span> prevWrappedElement = prevComponent._currentElement;</span><br><span class="line">      <span class="keyword">var</span> prevElement = prevWrappedElement.props.child;</span><br><span class="line">      <span class="keyword">if</span> (shouldUpdateReactComponent(prevElement, nextElement)) &#123;</span><br><span class="line">        <span class="keyword">var</span> publicInst = prevComponent._renderedComponent.getPublicInstance();</span><br><span class="line">        <span class="keyword">var</span> updatedCallback =</span><br><span class="line">          callback &amp;&amp;</span><br><span class="line">          <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            validateCallback(callback);</span><br><span class="line">            callback.call(publicInst);</span><br><span class="line">          &#125;;</span><br><span class="line">        ReactMount._updateRootComponent(</span><br><span class="line">          prevComponent,</span><br><span class="line">          nextWrappedElement,</span><br><span class="line">          nextContext,</span><br><span class="line">          container,</span><br><span class="line">          updatedCallback,</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span> publicInst;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ReactMount.unmountComponentAtNode(container);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> reactRootElement = getReactRootElementInContainer(container);</span><br><span class="line">    <span class="keyword">var</span> containerHasReactMarkup =</span><br><span class="line">      reactRootElement &amp;&amp; !!internalGetID(reactRootElement);</span><br><span class="line">    <span class="keyword">var</span> containerHasNonRootReactChild = hasNonRootReactChild(container);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> shouldReuseMarkup =</span><br><span class="line">      containerHasReactMarkup &amp;&amp;</span><br><span class="line">      !prevComponent &amp;&amp;</span><br><span class="line">      !containerHasNonRootReactChild;</span><br><span class="line">    <span class="keyword">var</span> component = ReactMount._renderNewRootComponent(</span><br><span class="line">      nextWrappedElement,</span><br><span class="line">      container,</span><br><span class="line">      shouldReuseMarkup,</span><br><span class="line">      nextContext,</span><br><span class="line">      callback,</span><br><span class="line">    )._renderedComponent.getPublicInstance();</span><br><span class="line">    <span class="keyword">return</span> component;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>这里有几个方法，分别是：</p><ul><li><code>getTopLevelWrapperInContainer</code></li><li><code>shouldUpdateReactComponent</code></li><li><code>_renderNewRootComponent</code></li></ul><h3 id="getTopLevelWrapperInContainer"><a href="#getTopLevelWrapperInContainer" class="headerlink" title="getTopLevelWrapperInContainer"></a>getTopLevelWrapperInContainer</h3><p>这个方法用来拿到现有的顶层容器组件，相关代码如下。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTopLevelWrapperInContainer</span>(<span class="params">container</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> root = getHostRootInstanceInContainer(container);</span><br><span class="line">  <span class="keyword">return</span> root ? root._hostContainerInfo._topLevelWrapper : <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getHostRootInstanceInContainer</span>(<span class="params">container</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> rootEl = getReactRootElementInContainer(container);</span><br><span class="line">  <span class="keyword">var</span> prevHostInstance =</span><br><span class="line">    rootEl &amp;&amp; ReactDOMComponentTree.getInstanceFromNode(rootEl);</span><br><span class="line">  <span class="keyword">return</span> prevHostInstance &amp;&amp; !prevHostInstance._hostParent</span><br><span class="line">    ? prevHostInstance</span><br><span class="line">    : <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>调用了两个方法，<code>getReactRootElementInContainer</code> 和 <code>ReactDOMComponentTree.getInstanceFromNode</code>.</p><p><strong>getReactRootElementInContainer</strong><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getReactRootElementInContainer</span>(<span class="params">container</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!container) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (container.nodeType === DOCUMENT_NODE) &#123;</span><br><span class="line">    <span class="keyword">return</span> container.documentElement;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> container.firstChild;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>ReactDOMComponentTree</strong></p><p>这个模块有三个方法，分别是：</p><ul><li><code>precacheChildNodes</code>  在 DOM 节点上存储相应的 React 实例</li><li><code>getNodeFromInstance</code> 从一个实例上获取到对应的 DOM 节点</li><li><code>getInstanceFromNode</code> 从一个 DOM 节点上获取到对应的实例</li></ul><h3 id="shouldUpdateReactComponent"><a href="#shouldUpdateReactComponent" class="headerlink" title="shouldUpdateReactComponent"></a>shouldUpdateReactComponent</h3><p>判断是否需要更新组件。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shouldUpdateReactComponent</span>(<span class="params">prevElement, nextElement</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> prevEmpty = prevElement === <span class="literal">null</span> || prevElement === <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">var</span> nextEmpty = nextElement === <span class="literal">null</span> || nextElement === <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (prevEmpty || nextEmpty) &#123;</span><br><span class="line">    <span class="keyword">return</span> prevEmpty === nextEmpty;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> prevType = <span class="keyword">typeof</span> prevElement;</span><br><span class="line">  <span class="keyword">var</span> nextType = <span class="keyword">typeof</span> nextElement;</span><br><span class="line">  <span class="keyword">if</span> (prevType === <span class="string">'string'</span> || prevType === <span class="string">'number'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> nextType === <span class="string">'string'</span> || nextType === <span class="string">'number'</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      nextType === <span class="string">'object'</span> &amp;&amp;</span><br><span class="line">      prevElement.type === nextElement.type &amp;&amp;</span><br><span class="line">      prevElement.key === nextElement.key</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到逻辑是这样的：</p><ul><li>前后两次元素都为 <code>null</code> 返回 <code>true</code></li><li>如果是 <code>textComponent</code>，那么直接更新</li><li>否则当为 DOM 元素或者 React 元素时，且 type 和 key 都相同时返回 <code>true</code>, 执行 update</li></ul><h2 id="ReactMount-renderNewRootComponent"><a href="#ReactMount-renderNewRootComponent" class="headerlink" title="ReactMount._renderNewRootComponent"></a>ReactMount._renderNewRootComponent</h2><p>这个方法是 <code>_renderSubtreeIntoContainer</code> 的核心，用来把一个新的组件挂载到 DOM 中。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">_renderNewRootComponent: <span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  nextElement,</span></span></span><br><span class="line"><span class="function"><span class="params">  container,</span></span></span><br><span class="line"><span class="function"><span class="params">  shouldReuseMarkup,</span></span></span><br><span class="line"><span class="function"><span class="params">  context,</span></span></span><br><span class="line"><span class="function"><span class="params">  callback,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 通过 instantiateReactComponent 拿到 React Component 组件实例</span></span><br><span class="line">  <span class="keyword">var</span> componentInstance = instantiateReactComponent(nextElement, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (callback) &#123;</span><br><span class="line">    componentInstance._pendingCallbacks = [</span><br><span class="line">      <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        validateCallback(callback);</span><br><span class="line">        callback.call(</span><br><span class="line">          componentInstance._renderedComponent.getPublicInstance(),</span><br><span class="line">        );</span><br><span class="line">      &#125;,</span><br><span class="line">    ];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The initial render is synchronous but any updates that happen during</span></span><br><span class="line">  <span class="comment">// rendering, in componentWillMount or componentDidMount, will be batched</span></span><br><span class="line">  <span class="comment">// according to the current batching strategy.</span></span><br><span class="line">  ReactUpdates.batchedUpdates(</span><br><span class="line">    batchedMountComponentIntoNode,</span><br><span class="line">    componentInstance,</span><br><span class="line">    container,</span><br><span class="line">    shouldReuseMarkup,</span><br><span class="line">    context,</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> wrapperID = componentInstance._instance.rootID;</span><br><span class="line">  instancesByReactRootID[wrapperID] = componentInstance;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> componentInstance;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><h3 id="instantiateReactComponent"><a href="#instantiateReactComponent" class="headerlink" title="instantiateReactComponent"></a>instantiateReactComponent</h3><p>根据传入的参数来生成不同的 React Component, 核心代码：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (node === <span class="literal">null</span> || node === <span class="literal">false</span>) &#123;</span><br><span class="line">  instance = ReactEmptyComponent.create(instantiateReactComponent);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> node === <span class="string">'object'</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> element = node;</span><br><span class="line">  <span class="keyword">var</span> type = element.type;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> type !== <span class="string">'function'</span> &amp;&amp; <span class="keyword">typeof</span> type !== <span class="string">'string'</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Special case string values</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> element.type === <span class="string">'string'</span>) &#123;</span><br><span class="line">    instance = ReactHostComponent.createInternalComponent(element);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isInternalComponentType(element.type)) &#123;</span><br><span class="line">    <span class="comment">// This is temporarily available for custom components that are not string</span></span><br><span class="line">    <span class="comment">// representations. I.e. ART. Once those are updated to use the string</span></span><br><span class="line">    <span class="comment">// representation, we can drop this code path.</span></span><br><span class="line">    instance = <span class="keyword">new</span> element.type(element);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We renamed this. Allow the old name for compat. :(</span></span><br><span class="line">    <span class="keyword">if</span> (!instance.getHostNode) &#123;</span><br><span class="line">      instance.getHostNode = instance.getNativeNode;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    instance = <span class="keyword">new</span> ReactCompositeComponentWrapper(element);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> node === <span class="string">'string'</span> || <span class="keyword">typeof</span> node === <span class="string">'number'</span>) &#123;</span><br><span class="line">  instance = ReactHostComponent.createInstanceForText(node);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  invariant(<span class="literal">false</span>, <span class="string">'Encountered invalid React node of type %s'</span>, <span class="keyword">typeof</span> node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从代码中可以看到，根据 <code>element.type</code> 的不同，有三个方法来生成三种不同 React 组件实例，分别为：</p><ul><li>ReactHostComponent.createInternalComponent(element)</li><li>new ReactCompositeComponentWrapper(element)</li><li>ReactHostComponent.createInstanceForText(node);</li></ul><p>可能读者会注意到，当 <code>isInternalComponentType(element.type)</code> 成立时， <code>instance = new element.type(element);</code> 的这段代码被我忽略了，那是因为这个是 React 封装的内部组件不是由字符串表达时的解决方法，我们是不用关心的。<br>我们来看上面的三个方法，其中两个方法都调用了 ReactHostComponent 模块。</p><h3 id="ReactHostComponent"><a href="#ReactHostComponent" class="headerlink" title="ReactHostComponent"></a>ReactHostComponent</h3><p>核心代码:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ReactHostComponentInjection = &#123;</span><br><span class="line">  <span class="comment">// This accepts a class that receives the tag string. This is a catch all</span></span><br><span class="line">  <span class="comment">// that can render any kind of tag.</span></span><br><span class="line">  injectGenericComponentClass: <span class="function"><span class="keyword">function</span>(<span class="params">componentClass</span>) </span>&#123;</span><br><span class="line">    genericComponentClass = componentClass;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// This accepts a text component class that takes the text string to be</span></span><br><span class="line">  <span class="comment">// rendered as props.</span></span><br><span class="line">  injectTextComponentClass: <span class="function"><span class="keyword">function</span>(<span class="params">componentClass</span>) </span>&#123;</span><br><span class="line">    textComponentClass = componentClass;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createInternalComponent</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">  invariant(</span><br><span class="line">    genericComponentClass,</span><br><span class="line">    <span class="string">'There is no registered component for the tag %s'</span>,</span><br><span class="line">    element.type,</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> genericComponentClass(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;ReactText&#125; text</span></span><br><span class="line"><span class="comment"> * @return &#123;ReactComponent&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createInstanceForText</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> textComponentClass(text);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>就是提供了两个方法来创建组件，而其中两个组件 class 的实现是通过其他模块注入进来的，那到底是从哪里注入进来的呢。<br>经过一番查找，发现是在 <code>ReactDOMStackInjection.js</code> 中注入的，我们看一下代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ReactComponentEnvironment = <span class="built_in">require</span>(<span class="string">'ReactComponentEnvironment'</span>);</span><br><span class="line"><span class="keyword">var</span> ReactComponentBrowserEnvironment = <span class="built_in">require</span>(<span class="string">'ReactComponentBrowserEnvironment'</span>);</span><br><span class="line"><span class="keyword">var</span> ReactDOMComponent = <span class="built_in">require</span>(<span class="string">'ReactDOMComponent'</span>);</span><br><span class="line"><span class="keyword">var</span> ReactDOMComponentTree = <span class="built_in">require</span>(<span class="string">'ReactDOMComponentTree'</span>);</span><br><span class="line"><span class="keyword">var</span> ReactDOMEmptyComponent = <span class="built_in">require</span>(<span class="string">'ReactDOMEmptyComponent'</span>);</span><br><span class="line"><span class="keyword">var</span> ReactDOMTextComponent = <span class="built_in">require</span>(<span class="string">'ReactDOMTextComponent'</span>);</span><br><span class="line"><span class="keyword">var</span> ReactDefaultBatchingStrategy = <span class="built_in">require</span>(<span class="string">'ReactDefaultBatchingStrategy'</span>);</span><br><span class="line"><span class="keyword">var</span> ReactEmptyComponent = <span class="built_in">require</span>(<span class="string">'ReactEmptyComponent'</span>);</span><br><span class="line"><span class="keyword">var</span> ReactGenericBatching = <span class="built_in">require</span>(<span class="string">'ReactGenericBatching'</span>);</span><br><span class="line"><span class="keyword">var</span> ReactHostComponent = <span class="built_in">require</span>(<span class="string">'ReactHostComponent'</span>);</span><br><span class="line"><span class="keyword">var</span> ReactReconcileTransaction = <span class="built_in">require</span>(<span class="string">'ReactReconcileTransaction'</span>);</span><br><span class="line"><span class="keyword">var</span> ReactUpdates = <span class="built_in">require</span>(<span class="string">'ReactUpdates'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> findDOMNode = <span class="built_in">require</span>(<span class="string">'findDOMNode'</span>);</span><br><span class="line"><span class="keyword">var</span> getHostComponentFromComposite = <span class="built_in">require</span>(<span class="string">'getHostComponentFromComposite'</span>);</span><br><span class="line"></span><br><span class="line">ReactGenericBatching.injection.injectStackBatchedUpdates(</span><br><span class="line">  ReactUpdates.batchedUpdates,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">ReactHostComponent.injection.injectGenericComponentClass(ReactDOMComponent);</span><br><span class="line"></span><br><span class="line">ReactHostComponent.injection.injectTextComponentClass(ReactDOMTextComponent);</span><br><span class="line"></span><br><span class="line">ReactEmptyComponent.injection.injectEmptyComponentFactory(<span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  instantiate,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ReactDOMEmptyComponent(instantiate);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ReactUpdates.injection.injectReconcileTransaction(ReactReconcileTransaction);</span><br><span class="line">ReactUpdates.injection.injectBatchingStrategy(ReactDefaultBatchingStrategy);</span><br><span class="line"></span><br><span class="line">ReactComponentEnvironment.injection.injectEnvironment(</span><br><span class="line">  ReactComponentBrowserEnvironment,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">findDOMNode._injectStack(<span class="function"><span class="keyword">function</span>(<span class="params">inst</span>) </span>&#123;</span><br><span class="line">  inst = getHostComponentFromComposite(inst);</span><br><span class="line">  <span class="keyword">return</span> inst ? ReactDOMComponentTree.getNodeFromInstance(inst) : <span class="literal">null</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可以看到，这个模块通过 <code>ReactHostComponent.injection</code> 注入了 ReactDOMComponent 和 ReactDOMTextComponent. 同时也注入了一些其他模块，这个我们后面还会用到。</p><p>这里 ReactDOMComponent 和 ReactDOMTextComponent 才是真是的生成 DOM 标记的模块，它们的内容过多，但是代码比较简单了，这里就不细说了。总之调用这两个模块的 <code>mountComponent</code> 方法都会生成 DOM Markup. 不同的地方在于， ReactDOMComponent 会如下结构的 Markup<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  node: node,</span><br><span class="line">  children: [],</span><br><span class="line">  html: <span class="literal">null</span>,</span><br><span class="line">  text: <span class="literal">null</span>,</span><br><span class="line">  toString</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而 ReactDOMTextComponent 会直接生成要渲染在 DOM 里面的 <code>String</code> 类型的文本。</p><h3 id="ReactCompositeComponent"><a href="#ReactCompositeComponent" class="headerlink" title="ReactCompositeComponent"></a>ReactCompositeComponent</h3><p>最后一类组件应该是 <code>ReactCompositeComponentWrapper</code>, 但查看 instantiateReactComponent 里面的这两段代码：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ReactCompositeComponentWrapper = <span class="function"><span class="keyword">function</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.construct(element);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(</span><br><span class="line">  ReactCompositeComponentWrapper.prototype,</span><br><span class="line">  ReactCompositeComponent,</span><br><span class="line">  &#123;</span><br><span class="line">    _instantiateReactComponent: instantiateReactComponent,</span><br><span class="line">  &#125;,</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>当调用 <code>this.construct</code> 的时候，还是调用到了 ReactCompositeComponent ,这个就是用户自定义的组件。</p><h3 id="ReactUpdates-batchedUpdates"><a href="#ReactUpdates-batchedUpdates" class="headerlink" title="ReactUpdates.batchedUpdates"></a>ReactUpdates.batchedUpdates</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">batchedUpdates</span>(<span class="params">callback, a, b, c, d, e</span>) </span>&#123;</span><br><span class="line">  ensureInjected();</span><br><span class="line">  <span class="keyword">return</span> batchingStrategy.batchedUpdates(callback, a, b, c, d, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 ReactUpdates 里面是 通过 batchingStrategy 调用 batchedUpdate. 而 batchingStrategy 也是前面说到的 ReactDOMStackInjection 来注入进去的。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ReactUpdates.injection.injectReconcileTransaction(ReactReconcileTransaction);</span><br><span class="line">ReactUpdates.injection.injectBatchingStrategy(ReactDefaultBatchingStrategy);</span><br></pre></td></tr></table></figure></p><p>ReactUpdates 共注入了两个模块，分别是 ReactReconcileTransaction 和 ReactDefaultBatchingStrategy. </p><p>先来看一下 ReactDefaultBatchingStrategy, ReactReconcileTransaction 后面碰到再说，来看一下它的代码：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ReactUpdates = <span class="built_in">require</span>(<span class="string">'ReactUpdates'</span>);</span><br><span class="line"><span class="keyword">var</span> Transaction = <span class="built_in">require</span>(<span class="string">'Transaction'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> emptyFunction = <span class="built_in">require</span>(<span class="string">'fbjs/lib/emptyFunction'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> RESET_BATCHED_UPDATES = &#123;</span><br><span class="line">  initialize: emptyFunction,</span><br><span class="line">  close: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ReactDefaultBatchingStrategy.isBatchingUpdates = <span class="literal">false</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> FLUSH_BATCHED_UPDATES = &#123;</span><br><span class="line">  initialize: emptyFunction,</span><br><span class="line">  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ReactDefaultBatchingStrategyTransaction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.reinitializeTransaction();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(ReactDefaultBatchingStrategyTransaction.prototype, Transaction, &#123;</span><br><span class="line">  getTransactionWrappers: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> TRANSACTION_WRAPPERS;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> transaction = <span class="keyword">new</span> ReactDefaultBatchingStrategyTransaction();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ReactDefaultBatchingStrategy = &#123;</span><br><span class="line">  isBatchingUpdates: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Call the provided function in a context within which calls to `setState`</span></span><br><span class="line"><span class="comment">   * and friends are batched such that components aren't updated unnecessarily.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  batchedUpdates: <span class="function"><span class="keyword">function</span>(<span class="params">callback, a, b, c, d, e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;</span><br><span class="line"></span><br><span class="line">    ReactDefaultBatchingStrategy.isBatchingUpdates = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The code is written this way to avoid extra allocations</span></span><br><span class="line">    <span class="keyword">if</span> (alreadyBatchingUpdates) &#123;</span><br><span class="line">      <span class="comment">// 如果当前 updates 已经完成，那么直接调用 callback</span></span><br><span class="line">      <span class="keyword">return</span> callback(a, b, c, d, e);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 通过事务的方式去调用 callback</span></span><br><span class="line">      <span class="keyword">return</span> transaction.perform(callback, <span class="literal">null</span>, a, b, c, d, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>可以看到我们前面调用的 <code>ReactUpdates.batchUpdates</code> 实际上调用到了这里的 batchedUpdates, 里面的逻辑也很简单。</p><p>这里面用到了一个 transaction 方法，这里我理解为“事务”。也就是说当如果当前正在进行一次更新，那么就通过事务的方式去调用这个 callback.</p><h4 id="transaction"><a href="#transaction" class="headerlink" title="transaction"></a>transaction</h4><p>transaction 在 React 源码里面使用非常广泛，作用是通过事务的方式去调用一个方法。</p><p>用一个或多个 wrapper 把方法包裹起来，在方法调用前和调用之后依次执行。事务会确保 wrapper 的 initialize 和 close 方法都会执行，无论要执行的方法执行成功或失败报错，看看它的源码解释就很明白了：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">* <span class="xml"><span class="tag">&lt;<span class="name">pre</span>&gt;</span></span></span><br><span class="line"><span class="xml">*                       wrappers (injected at creation time)</span></span><br><span class="line"><span class="xml">*                                      +        +</span></span><br><span class="line"><span class="xml">*                                      |        |</span></span><br><span class="line"><span class="xml">*                    +-----------------|--------|--------------+</span></span><br><span class="line"><span class="xml">*                    |                 v        |              |</span></span><br><span class="line"><span class="xml">*                    |      +---------------+   |              |</span></span><br><span class="line"><span class="xml">*                    |   +--|    wrapper1   |---|----+         |</span></span><br><span class="line"><span class="xml">*                    |   |  +---------------+   v    |         |</span></span><br><span class="line"><span class="xml">*                    |   |          +-------------+  |         |</span></span><br><span class="line"><span class="xml">*                    |   |     +----|   wrapper2  |--------+   |</span></span><br><span class="line"><span class="xml">*                    |   |     |    +-------------+  |     |   |</span></span><br><span class="line"><span class="xml">*                    |   |     |                     |     |   |</span></span><br><span class="line"><span class="xml">*                    |   v     v                     v     v   | wrapper</span></span><br><span class="line"><span class="xml">*                    | +---+ +---+   +---------+   +---+ +---+ | invariants</span></span><br><span class="line"><span class="xml">* perform(anyMethod) | |   | |   |   |         |   |   | |   | | maintained</span></span><br><span class="line"><span class="xml">* +-----------------&gt;|-|---|-|---|--&gt;|anyMethod|---|---|-|---|-|--------&gt;</span></span><br><span class="line"><span class="xml">*                    | |   | |   |   |         |   |   | |   | |</span></span><br><span class="line"><span class="xml">*                    | |   | |   |   |         |   |   | |   | |</span></span><br><span class="line"><span class="xml">*                    | |   | |   |   |         |   |   | |   | |</span></span><br><span class="line"><span class="xml">*                    | +---+ +---+   +---------+   +---+ +---+ |</span></span><br><span class="line"><span class="xml">*                    |  initialize                    close    |</span></span><br><span class="line"><span class="xml">*                    +-----------------------------------------+</span></span><br><span class="line"><span class="xml">* <span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><p>这里我们再回到刚才的 ReactDefaultBatchingStrategy, 代码里面有两个 wrapper.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> RESET_BATCHED_UPDATES = &#123;</span><br><span class="line">  initialize: emptyFunction,</span><br><span class="line">  close: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ReactDefaultBatchingStrategy.isBatchingUpdates = <span class="literal">false</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> FLUSH_BATCHED_UPDATES = &#123;</span><br><span class="line">  initialize: emptyFunction,</span><br><span class="line">  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>它们的 initialize 方法都是一个空函数，close 方法分别是：</p><ol><li>把当前的更新状态置为 false</li><li><code>flushBatchedUpdates</code> 这个方法比较复杂，这里不展开讲，主要是确保所有组件能够正确更新（<code>flushBatchedUpdates-&gt;ReactUpdates.runBatchedUpdates-&gt;ReactCompositeComponent.performUpdateIfNecessary</code>）</li></ol><p>现在回到上面的代码：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ReactUpdates.batchedUpdates(</span><br><span class="line">  batchedMountComponentIntoNode,</span><br><span class="line">  componentInstance,</span><br><span class="line">  container,</span><br><span class="line">  shouldReuseMarkup,</span><br><span class="line">  context,</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>可以知道，这里是调用了 batchedMountComponentIntoNode 进行后续的工作。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">batchedMountComponentIntoNode</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  componentInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">  container,</span></span></span><br><span class="line"><span class="function"><span class="params">  shouldReuseMarkup,</span></span></span><br><span class="line"><span class="function"><span class="params">  context,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> transaction = ReactUpdates.ReactReconcileTransaction.getPooled(</span><br><span class="line">    <span class="comment">/* useCreateElement */</span></span><br><span class="line">    !shouldReuseMarkup,</span><br><span class="line">  );</span><br><span class="line">  transaction.perform(</span><br><span class="line">    mountComponentIntoNode,</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    componentInstance,</span><br><span class="line">    container,</span><br><span class="line">    transaction,</span><br><span class="line">    shouldReuseMarkup,</span><br><span class="line">    context,</span><br><span class="line">  );</span><br><span class="line">  ReactUpdates.ReactReconcileTransaction.release(transaction);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里第一条赋值语句就用到了上面注入到 ReactUpdates 里面的另一个模块 ReactReconcileTransaction 即 React 的调度事务模块。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> SELECTION_RESTORATION = &#123;</span><br><span class="line">  initialize: ReactInputSelection.getSelectionInformation,</span><br><span class="line">  close: ReactInputSelection.restoreSelection,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Suppresses events (blur/focus) that could be inadvertently dispatched due to</span></span><br><span class="line"><span class="comment"> * high level DOM manipulations (like temporarily removing a text input from the</span></span><br><span class="line"><span class="comment"> * DOM).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> EVENT_SUPPRESSION = &#123;</span><br><span class="line">  initialize: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> currentlyEnabled = ReactBrowserEventEmitter.isEnabled();</span><br><span class="line">    ReactBrowserEventEmitter.setEnabled(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> currentlyEnabled;</span><br><span class="line">  &#125;,</span><br><span class="line">  close: <span class="function"><span class="keyword">function</span>(<span class="params">previouslyEnabled</span>) </span>&#123;</span><br><span class="line">    ReactBrowserEventEmitter.setEnabled(previouslyEnabled);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Provides a queue for collecting `componentDidMount` and</span></span><br><span class="line"><span class="comment"> * `componentDidUpdate` callbacks during the transaction.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> ON_DOM_READY_QUEUEING = &#123;</span><br><span class="line">  initialize: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.reactMountReady.reset();</span><br><span class="line">  &#125;,</span><br><span class="line">  close: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.reactMountReady.notifyAll();</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">var</span> TRANSACTION_WRAPPERS = [</span><br><span class="line">  SELECTION_RESTORATION,</span><br><span class="line">  EVENT_SUPPRESSION,</span><br><span class="line">  ON_DOM_READY_QUEUEING,</span><br><span class="line">];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ReactReconcileTransaction</span>(<span class="params">useCreateElement</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.reinitializeTransaction();</span><br><span class="line">  <span class="keyword">this</span>.renderToStaticMarkup = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">this</span>.reactMountReady = CallbackQueue.getPooled();</span><br><span class="line">  <span class="keyword">this</span>.useCreateElement = useCreateElement;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">var</span> Mixin = &#123;</span><br><span class="line">  getTransactionWrappers: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> TRANSACTION_WRAPPERS;</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.assign(ReactReconcileTransaction.prototype, Transaction, Mixin);</span><br><span class="line"></span><br><span class="line">PooledClass.addPoolingTo(ReactReconcileTransaction);</span><br></pre></td></tr></table></figure></p><p>这里也是通过事务的方式去调用，它有三个 wrapper:</p><ul><li>Selection Restoration 在更新过程中尽可能不打扰用户的选中范围（selection range）</li><li>Event Suppression 抑制一些不需要的事件分发，比如暂时性删除一个 input 元素而导致的 blur 事件</li><li>On DOM Ready Queueing 在事务执行过程中，提供一个 <code>componentDidMount</code> 和 <code>componentDidUpdate</code> 回调函数的队列</li></ul><p>而后面的 getPooled 方法，是一个利用实例池来避免不必要的 GC 的方法，不过多解释。</p><p>接着用这个事务的方式去调用 mountComponentIntoNode, 详细的看一下这个方法。</p><h3 id="mountComponentIntoNode"><a href="#mountComponentIntoNode" class="headerlink" title="mountComponentIntoNode"></a>mountComponentIntoNode</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountComponentIntoNode</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  wrapperInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">  container,</span></span></span><br><span class="line"><span class="function"><span class="params">  transaction,</span></span></span><br><span class="line"><span class="function"><span class="params">  shouldReuseMarkup,</span></span></span><br><span class="line"><span class="function"><span class="params">  context,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> markup = ReactReconciler.mountComponent(</span><br><span class="line">    wrapperInstance,</span><br><span class="line">    transaction,</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    ReactDOMContainerInfo(wrapperInstance, container),</span><br><span class="line">    context,</span><br><span class="line">    <span class="number">0</span> <span class="comment">/* parentDebugID */</span>,</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  wrapperInstance._renderedComponent._topLevelWrapper = wrapperInstance;</span><br><span class="line">  ReactMount._mountImageIntoNode(</span><br><span class="line">    markup,</span><br><span class="line">    container,</span><br><span class="line">    wrapperInstance,</span><br><span class="line">    shouldReuseMarkup,</span><br><span class="line">    transaction,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里看到了重点变量 <strong>markup</strong> 的操作, 这个就是我们最终要往 DOM 里面渲染的对象。通过 <code>ReactReconciler.mountComponent</code> 方法来得到 markup. <code>ReactReconciler.mountComponent</code> 的源码如下：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mountComponent: <span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  internalInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">  transaction,</span></span></span><br><span class="line"><span class="function"><span class="params">  hostParent,</span></span></span><br><span class="line"><span class="function"><span class="params">  hostContainerInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">  context,</span></span></span><br><span class="line"><span class="function"><span class="params">  parentDebugID, <span class="regexp">//</span> <span class="number">0</span> in production and for roots</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> markup = internalInstance.mountComponent(</span><br><span class="line">    transaction,</span><br><span class="line">    hostParent,</span><br><span class="line">    hostContainerInfo,</span><br><span class="line">    context,</span><br><span class="line">    parentDebugID,</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    internalInstance._currentElement &amp;&amp;</span><br><span class="line">    internalInstance._currentElement.ref != <span class="literal">null</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    transaction.getReactMountReady().enqueue(attachRefs, internalInstance);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> markup;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><p>它又调用了 <code>internalInstance.mountComponent</code>, 这里的 internalInstance 其实就是前面说的通过 instantiateReactComponent 得到的 React Component 实例。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// _renderNewRootComponent</span></span><br><span class="line"><span class="keyword">var</span> componentInstance = instantiateReactComponent(nextElement, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure></p><p>这里的 <code>nextElement</code> 是要渲染的 React root 元素。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// _renderSubtreeIntoContainer</span></span><br><span class="line">    <span class="keyword">var</span> nextWrappedElement = React.createElement(TopLevelWrapper, &#123;</span><br><span class="line">      child: nextElement,</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></p><p>TopLevelWrapper 的实现，需要注意它的 <code>render</code> 方法。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> TopLevelWrapper = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.rootID = topLevelRootCounter++;</span><br><span class="line">&#125;;</span><br><span class="line">TopLevelWrapper.prototype.isReactComponent = &#123;&#125;;</span><br><span class="line">TopLevelWrapper.prototype.render = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.props.child;</span><br><span class="line">&#125;;</span><br><span class="line">TopLevelWrapper.isReactTopLevelWrapper = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></p><p>它的 <code>render</code> 方法里面返回的 <code>this.props.child</code> 就是 nextElement 也就是我们项目代码里面入口 <code>ReactDOM.render(&lt;App/&gt;,document.getElementById(&#39;root&#39;))</code> 里面的 <code>&lt;App/&gt;</code>.</p><p>回到 <code>ReactReconciler.mountComponent</code> 里面的 <code>internalInstance.mountComponent</code>. 通过前面的讲到的 instantiateReactComponent 我们知道返回的组件有三类：</p><ol><li>ReactDOMComponent</li><li>ReactDOMTextComponent</li><li>ReactCompositeComponent</li></ol><p>前两类很简单，都是 DOM 本身的元素，最终会渲染出来它们对应的 Markup. 而 ReactCompositeComponent 比较复杂，我们只看关键代码：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ReactCompositeComponent.mountComponent</span></span><br><span class="line">    <span class="keyword">var</span> Component = <span class="keyword">this</span>._currentElement.type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> updateQueue = transaction.getUpdateQueue();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize the public class</span></span><br><span class="line">    <span class="keyword">var</span> doConstruct = shouldConstruct(Component);</span><br><span class="line">    <span class="keyword">var</span> inst = <span class="keyword">this</span>._constructComponent(</span><br><span class="line">      doConstruct,</span><br><span class="line">      publicProps,</span><br><span class="line">      publicContext,</span><br><span class="line">      updateQueue,</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">var</span> renderedElement;</span><br><span class="line">    <span class="keyword">if</span> (!doConstruct &amp;&amp; (inst == <span class="literal">null</span> || inst.render == <span class="literal">null</span>)) &#123;</span><br><span class="line">      renderedElement = inst;</span><br><span class="line">      inst = <span class="keyword">new</span> StatelessComponent(Component);</span><br><span class="line">      <span class="keyword">this</span>._compositeType = ReactCompositeComponentTypes.StatelessFunctional;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     。...</span><br><span class="line">    &#125;</span><br><span class="line">      markup = <span class="keyword">this</span>.performInitialMount(</span><br><span class="line">        renderedElement,</span><br><span class="line">        hostParent,</span><br><span class="line">        hostContainerInfo,</span><br><span class="line">        transaction,</span><br><span class="line">        context,</span><br><span class="line">      );</span><br></pre></td></tr></table></figure></p><p>首先得到 inst , 得到 inst 的调用栈是这样的： <code>this._constructComponent -&gt; this._constructComponentWithoutOwner</code><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// this._constructComponentWithoutOwner</span></span><br><span class="line">...</span><br><span class="line">   <span class="keyword">var</span> Component = <span class="keyword">this</span>._currentElement.type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (doConstruct) &#123;</span><br><span class="line">      <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        <span class="keyword">return</span> measureLifeCyclePerf(</span><br><span class="line">          () =&gt; <span class="keyword">new</span> Component(publicProps, publicContext, updateQueue),</span><br><span class="line">          <span class="keyword">this</span>._debugID,</span><br><span class="line">          <span class="string">'ctor'</span>,</span><br><span class="line">        );</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Component(publicProps, publicContext, updateQueue);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>根据 <code>_currentElement.type</code> 生成 Component 实例, <code>currentElement.type</code> 即就是继承自 <code>React.Component</code> 的 class 或者纯渲染组件 function.<br>然后声明 renderElement, 对于 stateless (函数声明的纯渲染组件)组件，<code>renderElement = inst</code>, 否则为 undefined.</p><p>接着来看 performInitialMount, </p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (renderedElement === <span class="literal">undefined</span>) &#123;</span><br><span class="line">  renderedElement = <span class="keyword">this</span>._renderValidatedComponent();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> nodeType = ReactNodeTypes.getType(renderedElement);</span><br><span class="line"><span class="keyword">this</span>._renderedNodeType = nodeType;</span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">this</span>._instantiateReactComponent(</span><br><span class="line">  renderedElement,</span><br><span class="line">  nodeType !== ReactNodeTypes.EMPTY <span class="comment">/* shouldHaveDebugID */</span>,</span><br><span class="line">);</span><br><span class="line"><span class="keyword">this</span>._renderedComponent = child;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> markup = ReactReconciler.mountComponent(</span><br><span class="line">  child,</span><br><span class="line">  transaction,</span><br><span class="line">  hostParent,</span><br><span class="line">  hostContainerInfo,</span><br><span class="line">  <span class="keyword">this</span>._processChildContext(context),</span><br><span class="line">  debugID,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>对于非 stateless 组件时，需要对 renderedElement 赋值。调用栈为： <code>this._renderValidatedComponent -&gt; this._renderValidatedComponentWithoutOwnerOrContext</code><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">_renderValidatedComponentWithoutOwnerOrContext: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> inst = <span class="keyword">this</span>._instance;</span><br><span class="line">  <span class="keyword">var</span> renderedElement;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">    renderedElement = measureLifeCyclePerf(</span><br><span class="line">      () =&gt; inst.render(),</span><br><span class="line">      <span class="keyword">this</span>._debugID,</span><br><span class="line">      <span class="string">'render'</span>,</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    renderedElement = inst.render();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">    <span class="comment">// We allow auto-mocks to proceed as if they're returning null.</span></span><br><span class="line">    <span class="keyword">if</span> (renderedElement === <span class="literal">undefined</span> &amp;&amp; inst.render._isMockFunction) &#123;</span><br><span class="line">      <span class="comment">// This is probably bad practice. Consider warning here and</span></span><br><span class="line">      <span class="comment">// deprecating this convenience.</span></span><br><span class="line">      renderedElement = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> renderedElement;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><p>最终得到 renderedElement 也就是 <code>inst.render()</code> 后的结果。</p><p>再往下走 <code>child = this._instantiateReactComponent(renderedElement)</code> 和 <code>markup = ReactReconciler.mountComponent(child,...)</code> . </p><p>可以联想到，这里会不断的循环递归调用 <code>ReactReconciler.mountComponent</code>, 知道 child 不是 ReactCompositeComponent 为止，得到最终的 MarkUp. MarkUp 的数据结构可以在 DOMLazyTree 中找到：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DOMLazyTree</span></span><br><span class="line">&#123;</span><br><span class="line">  node: node,</span><br><span class="line">  children: [],</span><br><span class="line">  html: <span class="literal">null</span>,</span><br><span class="line">  text: <span class="literal">null</span>,</span><br><span class="line">  toString,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>拿到了 MarkUp，就只剩下最后一步了，通过 <code>ReactMount._mountImageIntoNode</code> 来吧 MarkUp 挂载到实际 DOM 中。</p><h3 id="ReactMount-mountImageIntoNode"><a href="#ReactMount-mountImageIntoNode" class="headerlink" title="ReactMount._mountImageIntoNode"></a>ReactMount._mountImageIntoNode</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">_mountImageIntoNode: <span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  markup,</span></span></span><br><span class="line"><span class="function"><span class="params">  container,</span></span></span><br><span class="line"><span class="function"><span class="params">  instance,</span></span></span><br><span class="line"><span class="function"><span class="params">  shouldReuseMarkup,</span></span></span><br><span class="line"><span class="function"><span class="params">  transaction,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  invariant(</span><br><span class="line">    isValidContainer(container),</span><br><span class="line">    <span class="string">'mountComponentIntoNode(...): Target container is not valid.'</span>,</span><br><span class="line">  );</span><br><span class="line">  <span class="comment">// 首次渲染，这里为 shouldReuseMarkup = false ，里面都是更新的逻辑</span></span><br><span class="line">  <span class="keyword">if</span> (shouldReuseMarkup) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 首次渲染，transaction.useCreateElement = true</span></span><br><span class="line">  <span class="keyword">if</span> (transaction.useCreateElement) &#123;</span><br><span class="line">    <span class="keyword">while</span> (container.lastChild) &#123;</span><br><span class="line">      container.removeChild(container.lastChild);</span><br><span class="line">    &#125;</span><br><span class="line">    DOMLazyTree.insertTreeBefore(container, markup, <span class="literal">null</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    setInnerHTML(container, markup);</span><br><span class="line">    ReactDOMComponentTree.precacheNode(instance, container.firstChild);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>逻辑很简单，有两种方式把 markup 渲染到 DOM 中：</p><ul><li>清空给定的容器组件，然后把 markup 插入到给定的容器中</li><li>调用 <code>setInnerHTML</code> 来把 markup 插入到给定容器中，并缓存虚拟 DOM 到实际的 DOM 节点上</li></ul><p>对于初次渲染， 会执行第一种方法，清空容器组件，把 markup 挂载到实际的 DOM 中。调用栈：<code>DOMLazyTree.insertTreeBefore -&gt; insertTreeChildren</code><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertTreeChildren</span>(<span class="params">tree</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!enableLazy) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> node = tree.node;</span><br><span class="line">  <span class="keyword">var</span> children = tree.children;</span><br><span class="line">  <span class="keyword">if</span> (children.length) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; children.length; i++) &#123;</span><br><span class="line">      insertTreeBefore(node, children[i], <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tree.html != <span class="literal">null</span>) &#123;</span><br><span class="line">    setInnerHTML(node, tree.html);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tree.text != <span class="literal">null</span>) &#123;</span><br><span class="line">    setTextContent(node, tree.text);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>递归的挂载所有子组件到 DOM 中。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>那么到这里整个初次渲染的逻辑就算走完了，整体上可以看到 React 和 ReactDOM 的代码抽象程度非常高，以至于代码阅读起来非常的绕。本文也只限于整体的流程，没有深究细节，因为细节太多了。</p><p>最后整理了一个 <code>ReactDOM.render</code> 执行后流程关系图，能一定程度上帮助理解它的整过过程：<br>图很大，点击放大后也看不清，建议保存到本地后浏览，会看的清晰点。</p><img src="/2017/09/20/how-react-render-component-to-dom/ReactDOM.png" title="ReactDOM.render"><h1 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h1><ul><li><a href="/2017/09/20/react-source-code-analyze-1/" title="React 源码浅析之 - 入口文件">React 源码浅析之 - 入口文件</a></li><li><a href="/2017/09/20/react-source-code-analyze-2/" title="React 源码浅析之 - ReactBaseClasses">React 源码浅析之 - ReactBaseClasses</a></li><li><a href="/2017/09/20/react-source-code-analyze-3/" title="React 源码浅析之 - ReactChildren">React 源码浅析之 - ReactChildren</a></li><li><a href="/2017/09/20/react-source-code-analyze-4/" title="React 源码浅析之 - ReactElement">React 源码浅析之 - ReactElement</a></li><li><a href="/2017/09/20/react-source-code-analyze-5/" title="React 源码浅析之 - onlyChildren">React 源码浅析之 - onlyChildren</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当我们在开发 React 项目中，第一次调用 &lt;code&gt;ReactDOM.render&lt;/code&gt; 的时候都发生了什么呢？&lt;br&gt;今天就从源码角度来追踪一下这个问题（主要看流程， 而不纠结与细节）。&lt;/p&gt;
&lt;h2 id=&quot;ReactDOMStackEntry&quot;&gt;&lt;a href=&quot;#ReactDOMStackEntry&quot; class=&quot;headerlink&quot; title=&quot;ReactDOMStackEntry&quot;&gt;&lt;/a&gt;ReactDOMStackEntry&lt;/h2&gt;&lt;p&gt;首先我们可以从 ReactDOM 的入口文件 ReactDOMStackEntry.js 中找到 render 方法。可以看到，&lt;code&gt;render&lt;/code&gt; 方法是 ReactMount 组件提供的。&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; ReactDOMStack = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  findDOMNode: findDOMNode,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  render: ReactMount.render,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  unmountComponentAtNode: ReactMount.unmountComponentAtNode,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  version: ReactVersion,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;/* eslint-disable camelcase */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  unstable_batchedUpdates: ReactGenericBatching.batchedUpdates,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  unstable_renderSubtreeIntoContainer: ReactMount.renderSubtreeIntoContainer,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;/* eslint-enable camelcase */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// For TapEventPlugin which is popular in open source&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    EventPluginHub: &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;EventPluginHub&#39;&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Used by test-utils&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    EventPluginRegistry: &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;EventPluginRegistry&#39;&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    EventPropagators: &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;EventPropagators&#39;&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ReactControlledComponent: &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;ReactControlledComponent&#39;&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ReactDOMComponentTree,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ReactDOMEventListener: &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;ReactDOMEventListener&#39;&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ReactUpdates: ReactUpdates,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;ReactMount-render&quot;&gt;&lt;a href=&quot;#ReactMount-render&quot; class=&quot;headerlink&quot; title=&quot;ReactMount.render&quot;&gt;&lt;/a&gt;ReactMount.render&lt;/h2&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;render: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;nextElement, container, callback&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; ReactMount._renderSubtreeIntoContainer(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    nextElement,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    container,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    callback,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;又调到了 &lt;code&gt;_renderSubtreeIntoContainer&lt;/code&gt; 方法, 这个方法核心内容如下：&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="https://blog.kisnows.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="React" scheme="https://blog.kisnows.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>React 源码浅析之 - onlyChildren</title>
    <link href="https://blog.kisnows.com/2017/09/20/react-source-code-analyze-5/"/>
    <id>https://blog.kisnows.com/2017/09/20/react-source-code-analyze-5/</id>
    <published>2017-09-20T08:27:39.000Z</published>
    <updated>2017-10-14T07:27:47.607Z</updated>
    
    <content type="html"><![CDATA[<p>这个模块的代码非常简单，短短十几行。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ReactElement = <span class="built_in">require</span>(<span class="string">'ReactElement'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> invariant = <span class="built_in">require</span>(<span class="string">'fbjs/lib/invariant'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onlyChild</span>(<span class="params">children</span>) </span>&#123;</span><br><span class="line">  invariant(</span><br><span class="line">    ReactElement.isValidElement(children),</span><br><span class="line">    <span class="string">'React.Children.only expected to receive a single React element child.'</span>,</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> children;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = onlyChild;</span><br></pre></td></tr></table></figure><p>就是判断传入的 children 是不是一个合法的 React 元素，否则就抛错出来。判断的逻辑就在 ReactElement 模块里面：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ReactElement.isValidElement = <span class="function"><span class="keyword">function</span>(<span class="params">object</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="keyword">typeof</span> object === <span class="string">'object'</span> &amp;&amp;</span><br><span class="line">    object !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">    object.$$<span class="keyword">typeof</span> === REACT_ELEMENT_TYPE</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><a id="more"></a><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>那么到这里为止，所有 React 本身提供的 API 和模块就算是看完了。但是光看 React 本身的这些代码，其实并不能解决什么问题，比如 React Component 的生命周期是怎么实现的， setState 是怎么运作的，以及是如何把 React Component 渲染到浏览器中的，还有很多问题。<br>有机会我会继续寻找这些答案。</p><h1 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h1><ul><li><a href="/2017/09/20/react-source-code-analyze-1/" title="React 源码浅析之 - 入口文件">React 源码浅析之 - 入口文件</a></li><li><a href="/2017/09/20/react-source-code-analyze-2/" title="React 源码浅析之 - ReactBaseClasses">React 源码浅析之 - ReactBaseClasses</a></li><li><a href="/2017/09/20/react-source-code-analyze-3/" title="React 源码浅析之 - ReactChildren">React 源码浅析之 - ReactChildren</a></li><li><a href="/2017/09/20/react-source-code-analyze-4/" title="React 源码浅析之 - ReactElement">React 源码浅析之 - ReactElement</a></li><li><a href="/2017/09/20/react-source-code-analyze-5/" title="React 源码浅析之 - onlyChildren">React 源码浅析之 - onlyChildren</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个模块的代码非常简单，短短十几行。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; ReactElement = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;ReactElement&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; invariant = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;fbjs/lib/invariant&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;onlyChild&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;children&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  invariant(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ReactElement.isValidElement(children),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;React.Children.only expected to receive a single React element child.&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; children;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;module&lt;/span&gt;.exports = onlyChild;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;就是判断传入的 children 是不是一个合法的 React 元素，否则就抛错出来。判断的逻辑就在 ReactElement 模块里面：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ReactElement.isValidElement = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;object&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; object === &lt;span class=&quot;string&quot;&gt;&#39;object&#39;&lt;/span&gt; &amp;amp;&amp;amp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    object !== &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    object.$$&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; === REACT_ELEMENT_TYPE&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://blog.kisnows.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="React" scheme="https://blog.kisnows.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>React 源码浅析之 - ReactElement</title>
    <link href="https://blog.kisnows.com/2017/09/20/react-source-code-analyze-4/"/>
    <id>https://blog.kisnows.com/2017/09/20/react-source-code-analyze-4/</id>
    <published>2017-09-20T08:27:33.000Z</published>
    <updated>2017-10-14T07:27:47.607Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ReactElement"><a href="#ReactElement" class="headerlink" title="ReactElement"></a>ReactElement</h2><p>这个模块定义了 React 元素的行为和方法，首先看 ReactElement 函数：</p><h3 id="ReactElement-1"><a href="#ReactElement-1" class="headerlink" title="ReactElement"></a>ReactElement</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ReactElement = <span class="function"><span class="keyword">function</span>(<span class="params">type, key, ref, self, source, owner, props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> element = &#123;</span><br><span class="line">    <span class="comment">// This tag allow us to uniquely identify this as a React Element</span></span><br><span class="line">    $$<span class="keyword">typeof</span>: REACT_ELEMENT_TYPE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Built-in properties that belong on the element</span></span><br><span class="line">    type: type,</span><br><span class="line">    key: key,</span><br><span class="line">    ref: ref,</span><br><span class="line">    props: props,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Record the component responsible for creating this element.</span></span><br><span class="line">    _owner: owner,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">    <span class="comment">// The validation flag is currently mutative. We put it on</span></span><br><span class="line">    <span class="comment">// an external backing store so that we can freeze the whole object.</span></span><br><span class="line">    <span class="comment">// This can be replaced with a WeakMap once they are implemented in</span></span><br><span class="line">    <span class="comment">// commonly used development environments.</span></span><br><span class="line">    element._store = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// To make comparing ReactElements easier for testing purposes, we make</span></span><br><span class="line">    <span class="comment">// the validation flag non-enumerable (where possible, which should</span></span><br><span class="line">    <span class="comment">// include every environment we run tests in), so the test framework</span></span><br><span class="line">    <span class="comment">// ignores it.</span></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(element._store, <span class="string">'validated'</span>, &#123;</span><br><span class="line">      configurable: <span class="literal">false</span>,</span><br><span class="line">      enumerable: <span class="literal">false</span>,</span><br><span class="line">      writable: <span class="literal">true</span>,</span><br><span class="line">      value: <span class="literal">false</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// self and source are DEV only properties.</span></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(element, <span class="string">'_self'</span>, &#123;</span><br><span class="line">      configurable: <span class="literal">false</span>,</span><br><span class="line">      enumerable: <span class="literal">false</span>,</span><br><span class="line">      writable: <span class="literal">false</span>,</span><br><span class="line">      value: self,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// Two elements created in two different places should be considered</span></span><br><span class="line">    <span class="comment">// equal for testing purposes and therefore we hide it from enumeration.</span></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(element, <span class="string">'_source'</span>, &#123;</span><br><span class="line">      configurable: <span class="literal">false</span>,</span><br><span class="line">      enumerable: <span class="literal">false</span>,</span><br><span class="line">      writable: <span class="literal">false</span>,</span><br><span class="line">      value: source,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.freeze) &#123;</span><br><span class="line">      <span class="built_in">Object</span>.freeze(element.props);</span><br><span class="line">      <span class="built_in">Object</span>.freeze(element);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> element;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>抛去其中 DEV 里面的内容，其他部分很简单，定义了一个 React 元素应有属性。包括： type, key, ref, self, source, owner, props.<br><a id="more"></a><br>还有一个 <code>$$typeof</code> 属性，是一个常量，用来判断这个对象是不是一个 React 元素。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> REACT_ELEMENT_TYPE =</span><br><span class="line">  (<span class="keyword">typeof</span> <span class="built_in">Symbol</span> === <span class="string">'function'</span> &amp;&amp; <span class="built_in">Symbol</span>.for &amp;&amp; <span class="built_in">Symbol</span>.for(<span class="string">'react.element'</span>)) ||</span><br><span class="line">  <span class="number">0xeac7</span>;</span><br></pre></td></tr></table></figure></p><h3 id="ReactElement-createElement"><a href="#ReactElement-createElement" class="headerlink" title="ReactElement.createElement"></a>ReactElement.createElement</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ReactElement.createElement = <span class="function"><span class="keyword">function</span>(<span class="params">type, config, children</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> propName;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Reserved names are extracted</span></span><br><span class="line">  <span class="keyword">var</span> props = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> key = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">var</span> ref = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">var</span> source = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (config != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// ref 和 key 都属于保留 props key 值，所以这里需要做判断</span></span><br><span class="line">    <span class="keyword">if</span> (hasValidRef(config)) &#123;</span><br><span class="line">      ref = config.ref;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hasValidKey(config)) &#123;</span><br><span class="line">      key = <span class="string">''</span> + config.key;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// __self 和 __source 这两个属性目前没有看到他们的作用，先放着</span></span><br><span class="line">    self = config.__self === <span class="literal">undefined</span> ? <span class="literal">null</span> : config.__self;</span><br><span class="line">    source = config.__source === <span class="literal">undefined</span> ? <span class="literal">null</span> : config.__source;</span><br><span class="line">    <span class="comment">// Remaining properties are added to a new props object</span></span><br><span class="line">    <span class="comment">// 其他的属性添加到新的 props 对象上，同时需要排除掉保留字段 RESERVED_PROPS</span></span><br><span class="line">    <span class="comment">// var RESERVED_PROPS = &#123;key: true, ref: true, __self: true, __source: true,&#125;;</span></span><br><span class="line">    <span class="keyword">for</span> (propName <span class="keyword">in</span> config) &#123;</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        hasOwnProperty.call(config, propName) &amp;&amp;</span><br><span class="line">        !RESERVED_PROPS.hasOwnProperty(propName)</span><br><span class="line">      ) &#123;</span><br><span class="line">        props[propName] = config[propName];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Children 可以传递一个以上的参数，这些 children 参数都会作为新分配的 props 的属性</span></span><br><span class="line">  <span class="keyword">var</span> childrenLength = <span class="built_in">arguments</span>.length - <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (childrenLength === <span class="number">1</span>) &#123;</span><br><span class="line">    props.children = children;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childrenLength &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> childArray = <span class="built_in">Array</span>(childrenLength);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; childrenLength; i++) &#123;</span><br><span class="line">      childArray[i] = <span class="built_in">arguments</span>[i + <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">Object</span>.freeze) &#123;</span><br><span class="line">        <span class="built_in">Object</span>.freeze(childArray);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    props.children = childArray;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置 defaultProps 属性</span></span><br><span class="line">  <span class="keyword">if</span> (type &amp;&amp; type.defaultProps) &#123;</span><br><span class="line">    <span class="keyword">var</span> defaultProps = type.defaultProps;</span><br><span class="line">    <span class="keyword">for</span> (propName <span class="keyword">in</span> defaultProps) &#123;</span><br><span class="line">      <span class="keyword">if</span> (props[propName] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        props[propName] = defaultProps[propName];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 开发环境下，如果使用了保留字段 key 和 ref ，那么进行控制台报错提醒</span></span><br><span class="line">  <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">    <span class="keyword">if</span> (key || ref) &#123;</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        <span class="keyword">typeof</span> props.$$<span class="keyword">typeof</span> === <span class="string">'undefined'</span> ||</span><br><span class="line">        props.$$<span class="keyword">typeof</span> !== REACT_ELEMENT_TYPE</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="keyword">var</span> displayName = <span class="keyword">typeof</span> type === <span class="string">'function'</span></span><br><span class="line">          ? type.displayName || type.name || <span class="string">'Unknown'</span></span><br><span class="line">          : type;</span><br><span class="line">        <span class="keyword">if</span> (key) &#123;</span><br><span class="line">          defineKeyPropWarningGetter(props, displayName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ref) &#123;</span><br><span class="line">          defineRefPropWarningGetter(props, displayName);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回一个 React 元素， ReactCurrentOwner.current 是指当前正处于构建过程中的组件，这里默认是 null</span></span><br><span class="line">  <span class="keyword">return</span> ReactElement(</span><br><span class="line">    type,</span><br><span class="line">    key,</span><br><span class="line">    ref,</span><br><span class="line">    self,</span><br><span class="line">    source,</span><br><span class="line">    ReactCurrentOwner.current,</span><br><span class="line">    props,</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>用给定的参数来创建一个 React 元素，需要注意的是 <code>ref</code> 和 <code>key</code> 属于保留字段，不能作为 props 的属性传递。</p><h3 id="ReactElement-createFactory"><a href="#ReactElement-createFactory" class="headerlink" title="ReactElement.createFactory"></a>ReactElement.createFactory</h3><p>一个简单的工厂函数，用来方便的创建同类型的组件。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ReactElement.createFactory = <span class="function"><span class="keyword">function</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> factory = ReactElement.createElement.bind(<span class="literal">null</span>, type);</span><br><span class="line">  <span class="comment">// Expose the type on the factory and the prototype so that it can be</span></span><br><span class="line">  <span class="comment">// easily accessed on elements. E.g. `&lt;Foo /&gt;.type === Foo`.</span></span><br><span class="line">  <span class="comment">// This should not be named `constructor` since this may not be the function</span></span><br><span class="line">  <span class="comment">// that created the element, and it may not even be a constructor.</span></span><br><span class="line">  <span class="comment">// Legacy hook <span class="doctag">TODO:</span> Warn if this is accessed</span></span><br><span class="line">  factory.type = type;</span><br><span class="line">  <span class="keyword">return</span> factory;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="ReactElement-cloneAndReplaceKey"><a href="#ReactElement-cloneAndReplaceKey" class="headerlink" title="ReactElement.cloneAndReplaceKey"></a>ReactElement.cloneAndReplaceKey</h3><p>这个 API 没用过，可以用来替换一个 React 元素的保留属性： key 值。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ReactElement.cloneAndReplaceKey = <span class="function"><span class="keyword">function</span>(<span class="params">oldElement, newKey</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> newElement = ReactElement(</span><br><span class="line">    oldElement.type,</span><br><span class="line">    newKey,</span><br><span class="line">    oldElement.ref,</span><br><span class="line">    oldElement._self,</span><br><span class="line">    oldElement._source,</span><br><span class="line">    oldElement._owner,</span><br><span class="line">    oldElement.props,</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newElement;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="ReactElement-cloneElement"><a href="#ReactElement-cloneElement" class="headerlink" title="ReactElement.cloneElement"></a>ReactElement.cloneElement</h3><p>cloneElement 方法和 createElement 基本一样，只是前者是通过现有的 React 元素来复制一个新的元素出来。</p><h3 id="ReactElement-isValidElement"><a href="#ReactElement-isValidElement" class="headerlink" title="ReactElement.isValidElement"></a>ReactElement.isValidElement</h3><p>用来判断一个对象是不是一个合法的 React 元素。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ReactElement.isValidElement = <span class="function"><span class="keyword">function</span>(<span class="params">object</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="keyword">typeof</span> object === <span class="string">'object'</span> &amp;&amp;</span><br><span class="line">    object !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">    object.$$<span class="keyword">typeof</span> === REACT_ELEMENT_TYPE</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>用到了上面一开始定义的 $$typeof 属性。</p><h3 id="export"><a href="#export" class="headerlink" title="export"></a>export</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = ReactElement;</span><br></pre></td></tr></table></figure><p>ReactElement 模块就是这么些东西了，主要定义了一个 React 元素应有的属性，以及操作元素的一些方法。</p><h1 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h1><ul><li><a href="/2017/09/20/react-source-code-analyze-1/" title="React 源码浅析之 - 入口文件">React 源码浅析之 - 入口文件</a></li><li><a href="/2017/09/20/react-source-code-analyze-2/" title="React 源码浅析之 - ReactBaseClasses">React 源码浅析之 - ReactBaseClasses</a></li><li><a href="/2017/09/20/react-source-code-analyze-3/" title="React 源码浅析之 - ReactChildren">React 源码浅析之 - ReactChildren</a></li><li><a href="/2017/09/20/react-source-code-analyze-4/" title="React 源码浅析之 - ReactElement">React 源码浅析之 - ReactElement</a></li><li><a href="/2017/09/20/react-source-code-analyze-5/" title="React 源码浅析之 - onlyChildren">React 源码浅析之 - onlyChildren</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;ReactElement&quot;&gt;&lt;a href=&quot;#ReactElement&quot; class=&quot;headerlink&quot; title=&quot;ReactElement&quot;&gt;&lt;/a&gt;ReactElement&lt;/h2&gt;&lt;p&gt;这个模块定义了 React 元素的行为和方法，首先看 ReactElement 函数：&lt;/p&gt;
&lt;h3 id=&quot;ReactElement-1&quot;&gt;&lt;a href=&quot;#ReactElement-1&quot; class=&quot;headerlink&quot; title=&quot;ReactElement&quot;&gt;&lt;/a&gt;ReactElement&lt;/h3&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; ReactElement = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;type, key, ref, self, source, owner, props&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; element = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// This tag allow us to uniquely identify this as a React Element&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    $$&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt;: REACT_ELEMENT_TYPE,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Built-in properties that belong on the element&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    type: type,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    key: key,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ref: ref,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    props: props,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Record the component responsible for creating this element.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _owner: owner,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (__DEV__) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// The validation flag is currently mutative. We put it on&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// an external backing store so that we can freeze the whole object.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// This can be replaced with a WeakMap once they are implemented in&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// commonly used development environments.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    element._store = &amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// To make comparing ReactElements easier for testing purposes, we make&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// the validation flag non-enumerable (where possible, which should&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// include every environment we run tests in), so the test framework&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// ignores it.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;Object&lt;/span&gt;.defineProperty(element._store, &lt;span class=&quot;string&quot;&gt;&#39;validated&#39;&lt;/span&gt;, &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      configurable: &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      enumerable: &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      writable: &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      value: &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// self and source are DEV only properties.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;Object&lt;/span&gt;.defineProperty(element, &lt;span class=&quot;string&quot;&gt;&#39;_self&#39;&lt;/span&gt;, &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      configurable: &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      enumerable: &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      writable: &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      value: self,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Two elements created in two different places should be considered&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// equal for testing purposes and therefore we hide it from enumeration.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;Object&lt;/span&gt;.defineProperty(element, &lt;span class=&quot;string&quot;&gt;&#39;_source&#39;&lt;/span&gt;, &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      configurable: &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      enumerable: &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      writable: &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      value: source,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;built_in&quot;&gt;Object&lt;/span&gt;.freeze) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;built_in&quot;&gt;Object&lt;/span&gt;.freeze(element.props);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;built_in&quot;&gt;Object&lt;/span&gt;.freeze(element);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; element;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;抛去其中 DEV 里面的内容，其他部分很简单，定义了一个 React 元素应有属性。包括： type, key, ref, self, source, owner, props.&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="https://blog.kisnows.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="React" scheme="https://blog.kisnows.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>React 源码浅析之 - ReactChildren</title>
    <link href="https://blog.kisnows.com/2017/09/20/react-source-code-analyze-3/"/>
    <id>https://blog.kisnows.com/2017/09/20/react-source-code-analyze-3/</id>
    <published>2017-09-20T08:19:09.000Z</published>
    <updated>2017-10-14T07:27:47.606Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引入的模块"><a href="#引入的模块" class="headerlink" title="引入的模块"></a>引入的模块</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ReactElement = <span class="built_in">require</span>(<span class="string">'ReactElement'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> emptyFunction = <span class="built_in">require</span>(<span class="string">'fbjs/lib/emptyFunction'</span>);</span><br><span class="line"><span class="keyword">var</span> invariant = <span class="built_in">require</span>(<span class="string">'fbjs/lib/invariant'</span>);</span><br></pre></td></tr></table></figure><p>我们来看一下 ReactElement 模块，其他两个都是工具函数，不用关心。</p><h1 id="Export-的对象"><a href="#Export-的对象" class="headerlink" title="Export 的对象"></a>Export 的对象</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ReactChildren = &#123;</span><br><span class="line">  forEach: forEachChildren,</span><br><span class="line">  map: mapChildren,</span><br><span class="line">  count: countChildren,</span><br><span class="line">  toArray: toArray,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = ReactChildren;</span><br></pre></td></tr></table></figure><p>依次来看一下这个四个 API</p><h2 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">forEachChildren</span>(<span class="params">children, forEachFunc, forEachContext</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (children == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> children;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> traverseContext = getPooledTraverseContext(</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    forEachFunc,</span><br><span class="line">    forEachContext,</span><br><span class="line">  );</span><br><span class="line">  traverseAllChildren(children, forEachSingleChild, traverseContext);</span><br><span class="line">  releaseTraverseContext(traverseContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>入参： children, forEachFunc, forEachContext.<br>首先通过 <code>getPooledTraverseContext</code>  拿到一个遍历的上下文对象 <code>traverseContext</code>，然后调用 traverseAllChildren 方法来遍历所有传入 children 的后代节点。<br>最后释放当前的 <code>traverseContext</code>.<br><a id="more"></a></p><h3 id="getPooledTraverseContext"><a href="#getPooledTraverseContext" class="headerlink" title="getPooledTraverseContext"></a>getPooledTraverseContext</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> POOL_SIZE = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> traverseContextPool = [];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPooledTraverseContext</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  mapResult,</span></span></span><br><span class="line"><span class="function"><span class="params">  keyPrefix,</span></span></span><br><span class="line"><span class="function"><span class="params">  mapFunction,</span></span></span><br><span class="line"><span class="function"><span class="params">  mapContext,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (traverseContextPool.length) &#123;</span><br><span class="line">    <span class="keyword">var</span> traverseContext = traverseContextPool.pop();</span><br><span class="line">    traverseContext.result = mapResult;</span><br><span class="line">    traverseContext.keyPrefix = keyPrefix;</span><br><span class="line">    traverseContext.func = mapFunction;</span><br><span class="line">    traverseContext.context = mapContext;</span><br><span class="line">    traverseContext.count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> traverseContext;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      result: mapResult,</span><br><span class="line">      keyPrefix: keyPrefix,</span><br><span class="line">      func: mapFunction,</span><br><span class="line">      context: mapContext,</span><br><span class="line">      count: <span class="number">0</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义了一个 <code>traverseContextPool</code> 以避免每次重新创建新对象的成本，大小为 10. <code>getPooledTraverseContext</code> 方法接收四个参数，mapResult, keyPrefix, mapFunction, mapContext.<br>然后赋值到 traverseContext 上，除此之外还添加了一个计数器属性 count.</p><h3 id="traverseAllChildren"><a href="#traverseAllChildren" class="headerlink" title="traverseAllChildren"></a>traverseAllChildren</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">traverseAllChildren</span>(<span class="params">children, callback, traverseContext</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (children == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> traverseAllChildrenImpl(children, <span class="string">''</span>, callback, traverseContext);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="string">`traverseAllChildren`</span> 只是个空壳，里面的 <span class="string">`traverseAllChildrenImpl`</span> 才是真正的实现。</span><br><span class="line">** traverseAllChildrenImpl ** </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">traverseAllChildrenImpl</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  children,</span></span></span><br><span class="line"><span class="function"><span class="params">  nameSoFar,</span></span></span><br><span class="line"><span class="function"><span class="params">  callback,</span></span></span><br><span class="line"><span class="function"><span class="params">  traverseContext,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> type = <span class="keyword">typeof</span> children;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (type === <span class="string">'undefined'</span> || type === <span class="string">'boolean'</span>) &#123;</span><br><span class="line">    <span class="comment">// All of the above are perceived as null.</span></span><br><span class="line">    children = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    children === <span class="literal">null</span> ||</span><br><span class="line">    type === <span class="string">'string'</span> ||</span><br><span class="line">    type === <span class="string">'number'</span> ||</span><br><span class="line">    <span class="comment">// The following is inlined from ReactElement. This means we can optimize</span></span><br><span class="line">    <span class="comment">// some checks. React Fiber also inlines this logic for similar purposes.</span></span><br><span class="line">    (type === <span class="string">'object'</span> &amp;&amp; children.$$<span class="keyword">typeof</span> === REACT_ELEMENT_TYPE)</span><br><span class="line">  ) &#123;</span><br><span class="line">    callback(</span><br><span class="line">      traverseContext,</span><br><span class="line">      children,</span><br><span class="line">      <span class="comment">// If it's the only child, treat the name as if it was wrapped in an array</span></span><br><span class="line">      <span class="comment">// so that it's consistent if the number of children grows.</span></span><br><span class="line">      nameSoFar === <span class="string">''</span> ? SEPARATOR + getComponentKey(children, <span class="number">0</span>) : nameSoFar,</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>接收四个参数，首先判断 children 参数的 type ，不合法都认为 children 是 null.<br>紧接着的一堆判断，就是说当 children 是单个合法 React 元素的时候，执行 callback 函数，并返回 1，因为后面会递归的调用当前这个函数，所以这里也是递归调用的出口。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> child;</span><br><span class="line"><span class="keyword">var</span> nextName;</span><br><span class="line"><span class="keyword">var</span> subtreeCount = <span class="number">0</span>; <span class="comment">// Count of children found in the current subtree.</span></span><br><span class="line"><span class="keyword">var</span> nextNamePrefix = nameSoFar === <span class="string">''</span> ? SEPARATOR : nameSoFar + SUBSEPARATOR;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(children)) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; children.length; i++) &#123;</span><br><span class="line">    child = children[i];</span><br><span class="line">    nextName = nextNamePrefix + getComponentKey(child, i);</span><br><span class="line">    subtreeCount += traverseAllChildrenImpl(</span><br><span class="line">      child,</span><br><span class="line">      nextName,</span><br><span class="line">      callback,</span><br><span class="line">      traverseContext,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br></pre></td></tr></table></figure></p><p>当传入的 children 是一个 <code>Array</code> 的时候，遍历这个 Children Array ， 并对里面的每个元素调用当前的函数 <code>traverseAllChildrenImpl</code>.<br>传入的参数中需要注意， nextName 用来给要遍历的 React 元素添加 key 值，callback 和 <code>traverseContext</code> 和当前函数的值都是一样的，保证了每个子元素也能应用当前的 callback 且能访问到原始的 <code>traverseContext</code>.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> iteratorFn =</span><br><span class="line">    (ITERATOR_SYMBOL &amp;&amp; children[ITERATOR_SYMBOL]) ||</span><br><span class="line">    children[FAUX_ITERATOR_SYMBOL];</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> iteratorFn === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      <span class="comment">// Warn about using Maps as children</span></span><br><span class="line">      <span class="keyword">if</span> (iteratorFn === children.entries) &#123;</span><br><span class="line">        warning(</span><br><span class="line">          didWarnAboutMaps,</span><br><span class="line">          <span class="string">'Using Maps as children is unsupported and will likely yield '</span> +</span><br><span class="line">            <span class="string">'unexpected results. Convert it to a sequence/iterable of keyed '</span> +</span><br><span class="line">            <span class="string">'ReactElements instead.%s'</span>,</span><br><span class="line">          getStackAddendum(),</span><br><span class="line">        );</span><br><span class="line">        didWarnAboutMaps = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> iterator = iteratorFn.call(children);</span><br><span class="line">    <span class="keyword">var</span> step;</span><br><span class="line">    <span class="keyword">var</span> ii = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!(step = iterator.next()).done) &#123;</span><br><span class="line">      child = step.value;</span><br><span class="line">      nextName = nextNamePrefix + getComponentKey(child, ii++);</span><br><span class="line">      subtreeCount += traverseAllChildrenImpl(</span><br><span class="line">        child,</span><br><span class="line">        nextName,</span><br><span class="line">        callback,</span><br><span class="line">        traverseContext,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type === <span class="string">'object'</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> addendum = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      addendum =</span><br><span class="line">        <span class="string">' If you meant to render a collection of children, use an array '</span> +</span><br><span class="line">        <span class="string">'instead.'</span> +</span><br><span class="line">        getStackAddendum();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> childrenString = <span class="string">''</span> + children;</span><br><span class="line">    invariant(</span><br><span class="line">      <span class="literal">false</span>,</span><br><span class="line">      <span class="string">'Objects are not valid as a React child (found: %s).%s'</span>,</span><br><span class="line">      childrenString === <span class="string">'[object Object]'</span></span><br><span class="line">        ? <span class="string">'object with keys &#123;'</span> + <span class="built_in">Object</span>.keys(children).join(<span class="string">', '</span>) + <span class="string">'&#125;'</span></span><br><span class="line">        : childrenString,</span><br><span class="line">      addendum,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当不是 Array 但是一个可迭代的对象的时候，和上面一样，递归调用 traverseAllChildrenImpl 方法。<br>对于其他情况，认为 child 不合法，进行报错。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> subtreeCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后返回所有后代元素的数量。<br>整体上来看 <code>traverseAllChildrenImpl</code> 方法的作用就是，遍历给定 children 的所有后代元素，在每个后代元素上调用 callback 方法，并给每个元素分配一个当前上下文下唯一的 key 值作为参数要传入的参数。</p><p>回到 forEach 方法：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">traverseAllChildren(children, forEachSingleChild, traverseContext);</span><br></pre></td></tr></table></figure></p><p>这一句就是说遍历给定 children 的所有后代元素，并给它们调用 forEachSingleChild 方法。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">forEachSingleChild</span>(<span class="params">bookKeeping, child, name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> &#123;func, context&#125; = bookKeeping;</span><br><span class="line">  func.call(context, child, bookKeeping.count++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个传入的 callback 方法 <code>forEachSingleChild</code> 就是从入参 bookKeeping 也就是 <code>traverseContext</code> 中拿到 <code>func</code> 和 context，把 context 作为 <code>func</code> 的上下文， child 和计数器 count 作为参数进行调用。这里的 <code>func</code> 就是 <code>forEachChildren</code> 的入参 <code>forEachFunc</code>，也就是需用最终用户提供的函数。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">releaseTraverseContext(traverseContext);</span><br></pre></td></tr></table></figure></p><p>释放当前的 <code>traverseContext</code> 也就是把 <code>traverseContext</code> 的属性都置为 <code>null</code> 并放入 <code>traverseContextPool</code> 中供后续使用，提高使用效率。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">releaseTraverseContext</span>(<span class="params">traverseContext</span>) </span>&#123;</span><br><span class="line">  traverseContext.result = <span class="literal">null</span>;</span><br><span class="line">  traverseContext.keyPrefix = <span class="literal">null</span>;</span><br><span class="line">  traverseContext.func = <span class="literal">null</span>;</span><br><span class="line">  traverseContext.context = <span class="literal">null</span>;</span><br><span class="line">  traverseContext.count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (traverseContextPool.length &lt; POOL_SIZE) &#123;</span><br><span class="line">    traverseContextPool.push(traverseContext);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapChildren</span>(<span class="params">children, func, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (children == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> children;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> result = [];</span><br><span class="line">  mapIntoWithKeyPrefixInternal(children, result, <span class="literal">null</span>, func, context);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给传入 children 的后代元素调用 func 并返回调用 func 的结果集合。</p><h3 id="mapIntoWithKeyPrefixInternal"><a href="#mapIntoWithKeyPrefixInternal" class="headerlink" title="mapIntoWithKeyPrefixInternal"></a>mapIntoWithKeyPrefixInternal</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapIntoWithKeyPrefixInternal</span>(<span class="params">children, array, prefix, func, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> escapedPrefix = <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">if</span> (prefix != <span class="literal">null</span>) &#123;</span><br><span class="line">    escapedPrefix = escapeUserProvidedKey(prefix) + <span class="string">'/'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> traverseContext = getPooledTraverseContext(</span><br><span class="line">    array,</span><br><span class="line">    escapedPrefix,</span><br><span class="line">    func,</span><br><span class="line">    context,</span><br><span class="line">  );</span><br><span class="line">  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);</span><br><span class="line">  releaseTraverseContext(traverseContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，如果传入了 prefix ，那么转义 prefix 作为 <code>traverseContext</code> 的 prefix key.<br>然后拿到一个 <code>traverseContext</code> 对象，接着和 <code>forEachChildren</code> 一样，遍历所有 children 的后代元素并执行给定的 callback 函数，最后对 <code>traverseContext</code> 进行释放。</p><p>唯一的不同就是这个 callback 方法：<code>mapSingleChildIntoContext</code> .</p><h3 id="mapSingleChildIntoContext"><a href="#mapSingleChildIntoContext" class="headerlink" title="mapSingleChildIntoContext"></a>mapSingleChildIntoContext</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapSingleChildIntoContext</span>(<span class="params">bookKeeping, child, childKey</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> &#123;result, keyPrefix, func, context&#125; = bookKeeping;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> mappedChild = func.call(context, child, bookKeeping.count++);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(mappedChild)) &#123;</span><br><span class="line">    mapIntoWithKeyPrefixInternal(</span><br><span class="line">      mappedChild,</span><br><span class="line">      result,</span><br><span class="line">      childKey,</span><br><span class="line">      emptyFunction.thatReturnsArgument,</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mappedChild != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ReactElement.isValidElement(mappedChild)) &#123;</span><br><span class="line">      mappedChild = ReactElement.cloneAndReplaceKey(</span><br><span class="line">        mappedChild,</span><br><span class="line">        <span class="comment">// Keep both the (mapped) and old keys if they differ, just as</span></span><br><span class="line">        <span class="comment">// traverseAllChildren used to do for objects as children</span></span><br><span class="line">        keyPrefix +</span><br><span class="line">          (mappedChild.key &amp;&amp; (!child || child.key !== mappedChild.key)</span><br><span class="line">            ? escapeUserProvidedKey(mappedChild.key) + <span class="string">'/'</span></span><br><span class="line">            : <span class="string">''</span>) +</span><br><span class="line">          childKey,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    result.push(mappedChild);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法和上面的 <code>forEachSingleChildren</code> 很像。从 bookKeeping 上拿到 result , keyPrefix, func, context.<br>Result 其实就是 <code>mapChildren</code> 里面一开始定义的空数组， keyPrefix 就是 <code>mapIntoWithKeyPrefixInternal</code> 里面 escapedPrefix ， func 和 context 都是 <code>mapChildren</code> 对应的入参。</p><p>首先定义 <code>mappedChild</code> 为用户传入的 <code>mapFunc</code> 函数调用的返回值，然后判断这个返回值 <code>mappedChild</code> 是不是一个 <code>Array</code>.<br>如果是，那么循环调用 <code>mapIntoWithKeyPrefixInternal</code> 方法；否则在不为 <code>null</code> 的情况且是一个合法 React 元素的时候，用一个通过 keyPrefix , 用户分配的 key 即 <code>mappedChild.key</code> 和原有的 childkey 组成新 key 值的 <code>mappedChild</code> 的克隆元素作为 map 的结果，push 到 result 中。</p><p>整个 <code>mapChildren</code> 方法，就是对提供的 children 的每个后代元素调用 <code>mapFunc</code> 方法，给返回的结果设置新的 key ，最后把每一个执行的结果 <code>mappedChild</code> 放入到一个列表中返回给用户。</p><h3 id="countChildren"><a href="#countChildren" class="headerlink" title="countChildren"></a>countChildren</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countChildren</span>(<span class="params">children, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> traverseAllChildren(children, emptyFunction.thatReturnsNull, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个就很简单了，只是通过遍历返回所有后代节点的个数。<br><code>emptyFunction.thatReturnsNull</code><br>就是一个返回为 null 的函数。</p><h3 id="toArray"><a href="#toArray" class="headerlink" title="toArray"></a>toArray</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toArray</span>(<span class="params">children</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = [];</span><br><span class="line">  mapIntoWithKeyPrefixInternal(</span><br><span class="line">    children,</span><br><span class="line">    result,</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    emptyFunction.thatReturnsArgument,</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>理解了上面的 mapIntoWithKeyPrefixInternal ，那么这里也很简单了。<br>emptyFunction.thatReturnsArgument, 是一个函数，会返回它的第一个参数。</p><p><strong> mapSingleChildIntoContext </strong><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mappedChild=func.call(context,child,bookKeeping.count++);</span><br></pre></td></tr></table></figure></p><p>那么这句也就是返回 child 本身了。并将结果放入到 result 里面, 最后把所有的 result 返回给调用方。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>ReactChildren 有四个 API ，而这四个 API 主要依赖与两个方法，<code>traverseAllChildrenImpl</code> 和  <code>mapSingleChildIntoContext</code> 其他方法都是在此之上的组合调用。<br>还有一个值得注意的地方，就是用到对象池 <code>traverseContextPool</code> 。个人认为是因为在这里经常会递归调用而频繁的需要新建 <code>traverseContext</code> 对象，而每次都重新新建对象需要在堆里面重新分配内存，成本比较高，所以引入了对象池，以提高性能。</p><h1 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h1><ul><li><a href="/2017/09/20/react-source-code-analyze-1/" title="React 源码浅析之 - 入口文件">React 源码浅析之 - 入口文件</a></li><li><a href="/2017/09/20/react-source-code-analyze-2/" title="React 源码浅析之 - ReactBaseClasses">React 源码浅析之 - ReactBaseClasses</a></li><li><a href="/2017/09/20/react-source-code-analyze-3/" title="React 源码浅析之 - ReactChildren">React 源码浅析之 - ReactChildren</a></li><li><a href="/2017/09/20/react-source-code-analyze-4/" title="React 源码浅析之 - ReactElement">React 源码浅析之 - ReactElement</a></li><li><a href="/2017/09/20/react-source-code-analyze-5/" title="React 源码浅析之 - onlyChildren">React 源码浅析之 - onlyChildren</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;引入的模块&quot;&gt;&lt;a href=&quot;#引入的模块&quot; class=&quot;headerlink&quot; title=&quot;引入的模块&quot;&gt;&lt;/a&gt;引入的模块&lt;/h1&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; ReactElement = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;ReactElement&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; emptyFunction = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;fbjs/lib/emptyFunction&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; invariant = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;fbjs/lib/invariant&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们来看一下 ReactElement 模块，其他两个都是工具函数，不用关心。&lt;/p&gt;
&lt;h1 id=&quot;Export-的对象&quot;&gt;&lt;a href=&quot;#Export-的对象&quot; class=&quot;headerlink&quot; title=&quot;Export 的对象&quot;&gt;&lt;/a&gt;Export 的对象&lt;/h1&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; ReactChildren = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  forEach: forEachChildren,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  map: mapChildren,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  count: countChildren,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  toArray: toArray,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;module&lt;/span&gt;.exports = ReactChildren;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;依次来看一下这个四个 API&lt;/p&gt;
&lt;h2 id=&quot;forEach&quot;&gt;&lt;a href=&quot;#forEach&quot; class=&quot;headerlink&quot; title=&quot;forEach&quot;&gt;&lt;/a&gt;forEach&lt;/h2&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;forEachChildren&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;children, forEachFunc, forEachContext&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (children == &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; children;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; traverseContext = getPooledTraverseContext(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    forEachFunc,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    forEachContext,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  traverseAllChildren(children, forEachSingleChild, traverseContext);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  releaseTraverseContext(traverseContext);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;入参： children, forEachFunc, forEachContext.&lt;br&gt;首先通过 &lt;code&gt;getPooledTraverseContext&lt;/code&gt;  拿到一个遍历的上下文对象 &lt;code&gt;traverseContext&lt;/code&gt;，然后调用 traverseAllChildren 方法来遍历所有传入 children 的后代节点。&lt;br&gt;最后释放当前的 &lt;code&gt;traverseContext&lt;/code&gt;.&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="https://blog.kisnows.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="React" scheme="https://blog.kisnows.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>React 源码浅析之 - ReactBaseClasses</title>
    <link href="https://blog.kisnows.com/2017/09/20/react-source-code-analyze-2/"/>
    <id>https://blog.kisnows.com/2017/09/20/react-source-code-analyze-2/</id>
    <published>2017-09-20T08:19:00.000Z</published>
    <updated>2017-10-14T07:27:47.606Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引入的模块"><a href="#引入的模块" class="headerlink" title="引入的模块"></a>引入的模块</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ReactNoopUpdateQueue = <span class="built_in">require</span>(<span class="string">'ReactNoopUpdateQueue'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> emptyObject = <span class="built_in">require</span>(<span class="string">'fbjs/lib/emptyObject'</span>);</span><br><span class="line"><span class="keyword">var</span> invariant = <span class="built_in">require</span>(<span class="string">'fbjs/lib/invariant'</span>);</span><br><span class="line"><span class="keyword">var</span> lowPriorityWarning = <span class="built_in">require</span>(<span class="string">'lowPriorityWarning'</span>);</span><br></pre></td></tr></table></figure><p>其中， <code>ReactNoopUpdateQueue</code>  是默认的 updater ，用来提供 <code>update</code>, <code>replaceState</code>, <code>setState</code> 的入队操作，但可能是由于是默认 <code>updater</code> 的原因，只提供了 API 和对入参的校验，但没有提供实际的功能。比如：<br><a id="more"></a><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">enqueueSetState: <span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="regexp">//</span> 需要 render 的实例</span></span></span><br><span class="line"><span class="function"><span class="params">  publicInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="regexp">//</span> 接下来要 merge 的 state</span></span></span><br><span class="line"><span class="function"><span class="params">  partialState,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="regexp">//</span> 可选参数，setState 组件 update 后的回调</span></span></span><br><span class="line"><span class="function"><span class="params">  callback,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="regexp">//</span> 可选参数，调用函数的的名字</span></span></span><br><span class="line"><span class="function"><span class="params">  callerName,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  warnNoop(publicInstance, <span class="string">'setState'</span>);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><p>其余几个模块是一些通用辅助模块，就不细说了。</p><h1 id="Export-的对象"><a href="#Export-的对象" class="headerlink" title="Export 的对象"></a>Export 的对象</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  Component: ReactComponent,</span><br><span class="line">  PureComponent: ReactPureComponent,</span><br><span class="line">  AsyncComponent: ReactAsyncComponent,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们依次来看这几个 Component .</p><h2 id="ReactComponent"><a href="#ReactComponent" class="headerlink" title="ReactComponent"></a>ReactComponent</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Base class helpers for the updating state of a component.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ReactComponent</span>(<span class="params">props, context, updater</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.props = props;</span><br><span class="line">  <span class="keyword">this</span>.context = context;</span><br><span class="line">  <span class="keyword">this</span>.refs = emptyObject;</span><br><span class="line">  <span class="comment">// We initialize the default updater but the real one gets injected by the</span></span><br><span class="line">  <span class="comment">// renderer.</span></span><br><span class="line">  <span class="keyword">this</span>.updater = updater || ReactNoopUpdateQueue;</span><br><span class="line">&#125;</span><br><span class="line">ReactComponent.prototype.isReactComponent = &#123;&#125;;</span><br></pre></td></tr></table></figure><p>用来创建基础组件的构造函数，其中 <code>refs</code> 默认是一个空对象，而 <code>updater</code> 默认就是我们上面说的 <code>ReactNoopUpdateQueue</code>.</p><h3 id="setState"><a href="#setState" class="headerlink" title="setState"></a>setState</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ReactComponent.prototype.setState = <span class="function"><span class="keyword">function</span>(<span class="params">partialState, callback</span>) </span>&#123;</span><br><span class="line">  invariant(</span><br><span class="line">    <span class="keyword">typeof</span> partialState === <span class="string">'object'</span> ||</span><br><span class="line">      <span class="keyword">typeof</span> partialState === <span class="string">'function'</span> ||</span><br><span class="line">      partialState == <span class="literal">null</span>,</span><br><span class="line">    <span class="string">'setState(...): takes an object of state variables to update or a '</span> +</span><br><span class="line">      <span class="string">'function which returns an object of state variables.'</span>,</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">this</span>.updater.enqueueSetState(<span class="keyword">this</span>, partialState, callback, <span class="string">'setState'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>给它添加 <code>setState</code> 方法，实际操作就是把下一个要设置的 state 放入到更新队列里面。注释中提到：</p><ul><li>永远使用 setState 这个方法去更改 state ，你应该认为 this.state 是不可变的</li><li>不保证 this.state 会及时更新，也就是说调用 this.state 可能拿到的还是旧的 state</li><li>不保证 setState 会同步调用，有可能会把几个 setState 的调用一次性批量更新掉，一定要在某个 setState 的调用完成后执行-操作，可以提供可选的 callback 函数。</li><li>当一个 callback 函数传入给 setState 的时候，它会在未来的某个时机调用。会用最新的组件参数 (state, props, context). 而这些参数和此时组件本身的 this.* 上的参数值可能会不一样，应为 callback 函数有可能在 receiveProps 之后 shouldComponentUpdate 之前调用，而此时这个新的 state, props 和 context 还没有赋值给 this.</li></ul><p>其核心思想就是说， setState 的调用是异步的，从代码  <code>this.updater.enqueueSetState(this, partialState, callback, &#39;setState&#39;);</code>  中可以看到，只是把要更新的 state 放入到了更新队列里面，而不是直接进行 state 的更新。</p><h3 id="forceUpdate"><a href="#forceUpdate" class="headerlink" title="forceUpdate"></a>forceUpdate</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ReactComponent.prototype.forceUpdate = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.updater.enqueueForceUpdate(<span class="keyword">this</span>, callback, <span class="string">'forceUpdate'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一个强制更新的方法，这个方法不会触发 <code>shoudleComponentUpdate</code> ，但是会正常调用 <code>componentWillUpdate</code> 和 <code>componentDidUpdate</code> .<br>要确保调用这个方法的时候，所有的 DOM 事务操作已经完成。<br>只有在当你知道一个组件的深层次的 state 变化了，但是并没有调用 setState 的时候才需要调用这个方法。</p><h3 id="不推荐的方法"><a href="#不推荐的方法" class="headerlink" title="不推荐的方法"></a>不推荐的方法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Deprecated APIs. These APIs used to exist on classic React classes but since</span></span><br><span class="line"><span class="comment"> * we would like to deprecate them, we're not going to move them over to this</span></span><br><span class="line"><span class="comment"> * modern base class. Instead, we define a getter that warns if it's accessed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">  <span class="keyword">var</span> deprecatedAPIs = &#123;</span><br><span class="line">    isMounted: [</span><br><span class="line">      <span class="string">'isMounted'</span>,</span><br><span class="line">      <span class="string">'Instead, make sure to clean up subscriptions and pending requests in '</span> +</span><br><span class="line">        <span class="string">'componentWillUnmount to prevent memory leaks.'</span>,</span><br><span class="line">    ],</span><br><span class="line">    replaceState: [</span><br><span class="line">      <span class="string">'replaceState'</span>,</span><br><span class="line">      <span class="string">'Refactor your code to use setState instead (see '</span> +</span><br><span class="line">        <span class="string">'https://github.com/facebook/react/issues/3236).'</span>,</span><br><span class="line">    ],</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">var</span> defineDeprecationWarning = <span class="function"><span class="keyword">function</span>(<span class="params">methodName, info</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(ReactComponent.prototype, methodName, &#123;</span><br><span class="line">      get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        lowPriorityWarning(</span><br><span class="line">          <span class="literal">false</span>,</span><br><span class="line">          <span class="string">'%s(...) is deprecated in plain JavaScript React classes. %s'</span>,</span><br><span class="line">          info[<span class="number">0</span>],</span><br><span class="line">          info[<span class="number">1</span>],</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> fnName <span class="keyword">in</span> deprecatedAPIs) &#123;</span><br><span class="line">    <span class="keyword">if</span> (deprecatedAPIs.hasOwnProperty(fnName)) &#123;</span><br><span class="line">      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到 <code>isMounted</code> 和 <code>replaceState</code>  这两个方法，已经被官方认为将要废弃的 API ，在开发过程中应该尽量避免使用它们。</p><h2 id="PureComponent"><a href="#PureComponent" class="headerlink" title="PureComponent"></a>PureComponent</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ReactPureComponent</span>(<span class="params">props, context, updater</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Duplicated from ReactComponent.</span></span><br><span class="line">  <span class="keyword">this</span>.props = props;</span><br><span class="line">  <span class="keyword">this</span>.context = context;</span><br><span class="line">  <span class="keyword">this</span>.refs = emptyObject;</span><br><span class="line">  <span class="comment">// We initialize the default updater but the real one gets injected by the</span></span><br><span class="line">  <span class="comment">// renderer.</span></span><br><span class="line">  <span class="keyword">this</span>.updater = updater || ReactNoopUpdateQueue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ComponentDummy</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">ComponentDummy.prototype = ReactComponent.prototype;</span><br><span class="line"><span class="keyword">var</span> pureComponentPrototype = (ReactPureComponent.prototype = <span class="keyword">new</span> ComponentDummy());</span><br><span class="line">pureComponentPrototype.constructor = ReactPureComponent;</span><br><span class="line"><span class="comment">// Avoid an extra prototype jump for these methods.</span></span><br><span class="line"><span class="built_in">Object</span>.assign(pureComponentPrototype, ReactComponent.prototype);</span><br><span class="line">pureComponentPrototype.isPureReactComponent = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>一个典型 js 实现继承的方式，可以看到 PureComponent 继承自 ReactComponent ，PureComponent 拥有 ReactComponent 的所有属性和方法，并在此基础上多了一个属性：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">pureComponentPrototype.isPureReactComponent = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></p><p>后面在组件更新部分会用到这个属性。</p><h2 id="AsyncComponent"><a href="#AsyncComponent" class="headerlink" title="AsyncComponent"></a>AsyncComponent</h2><p>这个组件在我实际开发过程中还没有用到过，我们来看一下：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ReactAsyncComponent</span>(<span class="params">props, context, updater</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Duplicated from ReactComponent.</span></span><br><span class="line">  <span class="keyword">this</span>.props = props;</span><br><span class="line">  <span class="keyword">this</span>.context = context;</span><br><span class="line">  <span class="keyword">this</span>.refs = emptyObject;</span><br><span class="line">  <span class="comment">// We initialize the default updater but the real one gets injected by the</span></span><br><span class="line">  <span class="comment">// renderer.</span></span><br><span class="line">  <span class="keyword">this</span>.updater = updater || ReactNoopUpdateQueue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> asyncComponentPrototype = (ReactAsyncComponent.prototype = <span class="keyword">new</span> ComponentDummy());</span><br><span class="line">asyncComponentPrototype.constructor = ReactAsyncComponent;</span><br><span class="line"><span class="comment">// Avoid an extra prototype jump for these methods.</span></span><br><span class="line"><span class="built_in">Object</span>.assign(asyncComponentPrototype, ReactComponent.prototype);</span><br><span class="line">asyncComponentPrototype.unstable_isAsyncReactComponent = <span class="literal">true</span>;</span><br><span class="line">asyncComponentPrototype.render = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.props.children;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>和 PureComponent 一样，同样继承自 ReactComponent. 再次基础上添加了<br>unstable_isAsyncReactComponent 属性，并设置了 render 方法为直接返回它的 children. 从新添加的属性名可以看到，这是一个还没有稳定下来的特性组件。从名字和内容初步判断是用来创建异步的组件，先用一个 React 组件占位，当 props 传入 children 的时候，在进行渲染，从 render 方法直接 return 可以猜到这样可以实现无多余嵌套 html 标签的组件。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这个模块定义了 React 中会用到的三个基础组件类，需要注意的是：</p><pre><code>1. State 应该被看作是 immutable 的，所有的对 state 的修改只能通过 setState 来完成，不能使用 `this.state = **` 来进行 state 的更新2. setState 是一个异步的操作，所以在调用 setState 后从 this.state 上直接取值可能不是你期望的结果，读取的结果有可能依旧是老的 state</code></pre><p>而组件内部的 updater 逻辑，这个模块里面并没有定义具体的执行逻辑。比如调用 setState 后会对要更新的 state 进行入队操作，那么这个操作过程中发生了什么，究竟是如何进行批量的更新的，以及什么时候 state 才会更新完毕，那就需要从其他的模块里来寻找答案了。</p><h1 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h1><ul><li><a href="/2017/09/20/react-source-code-analyze-1/" title="React 源码浅析之 - 入口文件">React 源码浅析之 - 入口文件</a></li><li><a href="/2017/09/20/react-source-code-analyze-2/" title="React 源码浅析之 - ReactBaseClasses">React 源码浅析之 - ReactBaseClasses</a></li><li><a href="/2017/09/20/react-source-code-analyze-3/" title="React 源码浅析之 - ReactChildren">React 源码浅析之 - ReactChildren</a></li><li><a href="/2017/09/20/react-source-code-analyze-4/" title="React 源码浅析之 - ReactElement">React 源码浅析之 - ReactElement</a></li><li><a href="/2017/09/20/react-source-code-analyze-5/" title="React 源码浅析之 - onlyChildren">React 源码浅析之 - onlyChildren</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;引入的模块&quot;&gt;&lt;a href=&quot;#引入的模块&quot; class=&quot;headerlink&quot; title=&quot;引入的模块&quot;&gt;&lt;/a&gt;引入的模块&lt;/h1&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; ReactNoopUpdateQueue = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;ReactNoopUpdateQueue&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; emptyObject = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;fbjs/lib/emptyObject&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; invariant = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;fbjs/lib/invariant&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; lowPriorityWarning = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;lowPriorityWarning&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其中， &lt;code&gt;ReactNoopUpdateQueue&lt;/code&gt;  是默认的 updater ，用来提供 &lt;code&gt;update&lt;/code&gt;, &lt;code&gt;replaceState&lt;/code&gt;, &lt;code&gt;setState&lt;/code&gt; 的入队操作，但可能是由于是默认 &lt;code&gt;updater&lt;/code&gt; 的原因，只提供了 API 和对入参的校验，但没有提供实际的功能。比如：&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="https://blog.kisnows.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="React" scheme="https://blog.kisnows.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>React 源码浅析之 - 入口文件</title>
    <link href="https://blog.kisnows.com/2017/09/20/react-source-code-analyze-1/"/>
    <id>https://blog.kisnows.com/2017/09/20/react-source-code-analyze-1/</id>
    <published>2017-09-20T08:10:41.000Z</published>
    <updated>2017-10-14T07:27:47.605Z</updated>
    
    <content type="html"><![CDATA[<p>本系列文章以 react 最新的版本： 16.0.0-beta.5 为准。<br>首先我们入口文件 ReactEntry.js 来看，<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ReactBaseClasses = <span class="built_in">require</span>(<span class="string">'ReactBaseClasses'</span>);</span><br><span class="line"><span class="keyword">var</span> ReactChildren = <span class="built_in">require</span>(<span class="string">'ReactChildren'</span>);</span><br><span class="line"><span class="keyword">var</span> ReactElement = <span class="built_in">require</span>(<span class="string">'ReactElement'</span>);</span><br><span class="line"><span class="keyword">var</span> ReactVersion = <span class="built_in">require</span>(<span class="string">'ReactVersion'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> onlyChild = <span class="built_in">require</span>(<span class="string">'onlyChild'</span>);</span><br></pre></td></tr></table></figure></p><p>依赖模块：<br>    • ReactBaseClasses<br>    • ReactChildren<br>    • ReactElement<br>    • onlyChild<br>    • ReactElementValidator<br>接着:<br><a id="more"></a><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> createElement = ReactElement.createElement;</span><br><span class="line"><span class="keyword">var</span> createFactory = ReactElement.createFactory;</span><br><span class="line"><span class="keyword">var</span> cloneElement = ReactElement.cloneElement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">  <span class="keyword">var</span> ReactElementValidator = <span class="built_in">require</span>(<span class="string">'ReactElementValidator'</span>);</span><br><span class="line">  createElement = ReactElementValidator.createElement;</span><br><span class="line">  createFactory = ReactElementValidator.createFactory;</span><br><span class="line">  cloneElement = ReactElementValidator.cloneElement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到在开发环境下提供了对组件的验证。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> React = &#123;</span><br><span class="line">  Children: &#123;</span><br><span class="line">    map: ReactChildren.map,</span><br><span class="line">    forEach: ReactChildren.forEach,</span><br><span class="line">    count: ReactChildren.count,</span><br><span class="line">    toArray: ReactChildren.toArray,</span><br><span class="line">    only: onlyChild,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  Component: ReactBaseClasses.Component,</span><br><span class="line">  PureComponent: ReactBaseClasses.PureComponent,</span><br><span class="line">  unstable_AsyncComponent: ReactBaseClasses.AsyncComponent,</span><br><span class="line"></span><br><span class="line">  createElement: createElement,</span><br><span class="line">  cloneElement: cloneElement,</span><br><span class="line">  isValidElement: ReactElement.isValidElement,</span><br><span class="line"></span><br><span class="line">  createFactory: createFactory,</span><br><span class="line"></span><br><span class="line">  version: ReactVersion,</span><br><span class="line"></span><br><span class="line">  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: &#123;</span><br><span class="line">    ReactCurrentOwner: <span class="built_in">require</span>(<span class="string">'ReactCurrentOwner'</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>上面这些就是 React 提供的所有 API 了。<br>我会在后续的文章依次对这些 API 的实现进行解读。</p><h1 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h1><ul><li><a href="/2017/09/20/react-source-code-analyze-1/" title="React 源码浅析之 - 入口文件">React 源码浅析之 - 入口文件</a></li><li><a href="/2017/09/20/react-source-code-analyze-2/" title="React 源码浅析之 - ReactBaseClasses">React 源码浅析之 - ReactBaseClasses</a></li><li><a href="/2017/09/20/react-source-code-analyze-3/" title="React 源码浅析之 - ReactChildren">React 源码浅析之 - ReactChildren</a></li><li><a href="/2017/09/20/react-source-code-analyze-4/" title="React 源码浅析之 - ReactElement">React 源码浅析之 - ReactElement</a></li><li><a href="/2017/09/20/react-source-code-analyze-5/" title="React 源码浅析之 - onlyChildren">React 源码浅析之 - onlyChildren</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本系列文章以 react 最新的版本： 16.0.0-beta.5 为准。&lt;br&gt;首先我们入口文件 ReactEntry.js 来看，&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; ReactBaseClasses = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;ReactBaseClasses&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; ReactChildren = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;ReactChildren&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; ReactElement = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;ReactElement&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; ReactVersion = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;ReactVersion&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; onlyChild = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;onlyChild&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;依赖模块：&lt;br&gt;    • ReactBaseClasses&lt;br&gt;    • ReactChildren&lt;br&gt;    • ReactElement&lt;br&gt;    • onlyChild&lt;br&gt;    • ReactElementValidator&lt;br&gt;接着:&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="https://blog.kisnows.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="React" scheme="https://blog.kisnows.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>网易一年工作总结</title>
    <link href="https://blog.kisnows.com/2017/08/11/first-year-summary-for-netease-work-experience/"/>
    <id>https://blog.kisnows.com/2017/08/11/first-year-summary-for-netease-work-experience/</id>
    <published>2017-08-11T07:46:49.000Z</published>
    <updated>2017-10-14T07:27:47.596Z</updated>
    
    <content type="html"><![CDATA[<h1 id="做了哪些事情"><a href="#做了哪些事情" class="headerlink" title="做了哪些事情"></a>做了哪些事情</h1><p>说是一年，其实也一年多了，不过这倒不重要。主要看看做了哪些事吧：</p><h2 id="1-改造发布流程"><a href="#1-改造发布流程" class="headerlink" title="1. 改造发布流程"></a>1. 改造发布流程</h2><p>刚来公司的时候，白领贷的前端是基于 Riot 框架开发的系统。语言层面，使用 ES6 和 Less 开发，发布到线上是需要一个构建打包和编译的过程，不能直接部署到线上服务器。</p><p>所以项目的开发流程就是，功能开发，提交代码，本地打包，打包后的代码跟源代码一起提交测试，而后合并代码到 master 然后再在本地打包，然后上线。</p><p>这个流程非常的不合理，因为源代码和编译打包后的代码放到一块管理，本身就不合理。经常会出现，你一打包测试，我这边代码推上去就一堆冲突。所以我就想怎么来改进这个流程。</p><h3 id="改进方案一"><a href="#改进方案一" class="headerlink" title="改进方案一"></a>改进方案一</h3><p>网易内部是有一个 omad 系统（自动部署平台）的，想着说看能不能借助这个平台干点事情。因为初来乍到，对这个部署平台不是很熟悉，就问了和这个平台接触最多的测试同学，测试同学告诉我说 omad 没有提供任何对外的接口，所以我想的可能没法实现。</p><p>这样就尴尬了，没法做线上打包发布，那么打包这个过程就必然得放在本地来做。所以我就搞了一套现在看来很蠢的方案。那就是，用两个仓库来分别管理源代码和打包后的代码。</p><p>那么，如果需要发布的话，就需要在源代码仓库先进行打包编译，然后把打包编译的结果复制到管理要发布的代码的仓库。</p><p>一张示意图：</p><img src="/2017/08/11/first-year-summary-for-netease-work-experience/release1.png" title="改进方案一"><p>很明显，上面这种方式也只是临时解决方案，需要两个仓库来管理一份代码。每次提交代码都需要额外执行一个 run build 命令。</p><h3 id="改进方案二："><a href="#改进方案二：" class="headerlink" title="改进方案二："></a>改进方案二：</h3><p>由于上面的方案太蠢了，所以有了改进方案二，也是我们现在一直在用的方案：那就是直接线上打包。具体如下：<br><a id="more"></a><br>本地代码开发 -&gt; 提交 -&gt; 推送到远端 -&gt; omad 部署 -&gt; omad 专用打包机执行一段脚本来进行打包编译操作 -&gt; 把打包编译后的结果拷贝到目标机器。</p><p>一张示意图：</p><img src="/2017/08/11/first-year-summary-for-netease-work-experience/release2.png" title="改进方案二"><p>其实，本来第一次改造就应该改成这样的。但是因为一开始对内部的部署平台 omad 并不熟悉，所以不知道 omad 部署到目标机器前还可以执行一段脚本的。以至于有了第一种非常蠢的解决方案。</p><p>现在这套方案就比较完善了， 我们只关注源代码就可以了，发布的时候又 omad 去做构建和打包部署的事情。非常舒心，这套方案也一直用到了现在。</p><h2 id="2-搭建了一套完善的开发环境"><a href="#2-搭建了一套完善的开发环境" class="headerlink" title="2. 搭建了一套完善的开发环境"></a>2. 搭建了一套完善的开发环境</h2><p>原有的白领贷开发环境是基于 express 和 webpack 配合搭建起来的，但是功能比较简陋，只支持开发和打包两个命令，而且打包的配置文件是完全服务于多页面的工程。</p><p>后来我们开发来钱系统的时候，我就在原有的基础上重新搭建了一套完善的开发环境。从开发、联调、测试、打包到上线，该有的功能都有了。放一张图，具体可以 <a href="https://github.com/kisnows/spart" target="_blank" rel="noopener">看这里</a></p><img src="/2017/08/11/first-year-summary-for-netease-work-experience/environment.png" title="开发环境"><h2 id="3-主导并推动了移动端组件-ne-rc-的开发"><a href="#3-主导并推动了移动端组件-ne-rc-的开发" class="headerlink" title="3. 主导并推动了移动端组件 ne-rc 的开发"></a>3. 主导并推动了移动端组件 ne-rc 的开发</h2><p>再开发来钱的时候，积累了一套 react 的基础组件，但是跟业务耦合度比较高。考虑到以后可能还要做其他项目，就和一伙伴一起商量着把基础组件从业务中抽离出来，作为一个第三方组件库在接入到项目中。</p><p>于是就有了: <strong><a href="https://github.com/NE-LOAN-FED/NE-Component" target="_blank" rel="noopener">ne-rc</a></strong>,我们的移动端组件库，索然还在为 1.0 版本的发布继续努力，但已经成功接入了三个内部的项目。</p><p>效果显著，大大降低了重复开发成本，同时也降低了未来维护的成本。由此可见，一个稳定发展的团队，还是需要一套自己的内部组件库的。</p><h2 id="4-团队工作改进"><a href="#4-团队工作改进" class="headerlink" title="4. 团队工作改进"></a>4. 团队工作改进</h2><p>由于原有业务线前端负责人在我入职后不久就离职了， 前端技术部派我临时挑大梁。我深知自己经验不足，但也知道这是一个锻炼的机会，这里非常感谢我的老大信任我。</p><p>所以我非常努力，和业务线团队的小伙伴就如何提高我们的团队技术实力和业务支持能力讨论了很多，最后做了一下事情:</p><ul><li>开发框架优化</li><li>遗留项目改造</li><li>项目规范</li><li>技术规划</li></ul><h3 id="开发框架优化"><a href="#开发框架优化" class="headerlink" title="开发框架优化"></a>开发框架优化</h3><p>最终的成果就是上面说的搭建了一套完整的开发环境。并不断进行优化。从一开始白领贷项目开发时每次 rebuild 需要 30s , 打包上线需要 4~5 min 到后来去花项目 rebuild 600ms, 打包只需要 1min .这中间既有针对 webpack 的优化，也有项目开放交付方式的改变。</p><p>在这些优化的过程中，积累了很多经验。</p><h3 id="遗留项目改造"><a href="#遗留项目改造" class="headerlink" title="遗留项目改造"></a>遗留项目改造</h3><p>有几个遗留项目，虽然整体处于维护状态，但偶尔还是有很多运营需求。而原有的开发方式和发布方式都比较麻烦，我们也尽可能在不需要多的重构的基础上，进行了逐步升级。主要是构建和发布上。<br>改写原有的 webpack 配置文件方式，并从本地打包发布升级到了线上打包发布。减轻了这些项目的维护成本。</p><h3 id="项目规范"><a href="#项目规范" class="headerlink" title="项目规范"></a>项目规范</h3><p>业务线上人员来越多，在需要合作的情况下，规范是必不可少。我们从项目文档、代码风格检查、Git 分支管理、代码 review 等各个方面制订了完善又尽可能不繁琐的规范。</p><h3 id="技术规划"><a href="#技术规划" class="headerlink" title="技术规划"></a>技术规划</h3><p>我们组的项目大多应用 react ，所以需要持续关注 react 生态群的技术动向。但同时也关注其他技术和解决方案，包括 Nodejs , Angular 等。前端技术部也让我们多看看 Vue . 然而到现在我都没看过 Vue ，哈哈，可能是提不起兴趣吧。</p><h2 id="5-业务支持"><a href="#5-业务支持" class="headerlink" title="5. 业务支持"></a>5. 业务支持</h2><p>虽然我们前端技术部属于职能部门，但支持业务仍然是我们工作的最主要构成部分，毕竟公司要赚钱。除了一些小的以及一些后台项目，我主要参与维护和开发一下项目：</p><p>a. 白领贷项目维护<br>b. 来钱项目开发并上线<br>c. 去花项目开发并上线</p><p>去花最近就要上线了，我们已经开始内测了。这是一个提供分期的项目，目前只接入了考拉，马上也要对外了，不久大家就在考拉上购物时就可以有分期的支付选项了。</p><p>看到项目上线，还是很高兴的😄。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>时间还是蛮快的， 都来网易一年多了。</p><p>这段时间成长了许多，无论时工作技能、沟通技能还是工作流程和规范，都让我学会了很多东西。</p><p>也认识了很多优秀的同事，能跟这些优秀的同事一起做事情，也是一件很开心的事情。也许以后不会一直在网易，但在网易的这段经历还是很值得的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;做了哪些事情&quot;&gt;&lt;a href=&quot;#做了哪些事情&quot; class=&quot;headerlink&quot; title=&quot;做了哪些事情&quot;&gt;&lt;/a&gt;做了哪些事情&lt;/h1&gt;&lt;p&gt;说是一年，其实也一年多了，不过这倒不重要。主要看看做了哪些事吧：&lt;/p&gt;
&lt;h2 id=&quot;1-改造发布流程&quot;&gt;&lt;a href=&quot;#1-改造发布流程&quot; class=&quot;headerlink&quot; title=&quot;1. 改造发布流程&quot;&gt;&lt;/a&gt;1. 改造发布流程&lt;/h2&gt;&lt;p&gt;刚来公司的时候，白领贷的前端是基于 Riot 框架开发的系统。语言层面，使用 ES6 和 Less 开发，发布到线上是需要一个构建打包和编译的过程，不能直接部署到线上服务器。&lt;/p&gt;
&lt;p&gt;所以项目的开发流程就是，功能开发，提交代码，本地打包，打包后的代码跟源代码一起提交测试，而后合并代码到 master 然后再在本地打包，然后上线。&lt;/p&gt;
&lt;p&gt;这个流程非常的不合理，因为源代码和编译打包后的代码放到一块管理，本身就不合理。经常会出现，你一打包测试，我这边代码推上去就一堆冲突。所以我就想怎么来改进这个流程。&lt;/p&gt;
&lt;h3 id=&quot;改进方案一&quot;&gt;&lt;a href=&quot;#改进方案一&quot; class=&quot;headerlink&quot; title=&quot;改进方案一&quot;&gt;&lt;/a&gt;改进方案一&lt;/h3&gt;&lt;p&gt;网易内部是有一个 omad 系统（自动部署平台）的，想着说看能不能借助这个平台干点事情。因为初来乍到，对这个部署平台不是很熟悉，就问了和这个平台接触最多的测试同学，测试同学告诉我说 omad 没有提供任何对外的接口，所以我想的可能没法实现。&lt;/p&gt;
&lt;p&gt;这样就尴尬了，没法做线上打包发布，那么打包这个过程就必然得放在本地来做。所以我就搞了一套现在看来很蠢的方案。那就是，用两个仓库来分别管理源代码和打包后的代码。&lt;/p&gt;
&lt;p&gt;那么，如果需要发布的话，就需要在源代码仓库先进行打包编译，然后把打包编译的结果复制到管理要发布的代码的仓库。&lt;/p&gt;
&lt;p&gt;一张示意图：&lt;/p&gt;
&lt;img src=&quot;/2017/08/11/first-year-summary-for-netease-work-experience/release1.png&quot; title=&quot;改进方案一&quot;&gt;
&lt;p&gt;很明显，上面这种方式也只是临时解决方案，需要两个仓库来管理一份代码。每次提交代码都需要额外执行一个 run build 命令。&lt;/p&gt;
&lt;h3 id=&quot;改进方案二：&quot;&gt;&lt;a href=&quot;#改进方案二：&quot; class=&quot;headerlink&quot; title=&quot;改进方案二：&quot;&gt;&lt;/a&gt;改进方案二：&lt;/h3&gt;&lt;p&gt;由于上面的方案太蠢了，所以有了改进方案二，也是我们现在一直在用的方案：那就是直接线上打包。具体如下：&lt;br&gt;
    
    </summary>
    
      <category term="随笔" scheme="https://blog.kisnows.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>React-Redux 源码粗读</title>
    <link href="https://blog.kisnows.com/2017/08/03/react-redux-source-code-read/"/>
    <id>https://blog.kisnows.com/2017/08/03/react-redux-source-code-read/</id>
    <published>2017-08-03T11:54:30.000Z</published>
    <updated>2017-10-14T07:27:47.601Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><p>首先看一张图：</p><p><img src="/imgs/react-redux-source-code-read/react-redux.png" alt="React-Redux"></p><p>可以看到入口文件里面引入了这几个模块：</p><ul><li>Provider</li><li>connectAdvanced</li><li>connect</li></ul><p>我们就来依次看一下这几个模块</p><h2 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a>Provider</h2><p>将 <code>store</code> 挂在在了 context 上面，给予了子组件访问 <code>store</code> 的能力。<br><a id="more"></a></p><h2 id="connectAdvanced"><a href="#connectAdvanced" class="headerlink" title="connectAdvanced"></a>connectAdvanced</h2><p>一个用来生成 <code>connect</code> 的高阶函数,引用了以下模块:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hoistStatics <span class="keyword">from</span> <span class="string">'hoist-non-react-statics'</span></span><br><span class="line"><span class="keyword">import</span> invariant <span class="keyword">from</span> <span class="string">'invariant'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Component, createElement &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Subscription <span class="keyword">from</span> <span class="string">'../utils/Subscription'</span></span><br><span class="line"><span class="keyword">import</span> &#123; storeShape, subscriptionShape &#125; <span class="keyword">from</span> <span class="string">'../utils/PropTypes'</span></span><br></pre></td></tr></table></figure></p><h3 id="Subscription"><a href="#Subscription" class="headerlink" title="Subscription"></a>Subscription</h3><p>首先看一下 <code>Subscription</code> 模块。</p><h4 id="createListenerCollection"><a href="#createListenerCollection" class="headerlink" title="createListenerCollection"></a>createListenerCollection</h4><p>实现一个订阅发布模式，提供 <code>clear</code>，<code>notify</code>，<code>subscribe</code> 方法。分别用来清除当前队列，触发事件，订阅方法。</p><h4 id="Subscription-1"><a href="#Subscription-1" class="headerlink" title="Subscription"></a>Subscription</h4><p>订阅类，订阅 <code>onStateChange</code> 事件，同时确保当父级也有事件订阅时，事件触发时，先触发父级事件，然后再触发当前组件事件。</p><h3 id="makeSelectorStateful-sourceSelector-store-selector"><a href="#makeSelectorStateful-sourceSelector-store-selector" class="headerlink" title="makeSelectorStateful(sourceSelector,store):selector"></a>makeSelectorStateful(sourceSelector,store):selector</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeSelectorStateful</span>(<span class="params">sourceSelector, store</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// wrap the selector in an object that tracks its results between runs.</span></span><br><span class="line">  <span class="keyword">const</span> selector = &#123;</span><br><span class="line">    run: <span class="function"><span class="keyword">function</span> <span class="title">runComponentSelector</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> nextProps = sourceSelector(store.getState(), props)</span><br><span class="line">        <span class="keyword">if</span> (nextProps !== selector.props || selector.error) &#123;</span><br><span class="line">          selector.shouldComponentUpdate = <span class="literal">true</span></span><br><span class="line">          selector.props = nextProps</span><br><span class="line">          selector.error = <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        selector.shouldComponentUpdate = <span class="literal">true</span></span><br><span class="line">        selector.error = error</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> selector</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>selector</code> 用来通过 <code>state</code> 和 <code>prop</code> 来计算出下一个状态的 <code>props</code>，然后传递给连接的组件。<br>此函数是对 <code>selector</code> 的封装，在计算 <code>props</code> 的基础上，并记录上一次计算的结果。</p><h3 id="connectAdvanced-selectorFactory-options-wrapWithConnect-WrappedComponent"><a href="#connectAdvanced-selectorFactory-options-wrapWithConnect-WrappedComponent" class="headerlink" title="connectAdvanced(selectorFactory,{options}):wrapWithConnect(WrappedComponent)"></a>connectAdvanced(selectorFactory,{options}):wrapWithConnect(WrappedComponent)</h3><p><code>connectAdvanced</code> 的功能主要是根据传入的 <code>selectorFactory</code>, <code>options</code> 返回用于生成 <code>Connect</code> 组件一个高阶组件。</p><h3 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Connect</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props, context) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props, context)</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">this</span>.initSelector()</span><br><span class="line">    <span class="keyword">this</span>.initSubscription()</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  initSelector() &#123;</span><br><span class="line">    <span class="keyword">const</span> sourceSelector = selectorFactory(<span class="keyword">this</span>.store.dispatch, selectorFactoryOptions)</span><br><span class="line">    <span class="keyword">this</span>.selector = makeSelectorStateful(sourceSelector, <span class="keyword">this</span>.store)</span><br><span class="line">    <span class="keyword">this</span>.selector.run(<span class="keyword">this</span>.props)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  initSubscription() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!shouldHandleStateChanges) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// parentSub's source should match where store came from: props vs. context. A component</span></span><br><span class="line">    <span class="comment">// connected to the store via props shouldn't use subscription from context, or vice versa.</span></span><br><span class="line">    <span class="keyword">const</span> parentSub = (<span class="keyword">this</span>.propsMode ? <span class="keyword">this</span>.props : <span class="keyword">this</span>.context)[subscriptionKey]</span><br><span class="line">    <span class="keyword">this</span>.subscription = <span class="keyword">new</span> Subscription(<span class="keyword">this</span>.store, parentSub, <span class="keyword">this</span>.onStateChange.bind(<span class="keyword">this</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// `notifyNestedSubs` is duplicated to handle the case where the component is  unmounted in</span></span><br><span class="line">    <span class="comment">// the middle of the notification loop, where `this.subscription` will then be null. An</span></span><br><span class="line">    <span class="comment">// extra null check every change can be avoided by copying the method onto `this` and then</span></span><br><span class="line">    <span class="comment">// replacing it with a no-op on unmount. This can probably be avoided if Subscription's</span></span><br><span class="line">    <span class="comment">// listeners logic is changed to not call listeners that have been unsubscribed in the</span></span><br><span class="line">    <span class="comment">// middle of the notification loop.</span></span><br><span class="line">    <span class="keyword">this</span>.notifyNestedSubs = <span class="keyword">this</span>.subscription.notifyNestedSubs.bind(<span class="keyword">this</span>.subscription)</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> selector = <span class="keyword">this</span>.selector</span><br><span class="line">    selector.shouldComponentUpdate = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (selector.error) &#123;</span><br><span class="line">      <span class="keyword">throw</span> selector.error</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> createElement(WrappedComponent, <span class="keyword">this</span>.addExtraProps(selector.props))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义在 <code>connectAdvanced</code> 内部的组件，通过 <code>context</code> 获取 <code>store</code> 中数据，通过 <code>initSelector</code> 方法初始化一个包含初始 <code>store</code> 的 <code>selector</code>, 并通过 <code>initSubscription</code> 方法订阅 <code>store</code> 的变化。<br>此组件的 <code>render</code> 方法只是一个代理，用来把通过 <code>selector</code> 计算出来的 <code>props</code> 传递给需要包裹的组件。</p><h2 id="connect-1"><a href="#connect-1" class="headerlink" title="connect"></a>connect</h2><p><code>connect</code> 引入了以下模块：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> connectAdvanced <span class="keyword">from</span> <span class="string">'../components/connectAdvanced'</span></span><br><span class="line"><span class="keyword">import</span> shallowEqual <span class="keyword">from</span> <span class="string">'../utils/shallowEqual'</span></span><br><span class="line"><span class="keyword">import</span> defaultMapDispatchToPropsFactories <span class="keyword">from</span> <span class="string">'./mapDispatchToProps'</span></span><br><span class="line"><span class="keyword">import</span> defaultMapStateToPropsFactories <span class="keyword">from</span> <span class="string">'./mapStateToProps'</span></span><br><span class="line"><span class="keyword">import</span> defaultMergePropsFactories <span class="keyword">from</span> <span class="string">'./mergeProps'</span></span><br><span class="line"><span class="keyword">import</span> defaultSelectorFactory <span class="keyword">from</span> <span class="string">'./selectorFactory'</span></span><br></pre></td></tr></table></figure></p><p>只是在 <code>connectAdvanced</code> 的基础上，传入了 <code>selectorFactory</code> 和 <code>mapStateToPropsFactories</code>, <code>mapDispatchToProps</code>, <code>mapDispatchToPropsFactories</code> 作为 <code>connectAdvanced</code> 的 <code>options</code> 参数。</p><h3 id="defaultSelectorFactory"><a href="#defaultSelectorFactory" class="headerlink" title="defaultSelectorFactory"></a>defaultSelectorFactory</h3><p>定义了默认 <code>selector</code> 的行为，用来从传入的 <code>state</code> 中计算下一个状态的 <code>props</code>.</p><h3 id="defaultMap-xxx-To-xxx-Factories"><a href="#defaultMap-xxx-To-xxx-Factories" class="headerlink" title="defaultMap xxx To xxx Factories"></a>defaultMap xxx To xxx Factories</h3><p>这类模块用来生成映射到 props 方法的工厂函数，它们的代码如下形式：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; bindActionCreators &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"><span class="keyword">import</span> &#123; wrapMapToPropsConstant, wrapMapToPropsFunc &#125; <span class="keyword">from</span> <span class="string">'./wrapMapToProps'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">whenMapDispatchToPropsIsFunction</span>(<span class="params">mapDispatchToProps</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">typeof</span> mapDispatchToProps === <span class="string">'function'</span>)</span><br><span class="line">    ? wrapMapToPropsFunc(mapDispatchToProps, <span class="string">'mapDispatchToProps'</span>)</span><br><span class="line">    : <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">whenMapDispatchToPropsIsMissing</span>(<span class="params">mapDispatchToProps</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (!mapDispatchToProps)</span><br><span class="line">    ? wrapMapToPropsConstant(<span class="function"><span class="params">dispatch</span> =&gt;</span> (&#123; dispatch &#125;))</span><br><span class="line">    : <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">whenMapDispatchToPropsIsObject</span>(<span class="params">mapDispatchToProps</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (mapDispatchToProps &amp;&amp; <span class="keyword">typeof</span> mapDispatchToProps === <span class="string">'object'</span>)</span><br><span class="line">    ? wrapMapToPropsConstant(<span class="function"><span class="params">dispatch</span> =&gt;</span> bindActionCreators(mapDispatchToProps, dispatch))</span><br><span class="line">    : <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，主要引用了 <code>wrapMapToProps</code> 这个模块。</p><h4 id="wrapMapToProps"><a href="#wrapMapToProps" class="headerlink" title="wrapMapToProps"></a>wrapMapToProps</h4><h5 id="wrapMapToPropsFunc"><a href="#wrapMapToPropsFunc" class="headerlink" title="wrapMapToPropsFunc"></a>wrapMapToPropsFunc</h5><p>这个方法是一个通过把 <code>mapToProps</code> 函数包裹起来作为一个代理函数,用来做一下几件事情：</p><ul><li>检测 <code>mapToProps</code> 函数的调用是否依赖与 <code>props</code>, 用来供 <code>selectorFactory</code> 来决定在 <code>props</code> 变化的时候是否需要重新调用。</li><li>在第一次调用的时候，如果 <code>mapToProp</code> 执行后返回另一个函数，那么处理它，并且把这个返回的函数作为新的 <code>mapToProps</code> 用来处理后续的调用。</li><li>当第一次调用的时候，验证调用的结果是否是一个字面量对象。为了能够警告开发者，他们的 <code>mapToProps</code> 函数没有返回一个合法的结果。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>react-redux 就是一个用来绑定 redux 到 react 的一个库。如果不用 react-redux 的话，直接在 react 里面去用 redux 也是可以的，只是过于麻烦。需要手动监听 <code>store</code> 的变化，并手动执行组件的 <code>render</code> 方法。<br>react-redux 提供了一个高阶组件 <code>connect</code> 来帮我们做这件事情，而且帮我们做了一些优化。我们需要的只是，提供 <code>mapDispatchToProps</code> 和 <code>mapStateToProps</code> 给需要监听 <code>store</code> 的组件就可以了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Overview&quot;&gt;&lt;a href=&quot;#Overview&quot; class=&quot;headerlink&quot; title=&quot;Overview&quot;&gt;&lt;/a&gt;Overview&lt;/h1&gt;&lt;p&gt;首先看一张图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/imgs/react-redux-source-code-read/react-redux.png&quot; alt=&quot;React-Redux&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以看到入口文件里面引入了这几个模块：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Provider&lt;/li&gt;
&lt;li&gt;connectAdvanced&lt;/li&gt;
&lt;li&gt;connect&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们就来依次看一下这几个模块&lt;/p&gt;
&lt;h2 id=&quot;Provider&quot;&gt;&lt;a href=&quot;#Provider&quot; class=&quot;headerlink&quot; title=&quot;Provider&quot;&gt;&lt;/a&gt;Provider&lt;/h2&gt;&lt;p&gt;将 &lt;code&gt;store&lt;/code&gt; 挂在在了 context 上面，给予了子组件访问 &lt;code&gt;store&lt;/code&gt; 的能力。&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="https://blog.kisnows.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="React" scheme="https://blog.kisnows.com/tags/react/"/>
    
      <category term="Redux" scheme="https://blog.kisnows.com/tags/redux/"/>
    
  </entry>
  
  <entry>
    <title>基于 React 的前端项目开发总结</title>
    <link href="https://blog.kisnows.com/2017/05/12/react-base-project-summary/"/>
    <id>https://blog.kisnows.com/2017/05/12/react-base-project-summary/</id>
    <published>2017-05-12T07:00:52.000Z</published>
    <updated>2017-07-20T14:39:59.324Z</updated>
    
    <content type="html"><![CDATA[<h1 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h1><p>我们的项目主要选用以下技术开发，再配合一些其它辅助工具。</p><ul><li>react</li><li>react-router</li><li>redux</li><li>react-redux</li></ul><h1 id="开发及线上环境"><a href="#开发及线上环境" class="headerlink" title="开发及线上环境"></a>开发及线上环境</h1><h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><p>由于项目是前后端分离的，所以我们需要一套完整的开发环境，需要包括以下功能：</p><ul><li>数据 Mock</li><li>Webpack 实施编译刷新</li><li>方便前后端联调</li></ul><p>基于这些需求，我们基于 Express, Webpack,Webpack-dev-middleware 搭建了这套完整的开发环境。</p><p><img src="/imgs/react-base-project-summary/dev-env.png" alt="开发环境"></p><p>可以看到，浏览器所有的请求都被本地的 Node.js 服务拦截。对于静态资源请求，都委托给 <code>webpack-dev-middleware</code> 来处理，对于接口请求根据不同的环境来决定要做的操作。</p><h3 id="本地开发"><a href="#本地开发" class="headerlink" title="本地开发"></a>本地开发</h3><p>当 <code>ENV = &#39;development&#39;</code> 时，也就是开发环境，那么就直接读取本地的 mock 数据来渲染页面。</p><h3 id="前后端联调"><a href="#前后端联调" class="headerlink" title="前后端联调"></a>前后端联调</h3><p>当 <code>ENV = &#39;api&#39;</code> 时，也就是我们认为的联调环境，这个时候对于接口请求由 node.js 转发到需要联调的真实后端服务地址上，从而避免直接调用所产生的跨域问题。</p><p>这样就可以直接用本地开发代码和后端联调，能大大提高效率，省去了每次需要往服务器上构建部署的步骤。</p><h2 id="线上环境"><a href="#线上环境" class="headerlink" title="线上环境"></a>线上环境</h2><a id="more"></a><p>前后端是分开部署的，所有的静态资源都放在 CDN (example.cdn.com)上面。</p><p>也就是说我们的页面在 example.cdn/index.html 这里，但是请求的接口在 example.163.com/api/xxx,我们肯定不能让用户去直接去访问 example.cdn.com/index.html,这样不合理，而且由跨域问题存在</p><p>那么访问 example.dai.163.com 的时候，怎么拿到我们的 html 页面呢？<br>看下图：</p><p><img src="/imgs/react-base-project-summary/online.png" alt="线上环境"></p><p>在客户端和后台服务之间架设一台 nginx, 我们访问的 example.dai.163.com 有两种请求：</p><ul><li>html 页面资源</li><li>接口请求</li></ul><p>这两种请求都先经过 nginx，在这里做判断，如果是页面请求那么由 nginx 转发到 CDN， 否则交给后端服务来响应接口请求。</p><p>拿到页面以后，其它所有的 css, js 等静态资源都是直接请求到 CDN ，这里没什么说的。</p><h1 id="数据流转"><a href="#数据流转" class="headerlink" title="数据流转"></a>数据流转</h1><p>借助 redux 来管理数据流，我们来看这张图。</p><p><img src="/imgs/react-base-project-summary/data-flow.png" alt="数据流转"></p><p>首先，通过 <code>middleware</code> 和 <code>reducer</code> 生成 <code>store</code>, 然后获得项目的初始 <code>state</code>,通过初始 <code>state</code> 去渲染页面的初始状态。</p><p>以 <code>Home</code> 页面为例，首先 <code>Home</code> 通过 <code>react-redux</code> 提供的 <code>connect</code> 方法拿到初始 <code>state</code> 作为 <code>Home</code> 的 <code>prop</code> 传递给 <code>Home</code>. 而 <code>Home</code> 由多个不同的子组件组成，这些组件的需要数据再由 Home 通过 props 传递给自己的子组件。</p><p>当 <code>Home</code> 的初始状态加载完毕后，我们需要向后端请求去拿去一些用户数据。这时，我们分发一个下面这种格式的 <code>action</code>:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  types: [<span class="string">'home/start'</span>,<span class="string">'home/success'</span>,<span class="string">'home/failure'</span>],</span><br><span class="line">  payload: &#123;</span><br><span class="line">    api:</span><br><span class="line">    ...</span><br><span class="line">  &#125;,</span><br><span class="line">  meta: &#123;</span><br><span class="line">    isApi: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>所有的 <code>action</code> 都会按照我们制定的循序通过一个个 <code>middleware</code>. </p><p>在这里，我们的 <code>action</code> 会被 <code>callApiMiddleware</code> 通过 <code>meta</code> 里面的 <code>isApi</code> 标识命中，并去做相应的事情。</p><p>比如在这个中间件里面，我们去做了真实的接口请求，在请求成功或失败的时候分发对应的 <code>action</code>，以及做一些统一的业务逻辑。比如我们对后端返回的接口中 <code>code</code> 值有统一的约定，假设 1 为成功， 2 为失败， 3 为未登录。那么我们就可以在中间件中去处理这些业务逻辑。 </p><p>当请求成功，并渲染页面后，假设用户点击了一个按钮，这个按钮需要唤起 <code>native</code> 的一些功能，比如说拍照。那么我们分发一个唤起拍照功能的 <code>camera/start</code> 的<code>action</code>:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  types: [<span class="string">'sdk/start'</span>,<span class="string">'sdk/success'</span>,<span class="string">'sdk/failure'</span>],</span><br><span class="line">  payload: &#123;</span><br><span class="line">    command:</span><br><span class="line">    ...</span><br><span class="line">  &#125;,</span><br><span class="line">  meta: &#123;</span><br><span class="line">    isSDK: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>同样的道理，这个 <code>action</code> 会被 <code>EpaySDKMiddleware</code> 所识别并处理，在调起 native 的时候， 为了保证安全性，我们需要向后发起一个请求去拿签名，这个时候就可以在 <code>EpaySDKMiddleware</code> 里面分发一个接口请求的 <code>action</code>，那么这个 <code>action</code> 同样需要走一遍所有的 <code>middleware</code>. 那么这个接口请求的 <code>action</code> 就会像上面的流程一样，通过 <code>callApiMiddleware</code> 去处理。</p><p>中间件的存在，使整个流程变得非常清晰，接口的请求的中间件就只做接口请求，调用 native 接口的中间件就只做对 native 的调用，当对 native 接口的调用需要做后端接口请求的时候，去分发一个 <code>action</code> 走接口请求的中间件。</p><p>每个中间件只专注于自己的事情，既方便后续的维护，同时也提供了一个很好的拓展方式。而 <code>View</code> 层需要做的就只是做出分发 action，然后拿数据渲染页面就可以了，其他的逻辑都不用关心。</p><h1 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h1><p><img src="/imgs/react-base-project-summary/overall-process.png" alt="整体流程"></p><p>假设我们由如下的一个路由配置。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    component: App,</span><br><span class="line">    path: <span class="string">'/'</span>,</span><br><span class="line">    onEnter: initLogin(store),</span><br><span class="line">    indexRoute: &#123;</span><br><span class="line">      getComponent(nextState, cb) &#123;</span><br><span class="line">        <span class="built_in">require</span>.ensure([], <span class="built_in">require</span> =&gt; &#123;</span><br><span class="line">          cb(<span class="literal">null</span>, <span class="built_in">require</span>(<span class="string">'../views/Home'</span>).default)</span><br><span class="line">        &#125;, <span class="string">'Home'</span>)</span><br><span class="line">      &#125;,</span><br><span class="line">      onEnter: initHome(store)</span><br><span class="line">    &#125;,</span><br><span class="line">    childRoutes: [</span><br><span class="line">      createActivateRoute(store),</span><br><span class="line">      &#123;</span><br><span class="line">        path: <span class="string">'test'</span>,</span><br><span class="line">        indexRoute: &#123;</span><br><span class="line">          getComponent(nextState, cb) &#123;</span><br><span class="line">            <span class="built_in">require</span>.ensure([], <span class="built_in">require</span> =&gt; &#123;</span><br><span class="line">              cb(<span class="literal">null</span>, <span class="built_in">require</span>(<span class="string">'../views/Test'</span>).default)</span><br><span class="line">            &#125;, <span class="string">'Test'</span>)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      ...</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>那结合 <code>react-route</code> 我们来看一个完整的流程。当我们浏览器里面输入 example.dai.163.com/index.html/#/ 的时候。</p><p>首先，通过最上面 线上环境 一节提到的内容，拿到页面需要 html,css,js.</p><p>然后渲染 <code>Provide</code> 和 <code>Router</code> 组件，分别提供 <code>store</code> 的注入和路由的控制。</p><p>此时触发根路径的路由匹配，然后加载根组件 <code>APP</code>, 然后根据路由匹配规则匹配到 <code>IndexRouter</code>, 加载 <code>Home</code> 组件。</p><p>后面的事情就和前面数据流转一节讲的是一样的了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在前后端完全分离的基础上，借助一套完善的开发环境，可以大大提高的我们的开发效率，降低前后端联调的成本。</p><p>同时借助于 Redux 思想，实现单向数据流，让我们可以实现一个非常清晰的数据流向。并且，借助于中间件，我们可以更加有效的控制数据流转的过程。为后面项目的扩展提供无限的想象空间。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;技术选型&quot;&gt;&lt;a href=&quot;#技术选型&quot; class=&quot;headerlink&quot; title=&quot;技术选型&quot;&gt;&lt;/a&gt;技术选型&lt;/h1&gt;&lt;p&gt;我们的项目主要选用以下技术开发，再配合一些其它辅助工具。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;react&lt;/li&gt;
&lt;li&gt;react-router&lt;/li&gt;
&lt;li&gt;redux&lt;/li&gt;
&lt;li&gt;react-redux&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;开发及线上环境&quot;&gt;&lt;a href=&quot;#开发及线上环境&quot; class=&quot;headerlink&quot; title=&quot;开发及线上环境&quot;&gt;&lt;/a&gt;开发及线上环境&lt;/h1&gt;&lt;h2 id=&quot;开发环境&quot;&gt;&lt;a href=&quot;#开发环境&quot; class=&quot;headerlink&quot; title=&quot;开发环境&quot;&gt;&lt;/a&gt;开发环境&lt;/h2&gt;&lt;p&gt;由于项目是前后端分离的，所以我们需要一套完整的开发环境，需要包括以下功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据 Mock&lt;/li&gt;
&lt;li&gt;Webpack 实施编译刷新&lt;/li&gt;
&lt;li&gt;方便前后端联调&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基于这些需求，我们基于 Express, Webpack,Webpack-dev-middleware 搭建了这套完整的开发环境。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/imgs/react-base-project-summary/dev-env.png&quot; alt=&quot;开发环境&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以看到，浏览器所有的请求都被本地的 Node.js 服务拦截。对于静态资源请求，都委托给 &lt;code&gt;webpack-dev-middleware&lt;/code&gt; 来处理，对于接口请求根据不同的环境来决定要做的操作。&lt;/p&gt;
&lt;h3 id=&quot;本地开发&quot;&gt;&lt;a href=&quot;#本地开发&quot; class=&quot;headerlink&quot; title=&quot;本地开发&quot;&gt;&lt;/a&gt;本地开发&lt;/h3&gt;&lt;p&gt;当 &lt;code&gt;ENV = &amp;#39;development&amp;#39;&lt;/code&gt; 时，也就是开发环境，那么就直接读取本地的 mock 数据来渲染页面。&lt;/p&gt;
&lt;h3 id=&quot;前后端联调&quot;&gt;&lt;a href=&quot;#前后端联调&quot; class=&quot;headerlink&quot; title=&quot;前后端联调&quot;&gt;&lt;/a&gt;前后端联调&lt;/h3&gt;&lt;p&gt;当 &lt;code&gt;ENV = &amp;#39;api&amp;#39;&lt;/code&gt; 时，也就是我们认为的联调环境，这个时候对于接口请求由 node.js 转发到需要联调的真实后端服务地址上，从而避免直接调用所产生的跨域问题。&lt;/p&gt;
&lt;p&gt;这样就可以直接用本地开发代码和后端联调，能大大提高效率，省去了每次需要往服务器上构建部署的步骤。&lt;/p&gt;
&lt;h2 id=&quot;线上环境&quot;&gt;&lt;a href=&quot;#线上环境&quot; class=&quot;headerlink&quot; title=&quot;线上环境&quot;&gt;&lt;/a&gt;线上环境&lt;/h2&gt;
    
    </summary>
    
      <category term="技术" scheme="https://blog.kisnows.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="React" scheme="https://blog.kisnows.com/tags/react/"/>
    
      <category term="Redux" scheme="https://blog.kisnows.com/tags/redux/"/>
    
      <category term="react-router" scheme="https://blog.kisnows.com/tags/react-router/"/>
    
  </entry>
  
  <entry>
    <title>React 单页面初始化渲染优化</title>
    <link href="https://blog.kisnows.com/2017/04/20/react-page-render-improve/"/>
    <id>https://blog.kisnows.com/2017/04/20/react-page-render-improve/</id>
    <published>2017-04-20T07:16:05.000Z</published>
    <updated>2017-07-20T14:39:59.325Z</updated>
    
    <content type="html"><![CDATA[<p>由于项目使用 React, React-Router, Redux 来开发项目，采取了前端渲染的方式（如果采用 ssr 就不会有这个问题）。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>所以每到一个页面，需要发一个初始化的请求来获取页面数据，然后重新渲染页面，所以之前一个页面从请求到加载完毕的流程是这样的：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Route match -&gt; ComponentWillMount -&gt;  render -&gt; ComponentDidMount -&gt; dispatch(init())-&gt;  render -&gt; componentDidUpdate</span><br></pre></td></tr></table></figure></p><p>首先是路由匹配，然后准备加载组件，使用通过 <code>Reducer</code> 里面的初始化 <code>state</code> 进行 <code>render</code>, 然后触发 <code>ComponentDidMount</code> 事件，在这个事件里面去 <code>dispatch</code> 一个执行页面初始化的请求的 <code>Action</code>，请求成功过以后触发组件的重新渲染。</p><p>可以看到，展示最终的页面需要组件重新渲染两次。一次是使用写死在前端的<code>reducer</code> 里面的 <code>initialState</code> 数据来渲染，一次是在拿到后端数据进行的渲染。</p><p>所以有的时候会出现闪屏的情况，用户体验很不好。</p><p>我们的要求是进页面以后就是用从后台获取的最新数据渲染的页面，整个页面只会 <code>render</code> 一次。</p><p>那么怎么解决这个问题呢？</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>要解决这个问题，那么必然是加载好数据后，再去挂载页面组件，那么加载数据的时机就显得尤为重要。<br><a id="more"></a><br>借鉴传统服务端渲染页面的方式，这个时机肯定是放在路由里面去做比较合适。</p><p>具体到项目里面，就是在 <code>react-route</code> 里面的 <code>onEnter</code> 事件里面去做页面的初始化请求，当所有数据请求成功以后，在去加载这个页面。</p><p>整个页面加载的流程就变成了这样：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Route match -&gt; dispatch(init()) -&gt; ComponentWillMount -&gt;  render -&gt; ComponentDidMount</span><br></pre></td></tr></table></figure></p><h3 id="具体代码如下："><a href="#具体代码如下：" class="headerlink" title="具体代码如下："></a>具体代码如下：</h3><p><strong>HomeAction.js</strong><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createAction&#125; <span class="keyword">from</span> <span class="string">'redux-actions'</span></span><br><span class="line"><span class="keyword">import</span> &#123;HOME_INDEX&#125; <span class="keyword">from</span> <span class="string">'../../config/apis.js'</span></span><br><span class="line"><span class="keyword">import</span> initAPI <span class="keyword">from</span> <span class="string">'../../utils/initAPI.js'</span></span><br><span class="line"><span class="keyword">import</span> createAsyncAction <span class="keyword">from</span> <span class="string">'../../utils/createAsyncAction.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> InitActionList = createAsyncAction(<span class="string">'home/init'</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> FormChange = <span class="string">'home/formChange'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> FormFieldChange = <span class="string">'home/formFieldChange'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> initAPI(InitActionList, HOME_INDEX, <span class="string">'get'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>HomeReducer.js</strong><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; InitActionList &#125; <span class="keyword">from</span> <span class="string">'./HomeAction.js'</span></span><br><span class="line"><span class="keyword">import</span> &#123; CreditStatus, BillStatus, InstallmentStatus &#125; <span class="keyword">from</span> <span class="string">'../../config/constant'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initState = &#123;</span><br><span class="line">  foo: <span class="number">1</span>,</span><br><span class="line">  bar: <span class="number">10</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params">state = initState, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> type = action.type</span><br><span class="line">  <span class="keyword">const</span> payload = action.payload</span><br><span class="line">  <span class="keyword">const</span> meta = action.meta</span><br><span class="line">  <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">    <span class="keyword">case</span> InitActionList.start:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">    <span class="keyword">case</span> InitActionList.success:</span><br><span class="line">      <span class="keyword">const</span> currentStatus = getCurrentStatus(payload)</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        foo: currentStatus,</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">case</span> InitActionList.failure:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>Router.js</strong><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;init <span class="keyword">as</span> initHome&#125; <span class="keyword">from</span> <span class="string">'./homeAction'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">createRoutes</span> (<span class="params">store</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">initHome</span> (<span class="params">store</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">nextState, replace, next</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// dispatch 页面加载的 Action，在数据加载完成后在执行 next() 以挂载组件</span></span><br><span class="line">      store.dispatch(homeInit())</span><br><span class="line">        .then(<span class="function"><span class="params">()</span> =&gt;</span> next())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    component: App,</span><br><span class="line">    path: <span class="string">'/'</span>,</span><br><span class="line">    childRoutes: [</span><br><span class="line">      <span class="built_in">require</span>(<span class="string">'./activate'</span>),</span><br><span class="line">      &#123;</span><br><span class="line">        path: <span class="string">'test'</span>,</span><br><span class="line">        getComponent(nextState, cb) &#123;</span><br><span class="line">          <span class="built_in">require</span>.ensure([], <span class="built_in">require</span> =&gt; &#123;</span><br><span class="line">            cb(<span class="literal">null</span>, <span class="built_in">require</span>(<span class="string">'../views/Test'</span>).default)</span><br><span class="line">          &#125;, <span class="string">'Test'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    indexRoute: &#123;</span><br><span class="line">      getComponent(nextState, cb) &#123;</span><br><span class="line">        <span class="built_in">require</span>.ensure([], <span class="built_in">require</span> =&gt; &#123;</span><br><span class="line">          cb(<span class="literal">null</span>, <span class="built_in">require</span>(<span class="string">'../views/Home'</span>).default)</span><br><span class="line">        &#125;, <span class="string">'Home'</span>)</span><br><span class="line">      &#125;,</span><br><span class="line">      onEnter: initHome(store)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>Index.js</strong><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123; render &#125; <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Router, hashHistory &#125; <span class="keyword">from</span> <span class="string">'react-router'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></span><br><span class="line"><span class="keyword">import</span> &#123; syncHistoryWithStore &#125; <span class="keyword">from</span> <span class="string">'react-router-redux'</span></span><br><span class="line"><span class="keyword">import</span> &#123; AppContainer &#125; <span class="keyword">from</span> <span class="string">'react-hot-loader'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'react-hot-loader/patch'</span></span><br><span class="line"><span class="keyword">import</span> createRoutes <span class="keyword">from</span> <span class="string">'./routes'</span></span><br><span class="line"><span class="keyword">import</span> configureStore <span class="keyword">from</span> <span class="string">'./store'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./style/app.scss'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> store = configureStore(hashHistory, &#123;&#125;)</span><br><span class="line"><span class="keyword">const</span> history = syncHistoryWithStore(hashHistory, store)</span><br><span class="line"><span class="keyword">const</span> root = <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line"><span class="keyword">const</span> routers = createRoutes(store)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> renderRoot = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  render(</span><br><span class="line">    &lt;AppContainer&gt;</span><br><span class="line">      &lt;Provider store=&#123;store&#125; key=<span class="string">'provider'</span>&gt;</span><br><span class="line">        &lt;Router routes=&#123;routers&#125; history=&#123;history&#125; key=&#123;<span class="built_in">Math</span>.random()&#125; /&gt;</span><br><span class="line">      &lt;<span class="regexp">/Provider&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>AppContainer&gt;,</span><br><span class="line">    root</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">module</span>.hot) &#123;</span><br><span class="line">  <span class="built_in">module</span>.hot.accept(<span class="string">'./routes'</span>, () =&gt; &#123;</span><br><span class="line">    renderRoot()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">renderRoot()</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于项目使用 React, React-Router, Redux 来开发项目，采取了前端渲染的方式（如果采用 ssr 就不会有这个问题）。&lt;/p&gt;
&lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;所以每到一个页面，需要发一个初始化的请求来获取页面数据，然后重新渲染页面，所以之前一个页面从请求到加载完毕的流程是这样的：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Route match -&amp;gt; ComponentWillMount -&amp;gt;  render -&amp;gt; ComponentDidMount -&amp;gt; dispatch(init())-&amp;gt;  render -&amp;gt; componentDidUpdate&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;首先是路由匹配，然后准备加载组件，使用通过 &lt;code&gt;Reducer&lt;/code&gt; 里面的初始化 &lt;code&gt;state&lt;/code&gt; 进行 &lt;code&gt;render&lt;/code&gt;, 然后触发 &lt;code&gt;ComponentDidMount&lt;/code&gt; 事件，在这个事件里面去 &lt;code&gt;dispatch&lt;/code&gt; 一个执行页面初始化的请求的 &lt;code&gt;Action&lt;/code&gt;，请求成功过以后触发组件的重新渲染。&lt;/p&gt;
&lt;p&gt;可以看到，展示最终的页面需要组件重新渲染两次。一次是使用写死在前端的&lt;code&gt;reducer&lt;/code&gt; 里面的 &lt;code&gt;initialState&lt;/code&gt; 数据来渲染，一次是在拿到后端数据进行的渲染。&lt;/p&gt;
&lt;p&gt;所以有的时候会出现闪屏的情况，用户体验很不好。&lt;/p&gt;
&lt;p&gt;我们的要求是进页面以后就是用从后台获取的最新数据渲染的页面，整个页面只会 &lt;code&gt;render&lt;/code&gt; 一次。&lt;/p&gt;
&lt;p&gt;那么怎么解决这个问题呢？&lt;/p&gt;
&lt;h2 id=&quot;解决方案&quot;&gt;&lt;a href=&quot;#解决方案&quot; class=&quot;headerlink&quot; title=&quot;解决方案&quot;&gt;&lt;/a&gt;解决方案&lt;/h2&gt;&lt;p&gt;要解决这个问题，那么必然是加载好数据后，再去挂载页面组件，那么加载数据的时机就显得尤为重要。&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="https://blog.kisnows.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="React" scheme="https://blog.kisnows.com/tags/react/"/>
    
      <category term="Redux" scheme="https://blog.kisnows.com/tags/redux/"/>
    
      <category term="react-router" scheme="https://blog.kisnows.com/tags/react-router/"/>
    
  </entry>
  
  <entry>
    <title>一个 React Form 组件的重构思路</title>
    <link href="https://blog.kisnows.com/2017/03/17/react-form-rework-thinking/"/>
    <id>https://blog.kisnows.com/2017/03/17/react-form-rework-thinking/</id>
    <published>2017-03-17T13:31:31.000Z</published>
    <updated>2017-03-17T14:24:07.512Z</updated>
    
    <content type="html"><![CDATA[<p>最近对团队内部 React 组件库（<a href="https://github.com/NE-LOAN-FED/NE-Component" target="_blank" rel="noopener"><strong>ne-rc</strong></a>）中的 Form 组件进行了重构，记录一下思考的过程。</p><p>一些前置定义：</p><table><thead><tr><th>名词</th><th>定义</th></tr></thead><tbody><tr><td>表单</td><td>Form 组件</td></tr><tr><td>子表单</td><td>嵌套在 Form 下面的类似 Input, Select 这样的子组件</td></tr></tbody></table><p>首先我们看一下，我们的对 Form 组件的需求是什么。</p><ol><li>获取当前变动表单的状态<ul><li>校验所有必填表单是否填写完成</li><li>对外触发具体表单变化的方法 <code>formFieldChange</code></li></ul></li><li>暴露对外提供整个表单状态的方法<ul><li>提供整个表单最新状态的方法 $Form.data</li></ul></li><li>提交方法<ul><li>校验表单是否通过校验</li><li>对外触发 <code>formSubmit</code> 方法</li></ul></li></ol><p>接着我们从重构前和重构后，看如何来解决这个问题。</p><h1 id="Before"><a href="#Before" class="headerlink" title="Before"></a><strong>Before</strong></h1><h2 id="获取当前变动表单的状态"><a href="#获取当前变动表单的状态" class="headerlink" title="获取当前变动表单的状态"></a>获取当前变动表单的状态</h2><h3 id="如何获取变动的子表单"><a href="#如何获取变动的子表单" class="headerlink" title="如何获取变动的子表单"></a>如何获取变动的子表单</h3><p>React 父子通信需要通过 prop 传递方法，对于 Form 下面的类似与 Input 之类的子表单的变化想要通知到父级，如果不借助第三方的事件传递方法，那么就只能通过由父级通过 props 向 Input 传递 <code>formFieldChange</code>（假设就叫这个名字）方法，然后当子组件变化时去调用 <code>formFieldChange</code> 来实现。</p><p>那么问题来了，什么时候去传递这个方法呢？</p><p>不能在具体页面里面使用的时候再去每条表单里面注册这个方法，那每个用到表单组件的时候就都需要给子表单进行这样的事件绑定，这样太累了。</p><p>所以一开始，我选择通过直接递归的遍历 Form 下面的 children，只要发现这个 children 是我想要的表单类型，那么就重新克隆一个带有 <code>formFieldChange</code> 的组件来替换掉原来的组件。<br><a id="more"></a><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 获取 form 下面每一个表单对象，注入属性，并收集起来</span></span><br><span class="line"><span class="comment">  * @param children</span></span><br><span class="line"><span class="comment">  * @returns &#123;*&#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getForms</span>(<span class="params">children</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> React.Children.map(children, (el, i) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (!el) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (el.type) &#123;</span><br><span class="line">      <span class="keyword">case</span> Input:</span><br><span class="line">        Forms.push(el)</span><br><span class="line">        <span class="keyword">return</span> React.cloneElement(</span><br><span class="line">          el,</span><br><span class="line">          &#123;</span><br><span class="line">            key: i,</span><br><span class="line">            formFieldChange,</span><br><span class="line">            emptyInput</span><br><span class="line">          &#125;</span><br><span class="line">        )</span><br><span class="line">      <span class="keyword">case</span> Select:</span><br><span class="line">        Forms.push(el)</span><br><span class="line">        <span class="keyword">return</span> React.cloneElement(</span><br><span class="line">          el,</span><br><span class="line">          &#123;</span><br><span class="line">            key: i,</span><br><span class="line">            formFieldChange</span><br><span class="line">          &#125;</span><br><span class="line">        )</span><br><span class="line">      <span class="keyword">case</span> CheckBox:</span><br><span class="line">        Forms.push(el)</span><br><span class="line">        <span class="keyword">return</span> React.cloneElement(</span><br><span class="line">          el,</span><br><span class="line">          &#123;</span><br><span class="line">            key: i,</span><br><span class="line">            formFieldChange</span><br><span class="line">          &#125;</span><br><span class="line">        )</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">if</span> (el.props &amp;&amp; el.props.children <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</span><br><span class="line">          <span class="keyword">const</span> children = getForms(el.props.children)</span><br><span class="line">          <span class="keyword">return</span> React.cloneElement(</span><br><span class="line">            el,</span><br><span class="line">            &#123;</span><br><span class="line">              key: i,</span><br><span class="line">              children</span><br><span class="line">            &#125;</span><br><span class="line">          )</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> el</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样，所有的特定子组件就都可以拿到被注册的方法。以 Input 为例，在 Input 的 <code>onChange</code> 方法里面去调用从父级 props 传入的 <code>formFieldChange</code> 就可以通知到 Form 组件了。</p><h3 id="收集变动表单的数据。"><a href="#收集变动表单的数据。" class="headerlink" title="收集变动表单的数据。"></a>收集变动表单的数据。</h3><p>前一步完成后，这一步就比较简单了，Input 在调用 <code>formFieldChange</code> 的时候把想要传递的数据作为参数传进去，在 Form 里面去对这个参数做处理，就可以拿到当前变动的表单状态数据了。</p><h3 id="校验表单是否填写完成"><a href="#校验表单是否填写完成" class="headerlink" title="校验表单是否填写完成"></a>校验表单是否填写完成</h3><p>前面我们收集了每一条变动表单的数据。但是要判断当前 Form 下面的表单是否填写完成，那么首先需要知道我们有多少个需要填写的表单，然后在 <code>formFieldChange</code> 的时候进行判断就可以了。如何来提前知道我们有多少需要填写的 Field 呢，之前我选择的是通过在使用 Form 的时候先初始化一个包含所有表单初始化状态的数据。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Form</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.Forms = []</span><br><span class="line">    <span class="keyword">this</span>.formState = <span class="built_in">Object</span>.assign(&#123;&#125;, &#123;</span><br><span class="line">      isComplete: <span class="literal">false</span>,</span><br><span class="line">      isValidate: <span class="literal">false</span>,</span><br><span class="line">      errorMsg: <span class="string">''</span>,</span><br><span class="line">      data: &#123;&#125;</span><br><span class="line">    &#125;, <span class="keyword">this</span>.props.formState)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> propTypes = &#123;</span><br><span class="line">    onChange: PropTypes.func,</span><br><span class="line">    onSubmit: PropTypes.func,</span><br><span class="line">    formState: PropTypes.object</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">// 初始化一个类似这样的对象传递给 Form</span></span><br><span class="line">formState: &#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    realName: &#123;&#125;,</span><br><span class="line">    cityId: &#123;&#125;,</span><br><span class="line">    email: &#123;&#125;,</span><br><span class="line">    relativeName: &#123;&#125;,</span><br><span class="line">    relativePhone: &#123;&#125;,</span><br><span class="line">    companyName: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><p>这样就很粗暴的解决了这个问题，但是这中间存在很多问题。</p><p>因为限定了特定的组件类型（Input，Select，CheckBox），导致不利于扩展，如果在开发过程遇到其他类型的比如自定义的子表单，那么 Form 就没法对这个自定义子表单进行数据收集，解决起来比较麻烦。</p><p>所以就在考虑另一个种实现方式， Form 只去收集一个特定条件下的组件，只要这个组件满足了这个条件，并实现了对应的接口，那么 Form 就都可以去收集处理。这样也就大大挺高了适用性。</p><h2 id="暴露对外提供整个表单状态的方法"><a href="#暴露对外提供整个表单状态的方法" class="headerlink" title="暴露对外提供整个表单状态的方法"></a>暴露对外提供整个表单状态的方法</h2><p>通过在外监听每次 Form 触发的 <code>onChange</code> 事件来获取整个 Form 的状态。</p><h2 id="提交方法"><a href="#提交方法" class="headerlink" title="提交方法"></a>提交方法</h2><h3 id="检验表单是否通过校验"><a href="#检验表单是否通过校验" class="headerlink" title="检验表单是否通过校验"></a>检验表单是否通过校验</h3><p>已经有了整个 Form 的数据对象，做校验并不是什么困难。通过校验的时候调用 <code>formSubmit</code> 方法，没有通过校验的时候对外把错误信息添加到 Form 的 state 上去。</p><h3 id="对外触发-formSubmit-方法"><a href="#对外触发-formSubmit-方法" class="headerlink" title="对外触发 formSubmit 方法"></a>对外触发 formSubmit 方法</h3><p>当表单通过校验的时候，对外触发 <code>formSubmit</code> 方法，把要提交的数据作为 <code>formSubmit</code> 的参数传递给外面。</p><h1 id="After"><a href="#After" class="headerlink" title="After"></a><strong>After</strong></h1><p>前面是之前写的 Form 组件的一些思路，在实际使用中也基本能满足业务需求。</p><p>但是整个 Form 的可拓展性比较差，无法很好的接入其他自定义的组件。所以萌生了重写的想法。</p><p>对于重写的这个 Form，我的想法是：首先一定要方便使用，不需要一大堆的起始工作；其次就是可拓展性要强，除了自己已经提供的内在 Input，Select 等能够接入 Form 外，对于其他的业务中的特殊需求需要接入 Form 的时候，只要这个组件实现了特定的接口就可以了很方便的接入，而不需要大量的去修改组件内部的代码。</p><p>重构主要集中在上面需求 1 里面的内容，也就是：<strong>获取当前变动表单的状态</strong></p><p>获取当前表单的状态分解下来有一下几点：</p><ul><li>获取所有需要收集的子表单 <code>formFields</code></li><li>初始化 Form <code>state</code></li><li>表单下面子表单数量或类型发生变化时更新 1 里面创建的 <code>formFields</code></li><li>子表单内部状态发生变化时通知到父表单</li></ul><h2 id="获取当前变动表单的状态-1"><a href="#获取当前变动表单的状态-1" class="headerlink" title="获取当前变动表单的状态"></a>获取当前变动表单的状态</h2><h3 id="获取所有需要的子表单"><a href="#获取所有需要的子表单" class="headerlink" title="获取所有需要的子表单"></a>获取所有需要的子表单</h3><p>同样通过递归遍历 children 来获取需要收集的子表单，通过子表单的 type.name 命名规则是否符合我们的定义来决定是否要进行收集。<br>直接来看代码：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">collectFormField = <span class="function">(<span class="params">children</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleFieldChange = <span class="keyword">this</span>.handleFieldChange</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 简单粗暴，在 Form 更新的时候直接清空上一次保存的 formFields，全量更新，</span></span><br><span class="line">  <span class="comment">// 避免 formFields 内容或者数量发生变化时 this.formFields 数据不正确的问题</span></span><br><span class="line">  <span class="keyword">const</span> FormFields = <span class="keyword">this</span>.formFields = []</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getChildList</span>(<span class="params">children</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> React.Children.map(children, (el, i) =&gt; &#123;</span><br><span class="line">      <span class="comment">// 只要 Name 以 _Field 开头，就认为是需要 From 管理的组件</span></span><br><span class="line">      <span class="keyword">if</span> (!el || el === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> reg = <span class="regexp">/^_Field/</span></span><br><span class="line">      <span class="keyword">const</span> childName = el.type &amp;&amp; el.type.name</span><br><span class="line">      <span class="keyword">if</span> (reg.test(childName)) &#123;</span><br><span class="line">        FormFields.push(el)</span><br><span class="line">        <span class="keyword">return</span> React.cloneElement(el, &#123;</span><br><span class="line">          key: i,</span><br><span class="line">          handleFieldChange</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (el.props &amp;&amp; el.props.children) &#123;</span><br><span class="line">          <span class="keyword">const</span> children = getChildList(el.props.children)</span><br><span class="line">          <span class="keyword">return</span> React.cloneElement(el, &#123;</span><br><span class="line">            key: i,</span><br><span class="line">            children</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> el</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>只要组件的 class name 以 _Field 开头，就把它收集起来，并传入 <code>handleFieldChange</code> 方法，这样当一个自定义组件接入的时候，只需要在外面包一层，并把 class 的命名为以 _Field 开头的格式就可以被 Form 收集管理了。</p><p>接入组件里面需要做的就是，在合适的时机调用 <code>handleFieldChange</code> 方法，并把要传递的数据作为参数传递出来就可以了。</p><p>为什么一定要执迷不悟的使用遍历这种低效的方式去收集呢，其实都是为了组件上使用的方便。这样就不需要每次在引用的时候在对子表单做什么操作了。</p><h3 id="初始化-Form-state"><a href="#初始化-Form-state" class="headerlink" title="初始化 Form state"></a>初始化 Form state</h3><p>上一步拿到了所有的子表单，然后通过调用 <code>initialFormDataStructure</code> 拿来初始化 Form 的 <code>state.data</code> 的结构，同时通知到外面 Form 发生了变化。</p><h3 id="子表单数量或类型发生变化时"><a href="#子表单数量或类型发生变化时" class="headerlink" title="子表单数量或类型发生变化时"></a>子表单数量或类型发生变化时</h3><p>当 Form 下面子组件被添加或删除时，需要及时更新 Form Data 的结构。通过调用 <code>updateFormDataStructure</code><br>把新增的或者修改的子表单更新到最新，并通知到外面 Form 发生了变化。</p><h3 id="子表单内部状态发生变化时"><a href="#子表单内部状态发生变化时" class="headerlink" title="子表单内部状态发生变化时"></a>子表单内部状态发生变化时</h3><p>在第一步收集子表单的时候就已经把 <code>handleFieldChange</code> 注入到了子表单组件里面，所以子表单来决定调用的时机。当 <code>handleFieldChange</code> 被调用的时候，首先对 Form <code>state</code> 进行更新，然后外通知子表单发生了变化，同时通知外面 Form 发生了变化。</p><p>这样看起来整个流程就走通了，但实际上存在很多问题。</p><p>首先由于 <code>setState</code> 是一个异步的过程，只有在 <code>render</code> 后才能获取到最新的 <code>state</code>. 这就导致，在一个生命周期循环内如果我多次调用了 <code>setState</code> ，那么两次调用之间对 <code>state</code> 的读取很可能是不准确的。（有关生命周期的详细内容可以看这篇文章：<a href="https://www.w3ctech.com/topic/1596）" target="_blank" rel="noopener">https://www.w3ctech.com/topic/1596）</a></p><p>所以我创建了一个临时变量 <code>currentState</code> 来存放当前状态下最新的 <code>state</code>，每次 <code>setState</code> 的时候都对其进行更新。</p><p>另一个问题是当 Form 发生变化的时候，<code>updateFormDataStructure</code> 调用的过于频繁。其实只有在子表单的数量或者类型发生变化时才需要更新 Form state 的结构。而直接去对比子表单的类型是否发生变化也是意见开销很大操作，所以选择另一种折中方式。通过给 Form 当前的状态打标，将 Form 可能处于的状态都标识出来：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> STATUS = &#123;</span><br><span class="line">  Init: <span class="string">'Init'</span>,</span><br><span class="line">  Normal: <span class="string">'Normal'</span>,</span><br><span class="line">  FieldChange: <span class="string">'FieldChange'</span>,</span><br><span class="line">  UpdateFormDataStructure: <span class="string">'UpdateFormDataStructure'</span>,</span><br><span class="line">  Submit: <span class="string">'Submit'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样，只有在 Form 的 <code>STATUS</code> 处于 <code>Normal</code> 的时候才对其进行 <code>updateFormDataStructure</code> 操作。这样就可以省去很多次渲染以及无效的对外触发的 <code>FormChange</code> 事件。</p><p>提交和对外暴露 Form 状态的方法和之前基本一致，这样整个对 Form 的重构就算完成了，具体项目中使用体验还不错 O(∩_∩)O</p><p>Form 组件地址： <a href="https://github.com/NE-LOAN-FED/NE-Component/tree/master/src/Form" target="_blank" rel="noopener">https://github.com/NE-LOAN-FED/NE-Component/tree/master/src/Form</a></p><p>最后，如果看文章的你有什么更好的想法，请告诉我😛。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近对团队内部 React 组件库（&lt;a href=&quot;https://github.com/NE-LOAN-FED/NE-Component&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;strong&gt;ne-rc&lt;/strong&gt;&lt;/a&gt;）中的 Form 组件进行了重构，记录一下思考的过程。&lt;/p&gt;
&lt;p&gt;一些前置定义：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名词&lt;/th&gt;
&lt;th&gt;定义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;表单&lt;/td&gt;
&lt;td&gt;Form 组件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;子表单&lt;/td&gt;
&lt;td&gt;嵌套在 Form 下面的类似 Input, Select 这样的子组件&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;首先我们看一下，我们的对 Form 组件的需求是什么。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;获取当前变动表单的状态&lt;ul&gt;
&lt;li&gt;校验所有必填表单是否填写完成&lt;/li&gt;
&lt;li&gt;对外触发具体表单变化的方法 &lt;code&gt;formFieldChange&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;暴露对外提供整个表单状态的方法&lt;ul&gt;
&lt;li&gt;提供整个表单最新状态的方法 $Form.data&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;提交方法&lt;ul&gt;
&lt;li&gt;校验表单是否通过校验&lt;/li&gt;
&lt;li&gt;对外触发 &lt;code&gt;formSubmit&lt;/code&gt; 方法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;接着我们从重构前和重构后，看如何来解决这个问题。&lt;/p&gt;
&lt;h1 id=&quot;Before&quot;&gt;&lt;a href=&quot;#Before&quot; class=&quot;headerlink&quot; title=&quot;Before&quot;&gt;&lt;/a&gt;&lt;strong&gt;Before&lt;/strong&gt;&lt;/h1&gt;&lt;h2 id=&quot;获取当前变动表单的状态&quot;&gt;&lt;a href=&quot;#获取当前变动表单的状态&quot; class=&quot;headerlink&quot; title=&quot;获取当前变动表单的状态&quot;&gt;&lt;/a&gt;获取当前变动表单的状态&lt;/h2&gt;&lt;h3 id=&quot;如何获取变动的子表单&quot;&gt;&lt;a href=&quot;#如何获取变动的子表单&quot; class=&quot;headerlink&quot; title=&quot;如何获取变动的子表单&quot;&gt;&lt;/a&gt;如何获取变动的子表单&lt;/h3&gt;&lt;p&gt;React 父子通信需要通过 prop 传递方法，对于 Form 下面的类似与 Input 之类的子表单的变化想要通知到父级，如果不借助第三方的事件传递方法，那么就只能通过由父级通过 props 向 Input 传递 &lt;code&gt;formFieldChange&lt;/code&gt;（假设就叫这个名字）方法，然后当子组件变化时去调用 &lt;code&gt;formFieldChange&lt;/code&gt; 来实现。&lt;/p&gt;
&lt;p&gt;那么问题来了，什么时候去传递这个方法呢？&lt;/p&gt;
&lt;p&gt;不能在具体页面里面使用的时候再去每条表单里面注册这个方法，那每个用到表单组件的时候就都需要给子表单进行这样的事件绑定，这样太累了。&lt;/p&gt;
&lt;p&gt;所以一开始，我选择通过直接递归的遍历 Form 下面的 children，只要发现这个 children 是我想要的表单类型，那么就重新克隆一个带有 &lt;code&gt;formFieldChange&lt;/code&gt; 的组件来替换掉原来的组件。&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="https://blog.kisnows.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="React" scheme="https://blog.kisnows.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>【翻译向】Webpack 1 到 2 升级指南</title>
    <link href="https://blog.kisnows.com/2017/01/19/webpack2-migrating-v1-v2/"/>
    <id>https://blog.kisnows.com/2017/01/19/webpack2-migrating-v1-v2/</id>
    <published>2017-01-19T09:00:33.000Z</published>
    <updated>2017-03-17T14:17:38.722Z</updated>
    
    <content type="html"><![CDATA[<h2 id="resolve-root-resolve-fallback-resolve-modulesDirectories"><a href="#resolve-root-resolve-fallback-resolve-modulesDirectories" class="headerlink" title="resolve.root,resolve.fallback,resolve.modulesDirectories"></a><code>resolve.root</code>,<code>resolve.fallback</code>,<code>resolve.modulesDirectories</code></h2><p>这些配置项项都被一个单独的配置所替代 <code>resolve.modules</code>. 查看 <a href="https://webpack.js.org/configuration/resolve" target="_blank" rel="noopener">resolving</a> 了解更多。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">-   root: path.join(__dirname, <span class="string">"src"</span>)</span><br><span class="line">+   modules: [</span><br><span class="line">+     path.join(__dirname, <span class="string">"src"</span>),</span><br><span class="line">+     <span class="string">"node_modules"</span></span><br><span class="line">+   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="resolve-extensions"><a href="#resolve-extensions" class="headerlink" title="resolve.extensions"></a><code>resolve.extensions</code></h2><p>这个选项已经不在需要传一个空字符串了。它的行为已经被移动到了 <code>resolve.enforceExtension</code>. 查看 <a href="https://webpack.js.org/configuration/resolve" target="_blank" rel="noopener">resolving</a> 了解更多。</p><h2 id="resolve"><a href="#resolve" class="headerlink" title="resolve.*"></a><code>resolve.*</code></h2><p>这里修改了很多内容。因为被用到的不是很多，所以就不一一列举出来了。查看 <a href="https://webpack.js.org/configuration/resolve" target="_blank" rel="noopener">resolving</a> 了解更多。</p><h2 id="module-loaders-现在是-module-rules"><a href="#module-loaders-现在是-module-rules" class="headerlink" title="module.loaders 现在是 module.rules"></a><code>module.loaders</code> 现在是 <code>module.rules</code></h2><p>老的 loader 配置被一个更加强大的 rules 系统所取代了，允许配置 loader 和更多内容。为了保证一致性，旧的 <code>module.loaders</code> 语法依然可以合法且可以使用的。新的命名规范更加易于理解，这是一个使用 <code>module.rules</code> 去升级配置的很好的理由。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">-   loaders: [</span><br><span class="line">+   rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">-       loaders: [</span><br><span class="line">+       use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">"style-loader"</span></span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">"css-loader"</span>,</span><br><span class="line">-           query: &#123;</span><br><span class="line">+           options: &#123;</span><br><span class="line">              modules: <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.jsx$/</span>,</span><br><span class="line">        loader: <span class="string">"babel-loader"</span>, <span class="comment">// Do not use "use" here</span></span><br><span class="line">        options: &#123;</span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="把-loader-链接起来（Chaining-loaders）"><a href="#把-loader-链接起来（Chaining-loaders）" class="headerlink" title="把 loader 链接起来（Chaining loaders）"></a>把 loader 链接起来（Chaining loaders）</h2><p>就像在 webpack1 中那样，loader 可以被链接起来，把上一个 loader 的结果传递给下一个 loader. 使用 <a href="https://webpack.js.org/configuration/module#rule-use" target="_blank" rel="noopener">rule.use</a>， <code>use</code> 可以设置为一个 loaders 的列表。在 webpack1 中，loader 通过 <code>!</code> 来链接再一起。现在只会在 <code>module.loaders</code> 里面才会支持这样的风格。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">-   loaders: &#123;</span><br><span class="line">+   rules: &#123;</span><br><span class="line">      test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">-     loader: <span class="string">"style-loader!css-loader!less-loader"</span></span><br><span class="line">+     use: [</span><br><span class="line">+       <span class="string">"style-loader"</span>,</span><br><span class="line">+       <span class="string">"css-loader"</span>,</span><br><span class="line">+       <span class="string">"less-loader"</span></span><br><span class="line">+     ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="自动添加-loader-后辍的特性被移除了"><a href="#自动添加-loader-后辍的特性被移除了" class="headerlink" title="自动添加 -loader 后辍的特性被移除了"></a>自动添加 <code>-loader</code> 后辍的特性被移除了</h2><p>在引入 loader 的时候不能在省略后面的 <code>-loader</code> 了。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        use: [</span><br><span class="line">-         <span class="string">"style"</span>,</span><br><span class="line">+         <span class="string">"style-loader"</span>,</span><br><span class="line">-         <span class="string">"css"</span>,</span><br><span class="line">+         <span class="string">"css-loader"</span>,</span><br><span class="line">-         <span class="string">"less"</span>,</span><br><span class="line">+         <span class="string">"less-loader"</span>,</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>不过依旧可以使用 <code>resolveLoader.moduleExtensions</code> 配置来达到以前的目的，但是我们不推荐这样做。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ resolveLoader: &#123;</span><br><span class="line">+   moduleExtensions: [&quot;-loader&quot;]</span><br><span class="line">+ &#125;</span><br></pre></td></tr></table></figure></p><h2 id="不再需要-json-loader"><a href="#不再需要-json-loader" class="headerlink" title="不再需要 json-loader"></a>不再需要 <code>json-loader</code></h2><p>当没有给 sjon 文件配置对应的 loader 的时候，webpack 会自动使用 <code>json-loader</code> 来载入 JSON 文件。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">-     &#123;</span><br><span class="line">-       test: /\.json/,</span><br><span class="line">-       loader: &quot;json-loader&quot;</span><br><span class="line">-     &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>webpack 选择这样做的目的是想要抹平在 webpack，nodejs 和 browserify 不同环境下的区别。</p><h2 id="配置中的-loaders-会相对与上下文来解析（Loaders-in-configuration-resolve-relative-to-context）"><a href="#配置中的-loaders-会相对与上下文来解析（Loaders-in-configuration-resolve-relative-to-context）" class="headerlink" title="配置中的 loaders 会相对与上下文来解析（Loaders in configuration resolve relative to context）"></a>配置中的 loaders 会相对与上下文来解析（Loaders in configuration resolve relative to context）</h2><p>在 webpack1 中配置的 loader 会相对与匹配到的文件解析。但是 webapck2 中配置的 loader 会根据 <code>context</code> 的设置来解析。</p><p>这解决了当由于使用 <code>npm link</code> 或者引用 <code>context</code> 之外导致模块重复引入的问题。</p><p>你可能会通过 hach 的方式解决这个问题：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        // ...</span><br><span class="line">-       loader: require.resolve(&quot;my-loader&quot;)</span><br><span class="line">+       loader: &quot;my-loader&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  resolveLoader: &#123;</span><br><span class="line">-   root: path.resolve(__dirname, &quot;node_modules&quot;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p><code>module.preLoades</code> 和 <code>module.postLoaders</code> 被移除了<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  module: &#123;</span><br><span class="line">-   preLoaders: [</span><br><span class="line">+   rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.js$/,</span><br><span class="line">+       enforce: &quot;pre&quot;,</span><br><span class="line">        loader: &quot;eslint-loader&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h2 id="UglifyJsPlugin-sourceMap"><a href="#UglifyJsPlugin-sourceMap" class="headerlink" title="UglifyJsPlugin sourceMap"></a><code>UglifyJsPlugin</code> sourceMap</h2><p><code>UglifyJsPlugin</code> 中 <code>souceMap</code> 的默认选项从 <code>true</code> 改为了 <code>false</code>. 这意味着如果你需要在压缩后的代码中使用 souceMap 的功能，需要手动去配置 <code>sourceMap:false</code>.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  devtool: &quot;source-map&quot;,</span><br><span class="line">  plugins: [</span><br><span class="line">    new UglifyJsPlugin(&#123;</span><br><span class="line">+     sourceMap: true</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure><h2 id="UglifyJsPlugin-警告"><a href="#UglifyJsPlugin-警告" class="headerlink" title="UglifyJsPlugin 警告"></a><code>UglifyJsPlugin</code> 警告</h2><p><code>UglifyJsPlugin</code> 中 <code>compress.warnings</code>  和上一条一样，默认选项从 <code>true</code> 改为了 <code>false</code>.如果需要看到 uglifyjs 的警告，需要设置 <code>compress.warnings</code> 为 <code>true</code>.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  devtool: &quot;source-map&quot;,</span><br><span class="line">  plugins: [</span><br><span class="line">    new UglifyJsPlugin(&#123;</span><br><span class="line">+     compress: &#123;</span><br><span class="line">+       warnings: true</span><br><span class="line">+     &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure><h2 id="UglifyJsPlugin-压缩-loader（minimize-loaders）"><a href="#UglifyJsPlugin-压缩-loader（minimize-loaders）" class="headerlink" title="UglifyJsPlugin 压缩 loader（minimize loaders）"></a><code>UglifyJsPlugin</code> 压缩 loader（minimize loaders）</h2><p><code>UglifyJsPlugin</code> 不会在压缩模式下切换 loaders 了。<code>minimize: true</code> 需要一直被设置在配置来传给 loader 了，查看文档以了解更多的内容。</p><p>在 webpack3 或者后续的版本中，loaders 的压缩模式这个特性会被移除掉。</p><h2 id="BannderPlugin-breaking-change"><a href="#BannderPlugin-breaking-change" class="headerlink" title="BannderPlugin - breaking change"></a><code>BannderPlugin</code> - breaking change</h2><p><code>BannderPlugin</code> 不在支持传递两个参数，而是传递一个对象。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  plugins: [</span><br><span class="line">-    new webpack.BannerPlugin(&apos;Banner&apos;, &#123;raw: true, entryOnly: true&#125;);</span><br><span class="line">+    new webpack.BannerPlugin(&#123;banner: &apos;Banner&apos;, raw: true, entryOnly: true&#125;);</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure></p><h2 id="OccurrenceOrderPlugin-被作为默认设置"><a href="#OccurrenceOrderPlugin-被作为默认设置" class="headerlink" title="OccurrenceOrderPlugin 被作为默认设置"></a><code>OccurrenceOrderPlugin</code> 被作为默认设置</h2><p>不在需要手动去配置了<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  plugins: [</span><br><span class="line">-   new webpack.optimize.OccurrenceOrderPlugin()</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure></p><h2 id="ExtractTextWebpackPlugin-breaking-change"><a href="#ExtractTextWebpackPlugin-breaking-change" class="headerlink" title="ExtractTextWebpackPlugin - breaking change"></a><code>ExtractTextWebpackPlugin</code> - breaking change</h2><p>ExtractTextWebpackPlugin 1.0.0 无法在 webpack2 中正常工作，需要安装 ExtractTextPlugin V2 。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save-dev extract-text-webpack-plugin@beta</span><br></pre></td></tr></table></figure><p>配置的区别主要是在语法上。</p><p><code>ExtractTextPlugin.extract</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    test: /.css$/,</span><br><span class="line">-    loader: ExtractTextPlugin.extract(&quot;style-loader&quot;, &quot;css-loader&quot;, &#123; publicPath: &quot;/dist&quot; &#125;)</span><br><span class="line">+    loader: ExtractTextPlugin.extract(&#123;</span><br><span class="line">+      fallbackLoader: &quot;style-loader&quot;,</span><br><span class="line">+      loader: &quot;css-loader&quot;,</span><br><span class="line">+      publicPath: &quot;/dist&quot;</span><br><span class="line">+    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>new ExtractTextPlugin({options})</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">-  new ExtractTextPlugin(&quot;bundle.css&quot;, &#123; allChunks: true, disable: false &#125;)</span><br><span class="line">+  new ExtractTextPlugin(&#123;</span><br><span class="line">+    filename: &quot;bundle.css&quot;,</span><br><span class="line">+    disable: false,</span><br><span class="line">+    allChunks: true</span><br><span class="line">+  &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="全动态-require-会默认失败（Full-dynamic-requires-now-fail-by-default）"><a href="#全动态-require-会默认失败（Full-dynamic-requires-now-fail-by-default）" class="headerlink" title="全动态 require 会默认失败（Full dynamic requires now fail by default）"></a>全动态 require 会默认失败（Full dynamic requires now fail by default）</h2><p>一个由表达式决定的依赖会创建一个空的上下文来替代之前创建的一个包含完成文件夹的上下文。</p><p>最好重构这里的代码，因为它不会在 ES2015 模块里面工作。如果这对你来说不太可能，可以使用 <code>ContextReplacementPlugin</code> 来指定编译器找到正确的地址。</p><h2 id="在-CLI-和配置文件中使用自定义参数"><a href="#在-CLI-和配置文件中使用自定义参数" class="headerlink" title="在 CLI 和配置文件中使用自定义参数"></a>在 CLI 和配置文件中使用自定义参数</h2><p>如果你滥用 CLI 参数去传递自定义参数到配置中，像这样：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webapck --custom-stuff</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">var</span> customStuff = process.argv.indexOf(<span class="string">"--custom-stuff"</span>) &gt;= <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"><span class="built_in">module</span>.exports = config;</span><br></pre></td></tr></table></figure><p>你会发现这样不再被允许了，现在 CLI 比之前更加严格了。</p><p>作为替代，现在有一个接口用来给配置传递参数。未来的工具会基于这个。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webpack --env.customStuff</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">env</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> customStuff = env.customStuff;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">  <span class="keyword">return</span> config;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>查看 <a href="https://webpack.js.org/api/cli" target="_blank" rel="noopener">CLI</a></p><h2 id="require-ensure-和-AMD-require-是异步的了"><a href="#require-ensure-和-AMD-require-是异步的了" class="headerlink" title="require.ensure 和 AMD require 是异步的了"></a><code>require.ensure</code> 和 AMD <code>require</code> 是异步的了</h2><p>这些函数变成了异步的，代替之前如果代码块已经被加载后它们的回调函数会同步执行的行为。</p><p><strong><code>require.ensure</code> 现在依赖与原生的 <code>Promise</code>, 如果在一个不支持 <code>Promise</code> 的环境下使用 <code>require.ensure</code> ，那么你需要一个 polyfill.</strong></p><h2 id="Loader-的配置要通过-options"><a href="#Loader-的配置要通过-options" class="headerlink" title="Loader 的配置要通过 options"></a>Loader 的配置要通过 <code>options</code></h2><p>不能在通过在 <code>webpack.config.js</code> 中一个自定义的属性来配置 loader 了。必须通过 <code>options</code>. 下面这个 <code>ts</code> 属性的配置在 webpack2 中已经不合法了。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [&#123;</span><br><span class="line">    test: <span class="regexp">/\.tsx?$/</span>,</span><br><span class="line">    loader: <span class="string">'ts-loader'</span></span><br><span class="line">  &#125;]</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// does not work with webpack 2</span></span><br><span class="line">ts: &#123; <span class="attr">transpileOnly</span>: <span class="literal">false</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="什么是-options？"><a href="#什么是-options？" class="headerlink" title="什么是 options？"></a>什么是 <code>options</code>？</h2><p>好问题。严格的说，它可能是两个东西；都是用来配置一个 loader 的方式。典型的 <code>options</code> 被称为 <code>query</code>, 是一个可以被添加 loader 名字后面的字符串。更像一个 查询字符（query  string），但实际上是 <a href="https://github.com/webpack/loader-utils#parsequery" target="_blank" rel="noopener">greater powers</a></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [&#123;</span><br><span class="line">    test: <span class="regexp">/\.tsx?$/</span>,</span><br><span class="line">    loader: <span class="string">'ts-loader?'</span> + <span class="built_in">JSON</span>.stringify(&#123; <span class="attr">transpileOnly</span>: <span class="literal">false</span> &#125;)</span><br><span class="line">   &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样可以是一个指定的对象，和 loader 一同提供：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [&#123;</span><br><span class="line">    test: <span class="regexp">/\.tsx?$/</span>,</span><br><span class="line">    loader: <span class="string">'ts-loader'</span></span><br><span class="line">    options:  &#123; <span class="attr">transpileOnly</span>: <span class="literal">false</span> &#125;</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LoaderOptionsPlugin-上下文"><a href="#LoaderOptionsPlugin-上下文" class="headerlink" title="LoaderOptionsPlugin 上下文"></a><code>LoaderOptionsPlugin</code> 上下文</h2><p>一些 loader 需要从配置文件中读取上下文信息。这个需要长期的设置在 loader 的选项中。</p><p>为了兼容老的 loader，可以通过这个插件来传递给 loader：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  +   <span class="keyword">new</span> webpack.LoaderOptionsPlugin(&#123;</span><br><span class="line">    +     options: &#123;</span><br><span class="line">  +       context: __dirname</span><br><span class="line">  +     &#125;</span><br><span class="line">+   &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="debug"><a href="#debug" class="headerlink" title="debug"></a><code>debug</code></h2><p>在 webapck1 中 <code>debug</code> 选项用来把 loader 切换到 debug 模式。</p><p>在 webapck3 或更后面的版本中，这个模式会被移除掉。</p><p>为了兼容老的 loader，可以通过这个插件来传递参数给 loader：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- debug: true,</span><br><span class="line">  plugins: [</span><br><span class="line">+   new webpack.LoaderOptionsPlugin(&#123;</span><br><span class="line">+     debug: true</span><br><span class="line">+   &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="ES2015-代码分割"><a href="#ES2015-代码分割" class="headerlink" title="ES2015 代码分割"></a>ES2015 代码分割</h2><p>在 webpack1 中，可以通过 <code>require.ensure</code> 来懒加载一些代码块：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>.ensure([], <span class="function"><span class="keyword">function</span>(<span class="params">require</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> foo = <span class="built_in">require</span>(<span class="string">"./module"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在 ES2015 中我们使用 <code>import()</code> 作为一个方法在运行时动态的记载 ES2015.</p><p>webpack 会把 <code>import()</code> 作为一个分割点，并且把加载的代码分离出来作为一个单独的代码块。</p><p><code>import()</code> 需要一个模块的名称作为参数，并返回一个 Promise 对象。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">import</span>(<span class="string">"./module"</span>).then(<span class="function"><span class="params">module</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">module</span>.default;</span><br><span class="line">  &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Chunk loading failed"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好消息：现在代码块加载失败可以被处理了，因为它们是基于 Promise 的。</p><p>警告（Caveat）：<code>require.ensure</code> 可以方便的指定代码块的名字，通过第三个参数，但是 <code>import</code> API 还不支持这个特性。如果你还依赖这个功能，那么你可以继续使用 <code>require.ensure</code>.</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>.ensure([], <span class="function"><span class="keyword">function</span>(<span class="params">require</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> foo = <span class="built_in">require</span>(<span class="string">"./module"</span>);</span><br><span class="line">&#125;, <span class="string">"custom-chunk-name"</span>);</span><br></pre></td></tr></table></figure><p>如果想要和 Babel 结合使用 <code>import</code>, 你需要安装 <a href="http://babeljs.io/docs/plugins/syntax-dynamic-import/" target="_blank" rel="noopener">dynamic-import</a> 这个还处于 Stage 3 的语法插件来绕过语法解析错误。当这个提案被加到标准里面后，就不需要这么做了。</p><h2 id="动态表达式（Dynamic-expressions）"><a href="#动态表达式（Dynamic-expressions）" class="headerlink" title="动态表达式（Dynamic expressions）"></a>动态表达式（Dynamic expressions）</h2><p>很有可能你会需要传递一个表达式给 <code>import()</code>. 这里处理的模式跟 CommonJs 中很相似。</p><p><code>import()</code> 创建一个单独的代码块给每个可能的模块。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">route</span>(<span class="params">path, query</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">import</span>(<span class="string">`./routes/<span class="subst">$&#123;path&#125;</span>/route`</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">route</span> =&gt;</span> <span class="keyword">new</span> route.Route(query));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// This creates a separate chunk for each possible route</span></span><br></pre></td></tr></table></figure><h2 id="混合使用-ES2015，AMD-和-CommonJS"><a href="#混合使用-ES2015，AMD-和-CommonJS" class="headerlink" title="混合使用 ES2015，AMD 和 CommonJS"></a>混合使用 ES2015，AMD 和 CommonJS</h2><p>如果是 AMD 和 CommonJs ，那么它们完全可以很自由的混合使用。在这种情况下，Webpack 的处理的行为和 babel 或者 node-eps 相似。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CommonJS consuming ES2015 Module</span></span><br><span class="line"><span class="keyword">var</span> book = <span class="built_in">require</span>(<span class="string">"./book"</span>);</span><br><span class="line"></span><br><span class="line">book.currentPage;</span><br><span class="line">book.readPage();</span><br><span class="line">book.default === <span class="string">"This is a book"</span>;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES2015 Module consuming CommonJS</span></span><br><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">"fs"</span>; <span class="comment">// module.exports map to default</span></span><br><span class="line"><span class="keyword">import</span> &#123; readFileSync &#125; <span class="keyword">from</span> <span class="string">"fs"</span>; <span class="comment">// named exports are read from returned object+</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> fs.readFileSync === <span class="string">"function"</span>;</span><br><span class="line"><span class="keyword">typeof</span> readFileSync === <span class="string">"function"</span>;</span><br></pre></td></tr></table></figure><p>很重要的一点是，你需要告诉 babel 不要解析这些模块符号（module symbols），这样 webpack 才能使用它们。在 <code>.babelrc</code> 中这样配置就可以了：</p><p><strong>babelrc</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [</span><br><span class="line">    [&quot;es2015&quot;, &#123; &quot;modules&quot;: false &#125;]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>不需要修改什么，但是会很方便。</p><h3 id="字符串模板"><a href="#字符串模板" class="headerlink" title="字符串模板"></a>字符串模板</h3><p>webpack 现在支持在表达式中使用字符串模板了。这意味着可以在 webpack constructs 中使用他们：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- require(&quot;./templates/&quot; + name);</span><br><span class="line">+ require(`./templates/$&#123;name&#125;`);</span><br></pre></td></tr></table></figure><h3 id="Configuration-Promise"><a href="#Configuration-Promise" class="headerlink" title="Configuration Promise"></a>Configuration Promise</h3><p>webpack 现在支持从配置文件中返回一个 <code>Promise</code> 了。这意味着我们可以在配置文件中做一些异步的处理。</p><p><strong>webapck.config.js</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fetchLangs().then(<span class="function"><span class="params">lang</span> =&gt;</span> (&#123;</span><br><span class="line">    entry: <span class="string">"..."</span>,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    plugins: [</span><br><span class="line">      <span class="keyword">new</span> DefinePlugin(&#123; <span class="attr">LANGUAGE</span>: lang &#125;)</span><br><span class="line">    ]</span><br><span class="line">  &#125;));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="高级-loader-匹配"><a href="#高级-loader-匹配" class="headerlink" title="高级 loader 匹配"></a>高级 loader 匹配</h3><p>webpack 现在支持更多的方式来让 loader 去匹配文件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      resource: <span class="regexp">/filename/</span>, <span class="comment">// matches "/path/filename.js"</span></span><br><span class="line">      resourceQuery: <span class="regexp">/querystring/</span>, <span class="comment">// matches "/filename.js?querystring"</span></span><br><span class="line">      issuer: <span class="regexp">/filename/</span>, <span class="comment">// matches "/path/something.js" if requested from "/path/filename.js"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="更多的命令行选项"><a href="#更多的命令行选项" class="headerlink" title="更多的命令行选项"></a>更多的命令行选项</h3><p>添加了一些新的命令行选项：<br><code>--define process.env.NODE_ENV=&quot;production&quot;</code> ,查看 <code>DefinePlugin</code>.</p><p><code>--display-depth</code> 展示每个模块和入口的距离</p><p><code>--display-used-exports</code> 展示模块使用了那个模块的暴露的信息</p><p><code>--display-max-modules</code> 设置输出中展示的最大模块数量</p><p><code>-p</code> 同样设置了 <code>process.env.NODE_ENV</code> 为 “production”</p><h3 id="Loader-修改"><a href="#Loader-修改" class="headerlink" title="Loader 修改"></a>Loader 修改</h3><p>只和 loader 的作者有关。</p><h3 id="可缓存（Cacheable）"><a href="#可缓存（Cacheable）" class="headerlink" title="可缓存（Cacheable）"></a>可缓存（Cacheable）</h3><p>Loader 现在默认是可以缓存的。Loader 必须选择 return 如果它们是不可缓存的话。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  // Cacheable loader</span><br><span class="line">  module.exports = function(source) &#123;</span><br><span class="line">-   this.cacheable();</span><br><span class="line">    return source;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  // Not cacheable loader</span><br><span class="line">  module.exports = function(source) &#123;</span><br><span class="line">+   this.cacheable(false);</span><br><span class="line">    return source;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="复杂的选项"><a href="#复杂的选项" class="headerlink" title="复杂的选项"></a>复杂的选项</h3><p>webpack1 只支持可以 <code>JSON.stringify</code>选线的 loader. webpack2 支持所有的 plugins 接收一个 JS 对象作为参数。</p><p>使用复杂的选项会带来一个限制。需要给设置对象一个 <code>ident</code> 使他可以被其它 loaders 引用。</p><p>拥有一个 <code>ident</code> 在选项对象上，意味着他可以被其它 inline loader 引用。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">require(&apos;some-loader??by-iden!resource&apos;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: /.../,</span><br><span class="line">  loader: &quot;...&quot;,</span><br><span class="line">  options: &#123;</span><br><span class="line">    ident: &quot;by-ident&quot;,</span><br><span class="line">    magic: () =&gt; return Math.random()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种 inline 写法不应该经常使用，但是它可以被 laoder 生成的代码使用。例子：style-loader 生成一个模块，<code>require</code> 了剩下的请求（比如用来暴露 CSS）。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// style-loader generated code (simplified)</span><br><span class="line">var addStyle = require(&quot;./add-style&quot;);</span><br><span class="line">var css = require(&quot;-!css-loader?&#123;&quot;modules&quot;:true&#125;!postcss-loader??postcss-ident&quot;);</span><br><span class="line"></span><br><span class="line">addStyle(css);</span><br></pre></td></tr></table></figure><p>所以如果你要使用复杂的选项，那么告诉你的用户有关 <code>ident</code> 的事情。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;resolve-root-resolve-fallback-resolve-modulesDirectories&quot;&gt;&lt;a href=&quot;#resolve-root-resolve-fallback-resolve-modulesDirectories&quot; class=&quot;headerlink&quot; title=&quot;resolve.root,resolve.fallback,resolve.modulesDirectories&quot;&gt;&lt;/a&gt;&lt;code&gt;resolve.root&lt;/code&gt;,&lt;code&gt;resolve.fallback&lt;/code&gt;,&lt;code&gt;resolve.modulesDirectories&lt;/code&gt;&lt;/h2&gt;&lt;p&gt;这些配置项项都被一个单独的配置所替代 &lt;code&gt;resolve.modules&lt;/code&gt;. 查看 &lt;a href=&quot;https://webpack.js.org/configuration/resolve&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;resolving&lt;/a&gt; 了解更多。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;resolve: &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-   root: path.join(__dirname, &lt;span class=&quot;string&quot;&gt;&quot;src&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+   modules: [&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+     path.join(__dirname, &lt;span class=&quot;string&quot;&gt;&quot;src&quot;&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+     &lt;span class=&quot;string&quot;&gt;&quot;node_modules&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+   ]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;resolve-extensions&quot;&gt;&lt;a href=&quot;#resolve-extensions&quot; class=&quot;headerlink&quot; title=&quot;resolve.extensions&quot;&gt;&lt;/a&gt;&lt;code&gt;resolve.extensions&lt;/code&gt;&lt;/h2&gt;&lt;p&gt;这个选项已经不在需要传一个空字符串了。它的行为已经被移动到了 &lt;code&gt;resolve.enforceExtension&lt;/code&gt;. 查看 &lt;a href=&quot;https://webpack.js.org/configuration/resolve&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;resolving&lt;/a&gt; 了解更多。&lt;/p&gt;
&lt;h2 id=&quot;resolve&quot;&gt;&lt;a href=&quot;#resolve&quot; class=&quot;headerlink&quot; title=&quot;resolve.*&quot;&gt;&lt;/a&gt;&lt;code&gt;resolve.*&lt;/code&gt;&lt;/h2&gt;&lt;p&gt;这里修改了很多内容。因为被用到的不是很多，所以就不一一列举出来了。查看 &lt;a href=&quot;https://webpack.js.org/configuration/resolve&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;resolving&lt;/a&gt; 了解更多。&lt;/p&gt;
&lt;h2 id=&quot;module-loaders-现在是-module-rules&quot;&gt;&lt;a href=&quot;#module-loaders-现在是-module-rules&quot; class=&quot;headerlink&quot; title=&quot;module.loaders 现在是 module.rules&quot;&gt;&lt;/a&gt;&lt;code&gt;module.loaders&lt;/code&gt; 现在是 &lt;code&gt;module.rules&lt;/code&gt;&lt;/h2&gt;&lt;p&gt;老的 loader 配置被一个更加强大的 rules 系统所取代了，允许配置 loader 和更多内容。为了保证一致性，旧的 &lt;code&gt;module.loaders&lt;/code&gt; 语法依然可以合法且可以使用的。新的命名规范更加易于理解，这是一个使用 &lt;code&gt;module.rules&lt;/code&gt; 去升级配置的很好的理由。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;module&lt;/span&gt;: &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-   loaders: [&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+   rules: [&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        test: &lt;span class=&quot;regexp&quot;&gt;/\.css$/&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-       loaders: [&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+       use: [&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            loader: &lt;span class=&quot;string&quot;&gt;&quot;style-loader&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            loader: &lt;span class=&quot;string&quot;&gt;&quot;css-loader&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-           query: &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+           options: &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              modules: &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        test: &lt;span class=&quot;regexp&quot;&gt;/\.jsx$/&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        loader: &lt;span class=&quot;string&quot;&gt;&quot;babel-loader&quot;&lt;/span&gt;, &lt;span class=&quot;comment&quot;&gt;// Do not use &quot;use&quot; here&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        options: &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="技术" scheme="https://blog.kisnows.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="webpack" scheme="https://blog.kisnows.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>【翻译向】webpack2 指南（下）</title>
    <link href="https://blog.kisnows.com/2017/01/18/webpack2-guide-3/"/>
    <id>https://blog.kisnows.com/2017/01/18/webpack2-guide-3/</id>
    <published>2017-01-18T09:14:35.000Z</published>
    <updated>2017-02-15T13:17:36.645Z</updated>
    
    <content type="html"><![CDATA[<h1 id="缓存（Caching）"><a href="#缓存（Caching）" class="headerlink" title="缓存（Caching）"></a>缓存（Caching）</h1><p>为了能够使 webpack 处理后的静态资源能够长期缓存下来，需要：</p><ol><li>使用 <code>[chunkhash]</code> 给每一个文件创建基于内容变化的缓存标识</li><li>在 HTML 文件中引入文件时使用编译状态来拿到文件名称</li><li>在载入资源之前生成 chunk-manifest JSON 文件并写入到 HTML 页面中</li><li>确保包含启动代码的入口代码块的 hash 值不会被修改，当它的依赖没有变化的时候</li></ol><h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><p>每当我们代码中有一些东西需要被更新的时候，它需要在服务上部署然后由客户端重新下载这些文件。当网络状状况不太好的时候，这是意见非常低效的事情。这也是为什么浏览器要缓存静态资源的原因。</p><p>这会导致一个陷阱：当我们发布一个新的版本的时候不去更新的文件名，这会让浏览器认为文件没有变化，导致客户端拿不到最新的资源。</p><p>一个简单解决问题的方式就是告诉浏览器一个新的文件名。在没有 webpack 的时候我们会使用构建版本来标识此次的更新：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">application.js?build=1</span><br><span class="line">application.css?build=1</span><br></pre></td></tr></table></figure><p>在 webpack 中这样做也很简单：每一次 webpack 的构建都会生成一个可以用来构成文件名的独一无二的 hash 值。下面这个配置文件会生成两个带有 hash 值的文件名：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    vendor: <span class="string">'./src/vendor.js'</span>,</span><br><span class="line">    main: <span class="string">'./src/index.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.join(__dirname, <span class="string">'build'</span>),</span><br><span class="line">    filename: <span class="string">'[name].[hash].js'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><a id="more"></a><p>执行 webpack 命令会得到以下输出：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hash: 55e783391098c2496a8f</span><br><span class="line">Version: webpack 1.10.1</span><br><span class="line">Time: 58ms</span><br><span class="line">Asset Size Chunks Chunk Names</span><br><span class="line">main.55e783391098c2496a8f.js 1.43 kB 0 [emitted] main</span><br><span class="line">vendor.55e783391098c2496a8f.js 1.43 kB 1 [emitted] vendor</span><br><span class="line">[0] ./src/index.js 46 bytes &#123;0&#125; [built]</span><br><span class="line">[0] ./src/vendor.js 40 bytes &#123;1&#125; [built]</span><br></pre></td></tr></table></figure><p>但存在的问题是，每次我们重新编译，所有的文件名都会变化，这会导致客户端每次都重新把整个应用的代码重新下载一遍。那么我们如何才能时客户端每次只下载有变动的文件。</p><h2 id="给每个文件生成独特的-hash"><a href="#给每个文件生成独特的-hash" class="headerlink" title="给每个文件生成独特的 hash"></a>给每个文件生成独特的 hash</h2><p>当一个文件的内容没有变化的时候，如何保证它的文件名不会在每次编译中变化。比如，一个用来放所有的我们的所有依赖库文件的代码包。</p><p>Webpack 允许根据文件的内容生成 hash 值。这是更新后的配置：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">/*...*/</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">    filename: <span class="string">'[name].[chunkhash].js'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个配置同样会生成两个文件，但是每个文件都拥有自己的 hash 值：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">main.155567618f4367cd1cb8.js 1.43 kB 0 [emitted] main</span><br><span class="line">vendor.c2330c22cd2decb5da5a.js 1.43 kB 1 [emitted] vendor</span><br></pre></td></tr></table></figure><blockquote><p>不要在开发环境中使用 [chunkhash]，这会导致每次的编译时间边长。把开发环境和生成环境的配置文件分开，在开发环境使用 [name].js ，在生产环境中使用 [name].[chunkhash].js</p></blockquote><p>从 webpack 编译状态（compilation stats）中获取文件名<br>在开发环境中，你只需要在 HTML 中引入你的文件就可以了。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"main.js"</span>&gt;</span><span class="xml"><span class="tag">&lt;/<span class="name">srcipt</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>然而，在生产环境中，我们每次都会得到一个不同的文件名：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"main.12312123t234.js"</span>&gt;</span><span class="xml"><span class="tag">&lt;/<span class="name">srcipt</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>为了能够在 HTML 中引入正确的文件，我们需要了解一些构建的信息。这可以通过下面这个插件来从 webpack 编译状态（compliation stats） 中提取出来。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">/*...*/</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.plugin(<span class="string">"done"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">stats</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(<span class="string">"fs"</span>).writeFileSync(</span><br><span class="line">          path.join(__dirname, <span class="string">"…"</span>, <span class="string">"stats.json"</span>),</span><br><span class="line">          <span class="built_in">JSON</span>.stringify(stats.toJson()));</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>或者，通过下面这些插件来暴露 JSON 文件：</p><ul><li><a href="https://www.npmjs.com/package/webpack-manifest-plugin" target="_blank" rel="noopener">https://www.npmjs.com/package/webpack-manifest-plugin</a></li><li><a href="https://www.npmjs.com/package/assets-webpack-plugin" target="_blank" rel="noopener">https://www.npmjs.com/package/assets-webpack-plugin</a></li></ul><p>一个简单的通过 webpack-manifest-plugin 输出的文件如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"main.js"</span>: <span class="string">"main.155567618f4367cd1cb8.js"</span>,</span><br><span class="line">  <span class="string">"vendor.js"</span>: <span class="string">"vendor.c2330c22cd2decb5da5a.js"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来的事情就由你的服务来决定了。这有一个很不错的例子  <a href="walk through for Rails-based projects">walk through for Rails-based projects</a>. 使用 Node.js 的服务端渲染的话可以使用 <a href="https://github.com/halt-hammerzeit/webpack-isomorphic-tools" target="_blank" rel="noopener">webpack-isomorphic-tools</a>. 如果你的应用不需要依赖服务端渲染的话，那完全可以直接生成一个 <code>index.html</code>. 可以使用下面这两个插件来完成：</p><ul><li><a href="https://github.com/ampedandwired/html-webpack-plugin" target="_blank" rel="noopener">https://github.com/ampedandwired/html-webpack-plugin</a></li><li><a href="https://github.com/szrenwei/inline-manifest-webpack-plugin" target="_blank" rel="noopener">https://github.com/szrenwei/inline-manifest-webpack-plugin</a></li></ul><h2 id="确定的-hashes-Deterministic-hashes"><a href="#确定的-hashes-Deterministic-hashes" class="headerlink" title="确定的 hashes (Deterministic hashes)"></a>确定的 hashes (Deterministic hashes)</h2><p>为了压缩生成文件的大小，webpack 使用 id 代替名字来识别模块。再编译过程中，id 已经被生成，映射到代码块的名字并且放到一个 JavaScript 对象中，被叫做代码块清单（ chunk manifest）。它会被放到入口文件中，确保打包后的文件能够正常工作。</p><p>这会有和之前一样的问题：无论修改任何地方的文件，即使其它地方都没有修改，更新后的入口需要包含清单文件。这会生成一个新的 hash 值，导致问们的入口文件名修改，无法享受长期缓存带来的好处。</p><p>为了解决这个问题，我们应该使用 <a href="https://github.com/diurnalist/chunk-manifest-webpack-plugin" target="_blank" rel="noopener">https://github.com/diurnalist/chunk-manifest-webpack-plugin</a> ，一个可以把清单文件提取出来单独放到一个 JSON 文件中。这是更新后的配置文件，会生成 chunk-manifest.json 并放到我们打包后的文件夹下面：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">var</span> ChunkManifestPlugin = <span class="built_in">require</span>(<span class="string">'chunk-manifest-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// your config values here</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> ChunkManifestPlugin(&#123;</span><br><span class="line">      filename: <span class="string">"chunk-manifest.json"</span>,</span><br><span class="line">      manifestVariable: <span class="string">"webpackManifest"</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当我们从入口文件中移除掉清单文件后，那么我们就需要手动把这个文件提供给 webapck 使用。在上面的例子中你可能注意到 <code>manifestVariable</code> 这个选项。这是一个全局变量，一个供 webpack 来查找清单 JSON 文件，这也是为什么我们需要在代码包前面引入到 HTML 中。在 HTML 中写入 JSON 文件的内容是很容易，那么我们的 HTML 文件的 head 部分就会向下面这样：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">      <span class="comment">//&lt;![CDATA[</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">window</span>.webpackManifest = &#123;<span class="string">"0"</span>:<span class="string">"main.3d038f325b02fdee5724.js"</span>,<span class="string">"1"</span>:<span class="string">"1.c4116058de00860e5aa8.js"</span>&#125;</span></span><br><span class="line"><span class="javascript">      <span class="comment">//]]&gt;</span></span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最终的 webpack.config.js 文件如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="keyword">var</span> ManifestPlugin = <span class="built_in">require</span>(<span class="string">'webpack-manifest-plugin'</span>);</span><br><span class="line"><span class="keyword">var</span> ChunkManifestPlugin = <span class="built_in">require</span>(<span class="string">'chunk-manifest-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">var</span> WebpackMd5Hash = <span class="built_in">require</span>(<span class="string">'webpack-md5-hash'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    vendor: <span class="string">'./src/vendor.js'</span>,</span><br><span class="line">    main: <span class="string">'./src/index.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.join(__dirname, <span class="string">'build'</span>),</span><br><span class="line">    filename: <span class="string">'[name].[chunkhash].js'</span>,</span><br><span class="line">    chunkFilename: <span class="string">'[name].[chunkhash].js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">      name: <span class="string">"vendor"</span>,</span><br><span class="line">      minChunks: <span class="literal">Infinity</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> WebpackMd5Hash(),</span><br><span class="line">    <span class="keyword">new</span> ManifestPlugin(),</span><br><span class="line">    <span class="keyword">new</span> ChunkManifestPlugin(&#123;</span><br><span class="line">      filename: <span class="string">"chunk-manifest.json"</span>,</span><br><span class="line">      manifestVariable: <span class="string">"webpackManifest"</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>如果使用 <a href="https://github.com/ampedandwired/html-webpack-plugin" target="_blank" rel="noopener">webpack-html-plugin</a> ,那么你可以使用 <a href="https://github.com/szrenwei/inline-manifest-webpack-plugin" target="_blank" rel="noopener"> inline-manifest-webpack-plugin </a> 来做这件事。</p></blockquote><p>使用这个配置，那么第三方代码块（vendors chunkd）将不会变化，除非你修改它的代码或者依赖。</p><h1 id="垫片（Shimming）"><a href="#垫片（Shimming）" class="headerlink" title="垫片（Shimming）"></a>垫片（Shimming）</h1><p>webpack 作为了个模块打包工具，可以支持的模块系统包括 ES2015 modules, CommonJs 和 AMD. 但是很多情况下，当我们使用第三方库的时候，我们看到他们会依赖一个全局变量比如 <code>$</code> 或者说 <code>jquery</code>. 它们也可能创建一些需要暴露出来的新的全局变量。我们来看几种不同的方式来使 webpack 能够理解这些非模块（broken modules）的文件。</p><p>最好使用在 <code>dist</code> 文件下没有打包压缩过的 CommonJs/AMD 文件（Prefer unminified CommonJS/AMD files over bundled dist versions.）<br>大多数模块会在 <code>package.json</code> 的 <code>main</code> 字段中指定它们的 <code>dist</code> 版本。这对大多数开发者来说都是非常有用的，对 webpack 来说最好设置一个别名到它们的 <code>src</code> 目录下面，这样能够使 webpack 更好的优化依赖。但是，在很多情况下使用 <code>dist</code> 版本也不会有什么大的问题。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  resolve: &#123;</span><br><span class="line">  alias: &#123;</span><br><span class="line">    jquery: <span class="string">"jquery/src/jquery"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="provide-plugin"><a href="#provide-plugin" class="headerlink" title="provide-plugin"></a><code>provide-plugin</code></h2><p>通过使用 <code>[provide-plugin](https://webpack.js.org/plugins/provide-plugin)</code> 使这个模块在所有通过 <code>webpack</code> 引用的模块中作为一个可用的变量。只有当你使用了这个变量后，对应的模块才会被引用进来。很多古老的模块通过使用特定的全局变量，比如 jQuery 的 <code>$</code> 和或者 <code>jQuery</code>.  在这个场景下，你可以提前在 webpack 中配置为 <code>var $=requrei(&#39;jquery&#39;)</code> ，在每一次遇到全局 <code>$</code> 标识符。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.ProvidePlugin(&#123;</span><br><span class="line">      $: <span class="string">'jquery'</span>,</span><br><span class="line">      jQuery: <span class="string">'jquery'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="imports-loader"><a href="#imports-loader" class="headerlink" title="imports-loader"></a><code>imports-loader</code></h2><p><code>[imports-loader](https://webpack.js.org/loaders/imports-loader/)</code> 将必须要的全局变量插入到传统模块中。比如，一些传统模块依赖 <code>this</code> 指向 <code>window</code> 对象。这会导致一个问题，当模块被执行在 CommonJS 上下文的时候， <code>this</code> 指向为 <code>module.exports</code>.在这种情况下，你可以通过 <code>imports-loader</code>重写 <code>this</code>.</p><p><strong>webpack.config.js</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">      test: <span class="built_in">require</span>.resolve(<span class="string">"some-module"</span>),</span><br><span class="line">      use: <span class="string">'imports-loader?this=&gt;window'</span></span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>它支持不同的模块类型，比如 AMD，CommonJS 同时也支持传统模块。可是，通常情况下它会去检查 <code>define</code> 变量，然后使用一些奇怪（quirky）的代码去暴露这些属性。在这种情况下，通过设置 <code>define = false</code> 来强制CommonJS 路径可能会有一些帮助。</p><p><strong>webpack.config.js</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">      test: <span class="built_in">require</span>.resolve(<span class="string">"some-module"</span>),</span><br><span class="line">      use: <span class="string">'imports-loader?define=&gt;false'</span></span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="exports-loader"><a href="#exports-loader" class="headerlink" title="exports-loader"></a><code>exports-loader</code></h2><p>假设一个库文件创建了一个全局变量，期待它的消费者去使用。在这种情况下，我们应该使用 <code>[exports-loader](https://webpack.js.org/loaders/exports-loader/)</code>, 来暴露一个 CommonJS 风格的全局变量。比如，为了暴露 <code>file</code> 为 <code>file</code>，<code>helpers.parse</code> 为 <code>parse</code>:</p><p><strong>webpack.config.js</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">      test: <span class="built_in">require</span>.resolve(<span class="string">"some-module"</span>),</span><br><span class="line">      use: <span class="string">'exports-loader?file,parse=helpers.parse'</span></span><br><span class="line">      <span class="comment">// adds below code the the file's source:</span></span><br><span class="line">      <span class="comment">//  exports["file"] = file;</span></span><br><span class="line">      <span class="comment">//  exports["parse"] = helpers.parse;</span></span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="script-loader"><a href="#script-loader" class="headerlink" title="script-loader"></a><code>script-loader</code></h2><p><code>[script-loader](https://webpack.js.org/loaders/script-loader/)</code> 会在全局上下文里面解析代码，就和你在 HTML 中添加了一个 <code>script</code> 标签一样。在这种情况下，理论上所有的模块都应该正常的运行。</p><blockquote><p>这个文件会被作为字符串打包在代码中。不会被 <code>webpack</code> 压缩，所以请使用压缩后的版本。同样这种情况无法使用 webpack 提供的开发工具。</p></blockquote><p>假设你有一个 <code>legacy.js</code> 文件包含：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">GLOBAL_CONFIG = &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="使用-script-loader"><a href="#使用-script-loader" class="headerlink" title="使用 script-loader"></a>使用 <code>script-loader</code></h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">'script-loader!legacy.js'</span>)</span><br></pre></td></tr></table></figure><p>一般会得到这样的结果：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">'GLOBAL_CONFIG = &#123;&#125;'</span>)</span><br></pre></td></tr></table></figure><h2 id="noParse-选项"><a href="#noParse-选项" class="headerlink" title="noParse 选项"></a><code>noParse</code> 选项</h2><p>当没有 AMD/CommonJS 风格的模块，同时你需要在 <code>dist</code> 中引入，你可以把这个模块标识为 <code>[noParse](https://webpack.js.org/configuration/module/#module-noparse)</code>. 这样 <code>webpack</code> 就只会引入这个模块但是不会去做任何处理，这样也可以减少构建的时间。</p><blockquote><p>任何需要 AST 支持的，比如 <code>ProvidePlugin</code>, 都是不会工作的。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    noParse: <span class="regexp">/jquery|backbone/</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="编写一个库文件"><a href="#编写一个库文件" class="headerlink" title="编写一个库文件"></a>编写一个库文件</h1><p>webpack 是一个工具，可以用来打包应用代码，同样也可以用来打包库代码。如果你是一个 JavaScript 库的作者，正在寻找精简打包代码的流程，那么这个章节的内容会对你很有帮助。</p><h2 id="编写一个库（Author-a-Library）"><a href="#编写一个库（Author-a-Library）" class="headerlink" title="编写一个库（Author a Library）"></a>编写一个库（Author a Library）</h2><p>我们这有一个精简的包装库来把数字 1 到 5 转换到对应的单词，反之亦然。 看起来可能是这样的：</p><p><strong>src/index.js</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">'lodash'</span>;</span><br><span class="line"><span class="keyword">import</span> numRef <span class="keyword">from</span> <span class="string">'./ref.json'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">numToWord</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> _.reduce(numRef, (accum, ref) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> ref.num === num ? ref.word : accum;</span><br><span class="line">  &#125;, <span class="string">''</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">wordToNum</span>(<span class="params">word</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> _.reduce(numRef, (accum, ref) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> ref.word === word &amp;&amp; word.toLowerCase() ? ref.num : accum;</span><br><span class="line">  &#125;, <span class="number">-1</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>库的使用规范如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ES2015modules</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>*aswebpackNumbersfrom<span class="string">'webpack-numbers'</span>;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">webpackNumbers.wordToNum(<span class="string">'Two'</span>)<span class="comment">//outputis2</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">//CommonJSmodules</span></span><br><span class="line"></span><br><span class="line">varwebpackNumbers=<span class="built_in">require</span>(<span class="string">'webpack-numbers'</span>);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">webpackNumbers.numToWord(<span class="number">3</span>);<span class="comment">//outputisThree</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">//Asascripttag</span></span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">...</span><br><span class="line">&lt;scriptsrc=<span class="string">"https://unpkg.com/webpack-numbers"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;script&gt;</span><br><span class="line">...</span><br><span class="line"><span class="comment">/*webpackNumbersisavailableasaglobalvariable*/</span></span><br><span class="line">webpackNumbers.wordToNum(<span class="string">'Five'</span>)<span class="comment">//outputis5</span></span><br><span class="line">...</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>html&gt;</span><br></pre></td></tr></table></figure><p>完整的库配置和代码放在这里 <a href="https://github.com/kalcifer/webpack-library-example" target="_blank" rel="noopener"> webpack-library-example</a>.</p><h2 id="配置-webpack"><a href="#配置-webpack" class="headerlink" title="配置 webpack"></a>配置 webpack</h2><p>那么接下来的事情就是打包这个库<br>    • 不打包 lodash，但是会被它的消费者引入<br>    • 命名这个库为 <code>webpack-numbers</code>, 并且变量为 <code>webpackNumbers</code><br>    • 库可以通过 <code>import webapckNumbers from &#39;webpack-numbers&#39;</code> 或者 <code>require(&#39;webpack-numbers&#39;)</code> 来引入<br>    • 当通过 <code>script</code> 标签引入的时候，可以通过全局变量 <code>webpackNumbers</code> 来访问<br>    • 可以在 Node.js 中使用</p><h3 id="添加-webpack"><a href="#添加-webpack" class="headerlink" title="添加 webpack"></a>添加 webpack</h3><p>添加基础 webpack 配置。</p><p><strong>webpack.config.js</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: <span class="string">'./dist'</span>,</span><br><span class="line">    filename: <span class="string">'webpack-numbers.js'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这将添加一个基础配置来打包这个库。</p><h3 id="添加-Loaders"><a href="#添加-Loaders" class="headerlink" title="添加 Loaders"></a>添加 Loaders</h3><p>但是如果没有对应 loaders 去解析代码是没有办法工作的。这里，我们添加 <code>json-loader</code> 来添加对 json 文件的解析。</p><p><strong>webpack.config.js</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  // ...</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">      test: /.json$/,</span><br><span class="line">      use: &apos;json-loader&apos;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="添加-externals"><a href="#添加-externals" class="headerlink" title="添加 externals"></a>添加 <code>externals</code></h3><p>现在，如果执行 <code>webpack</code> 命令，你会发现一个提交较大的代码包被生成。如果你去检查代码，会发现 ladash 被打包到了代码包中。对于你的库来说把 <code>lodash</code> 打包在一起使完全没有必要的。</p><p>可以通过 <code>externals</code> 配置：</p><p><strong>webpack.config.js</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">    externals: &#123;</span><br><span class="line">  <span class="string">"lodash"</span>: &#123;</span><br><span class="line">    commonjs: <span class="string">"lodash"</span>,</span><br><span class="line">      commonjs2: <span class="string">"lodash"</span>,</span><br><span class="line">      amd: <span class="string">"lodash"</span>,</span><br><span class="line">      root: <span class="string">"_"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这意味着在使用者的环境下你的库会期望依赖 <code>lodash</code> 。</p><h3 id="添加-libraryTarget"><a href="#添加-libraryTarget" class="headerlink" title="添加 libraryTarget"></a>添加 <code>libraryTarget</code></h3><p>为了这个库能够被广泛的使用，我们需要让它在不同的环境下有相同的表现。比如， CommonJS，AMD，Node.js 或者作为一个全局变量。</p><p>为了达到这个目的，需要在 webpack 配置中添加 <code>library</code>  属性。</p><p><strong>webpack.config.js</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">    output: &#123;</span><br><span class="line">...</span><br><span class="line">  library: <span class="string">'webpackNumbers'</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这能够你的库被引入的时候可以作为一个全局变量被访问。为了能够在其它情况下使用，在配置中继续添加 <code>libraryTarget</code> 的值：</p><p><strong>webpack.config.js</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">    output: &#123;</span><br><span class="line">...</span><br><span class="line">  library: <span class="string">'webpackNumbers'</span>,</span><br><span class="line">    libraryTarget:<span class="string">'umd'</span> <span class="comment">// Possible value - amd, commonjs, commonjs2, commonjs-module, this, var</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果 <code>library</code> 设置了，但是 <code>libraryTarget</code>没有配置，那么 <code>libraryTarget</code> 默认为 <code>var</code> 就像在<a href="https://webpack.js.org/configuration/output" target="_blank" rel="noopener"> config reference</a> 中指定的一样。</p><h3 id="最后一步"><a href="#最后一步" class="headerlink" title="最后一步"></a>最后一步</h3><p><a href="https://webpack.js.org/guides/production-build" target="_blank" rel="noopener">调整生产环境下的配置文件</a></p><p>将打包后的文件添加到  <code>package.json</code> 中指定的字段里面。</p><p><strong>package.json</strong></p><figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    "main": "dist/webpack-numbers.js",</span><br><span class="line">    "module": "src/index.js", // To add as standard module as per https://github.com/dherman/defense-of-dot-js/blob/master/proposal.md#typical-usage</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在你可以把它作为一个 npm 模块发布了，并且在 unpkg.com 里面向你的用户传播了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;缓存（Caching）&quot;&gt;&lt;a href=&quot;#缓存（Caching）&quot; class=&quot;headerlink&quot; title=&quot;缓存（Caching）&quot;&gt;&lt;/a&gt;缓存（Caching）&lt;/h1&gt;&lt;p&gt;为了能够使 webpack 处理后的静态资源能够长期缓存下来，需要：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用 &lt;code&gt;[chunkhash]&lt;/code&gt; 给每一个文件创建基于内容变化的缓存标识&lt;/li&gt;
&lt;li&gt;在 HTML 文件中引入文件时使用编译状态来拿到文件名称&lt;/li&gt;
&lt;li&gt;在载入资源之前生成 chunk-manifest JSON 文件并写入到 HTML 页面中&lt;/li&gt;
&lt;li&gt;确保包含启动代码的入口代码块的 hash 值不会被修改，当它的依赖没有变化的时候&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;存在的问题&quot;&gt;&lt;a href=&quot;#存在的问题&quot; class=&quot;headerlink&quot; title=&quot;存在的问题&quot;&gt;&lt;/a&gt;存在的问题&lt;/h2&gt;&lt;p&gt;每当我们代码中有一些东西需要被更新的时候，它需要在服务上部署然后由客户端重新下载这些文件。当网络状状况不太好的时候，这是意见非常低效的事情。这也是为什么浏览器要缓存静态资源的原因。&lt;/p&gt;
&lt;p&gt;这会导致一个陷阱：当我们发布一个新的版本的时候不去更新的文件名，这会让浏览器认为文件没有变化，导致客户端拿不到最新的资源。&lt;/p&gt;
&lt;p&gt;一个简单解决问题的方式就是告诉浏览器一个新的文件名。在没有 webpack 的时候我们会使用构建版本来标识此次的更新：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;application.js?build=1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;application.css?build=1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在 webpack 中这样做也很简单：每一次 webpack 的构建都会生成一个可以用来构成文件名的独一无二的 hash 值。下面这个配置文件会生成两个带有 hash 值的文件名：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// webpack.config.js&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; path = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;path&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;module&lt;/span&gt;.exports = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  entry: &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    vendor: &lt;span class=&quot;string&quot;&gt;&#39;./src/vendor.js&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    main: &lt;span class=&quot;string&quot;&gt;&#39;./src/index.js&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  output: &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    path: path.join(__dirname, &lt;span class=&quot;string&quot;&gt;&#39;build&#39;&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    filename: &lt;span class=&quot;string&quot;&gt;&#39;[name].[hash].js&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="技术" scheme="https://blog.kisnows.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="webpack" scheme="https://blog.kisnows.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>【翻译向】webpack2 指南（中）</title>
    <link href="https://blog.kisnows.com/2017/01/18/webpack2-guide-2/"/>
    <id>https://blog.kisnows.com/2017/01/18/webpack2-guide-2/</id>
    <published>2017-01-18T03:49:14.000Z</published>
    <updated>2017-02-15T13:17:36.690Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动态模块替换（Hot-Module-Repalcement-React）"><a href="#动态模块替换（Hot-Module-Repalcement-React）" class="headerlink" title="动态模块替换（Hot Module Repalcement -React）"></a>动态模块替换（Hot Module Repalcement -React）</h1><p>就像之前 <a href="https://webpack.js.org/concepts/hot-module-repalcement" target="_blank" rel="noopener">理念页面</a> 中解析的细节那样，动态模块替换（HMR）会在应用运行时动态的替换、添加或者删除模块而不用重新刷新页面。 HMR 非常有用，当应用只有一个状态树（single state tree）时。</p><p>下面介绍的方法描述中使用了 Babel 和 React ,但这并不是使用 HRM 所必须的工具。</p><h2 id="项目配置"><a href="#项目配置" class="headerlink" title="项目配置"></a>项目配置</h2><p>这里会指导你如何用 Babel， React 和 PostCss 一起使用 HMR 去演示一个项目。为了能够跟着下面走下去，需要把这些依赖添加到 <code>package.json</code> 中去。</p><p>为了使用 HMR，你需要如下这些依赖：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save-dev babel@6.5.2 babel-core@6.13.2 babel-loader@6.2.4 babel-preset-es2015@6.13.2 babel-preset-react@6.11.1 babel-preset-stage-2@6.13.0 css-loader@0.23.1 postcss-loader@0.9.1 react-hot-loader@3.0.0-beta.6 style-loader@0.13.1 webpack@2.1.0-beta.25 webpack-dev-server@2.1.0-beta.0</span><br></pre></td></tr></table></figure><p>同时，为了达到我们演示的目的，还需要：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save react@15.3.0 react-dom@15.3.0</span><br></pre></td></tr></table></figure><h3 id="Babel-Config"><a href="#Babel-Config" class="headerlink" title="Babel Config"></a>Babel Config</h3><p><code>.babelrc</code> 文件应该如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [</span><br><span class="line">    [<span class="string">"es2015"</span>, &#123;<span class="attr">"modules"</span>: <span class="literal">false</span>&#125;],</span><br><span class="line">    // webpack understands the native import syntax, and uses it for tree shaking</span><br><span class="line"></span><br><span class="line">    <span class="string">"stage-2"</span>,</span><br><span class="line">    // Specifies what level of language features to activate.</span><br><span class="line">    // Stage <span class="number">2</span> is <span class="string">"draft"</span>, <span class="number">4</span> is finished, <span class="number">0</span> is strawman.</span><br><span class="line">    // See https://tc39.github.io/process-document/</span><br><span class="line"></span><br><span class="line">    <span class="string">"react"</span></span><br><span class="line">    // Transpile React components to JavaScript</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"plugins"</span>: [</span><br><span class="line">    <span class="string">"react-hot-loader/babel"</span></span><br><span class="line">    // Enables React code to work with HMR.</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Webpack-Config"><a href="#Webpack-Config" class="headerlink" title="Webpack Config"></a>Webpack Config</h3><a id="more"></a><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; resolve &#125; = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: [</span><br><span class="line">    <span class="string">'react-hot-loader/patch'</span>,</span><br><span class="line">    <span class="comment">// activate HMR for React</span></span><br><span class="line"></span><br><span class="line">    <span class="string">'webpack-dev-server/client?http://localhost:8080'</span>,</span><br><span class="line">    <span class="comment">// bundle the client for webpack-dev-server</span></span><br><span class="line">    <span class="comment">// and connect to the provided endpoint</span></span><br><span class="line"></span><br><span class="line">    <span class="string">'webpack/hot/only-dev-server'</span>,</span><br><span class="line">    <span class="comment">// bundle the client for hot reloading</span></span><br><span class="line">    <span class="comment">// only- means to only hot reload for successful updates</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="string">'./index.js'</span></span><br><span class="line">    <span class="comment">// the entry point of our app</span></span><br><span class="line">  ],</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">    <span class="comment">// the output bundle</span></span><br><span class="line"></span><br><span class="line">    path: resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line"></span><br><span class="line">    publicPath: <span class="string">'/'</span></span><br><span class="line">    <span class="comment">// necessary for HMR to know where to load the hot update chunks</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  context: resolve(__dirname, <span class="string">'src'</span>),</span><br><span class="line"></span><br><span class="line">  devtool: <span class="string">'inline-source-map'</span>,</span><br><span class="line"></span><br><span class="line">  devServer: &#123;</span><br><span class="line">    hot: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// enable HMR on the server</span></span><br><span class="line"></span><br><span class="line">    contentBase: resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    <span class="comment">// match the output path</span></span><br><span class="line"></span><br><span class="line">    publicPath: <span class="string">'/'</span></span><br><span class="line">    <span class="comment">// match the output `publicPath`</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          <span class="string">'babel-loader'</span>,</span><br><span class="line">        ],</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          <span class="string">'style-loader'</span>,</span><br><span class="line">          <span class="string">'css-loader?modules'</span>,</span><br><span class="line">          <span class="string">'postcss-loader'</span>,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.HotModuleReplacementPlugin(),</span><br><span class="line">    <span class="comment">// enable HMR globally</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> webpack.NamedModulesPlugin(),</span><br><span class="line">    <span class="comment">// prints more readable module names in the browser console on HMR updates</span></span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面有很多配置，但不是所有都和 HMR 有关。可以通过查阅 webpack-dev-server options 和concept pages 来加深理解。</p><p>我们基础设想是这样的，你的 JavaScript 入口文件在 <code>./src/index.js</code> 且你使用 CSS Module 来编写样式文件。</p><p>配置文件中需要重点关注的是 <code>devServer</code> 和 <code>entry</code> key. <code>HotModueReplacementPlugin</code> 同样需要被包含在 <code>plugins</code> key 中。</p><p>为了达到目的，我们引入了两个模块：</p><ul><li><code>react-hot-loader</code> 添加到了入口中， 是为了能够使 React 支持 HMR</li><li>为了更好的理解 HMR 每次更新的时候做了哪些事情，我们添加了 <code>NamedModulePlugin</code></li></ul><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ./src/index.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; AppContainer &#125; <span class="keyword">from</span> <span class="string">'react-hot-loader'</span>;</span><br><span class="line"><span class="comment">// AppContainer is a necessary wrapper component for HMR</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./components/App'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> render = <span class="function">(<span class="params">Component</span>) =&gt;</span> &#123;</span><br><span class="line">  ReactDOM.render(</span><br><span class="line">  &lt;AppContainer&gt;</span><br><span class="line">  &lt;Component/&gt;</span><br><span class="line">  &lt;<span class="regexp">/AppContainer&gt;,</span></span><br><span class="line"><span class="regexp">    document.getElementById('root')</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">render(App);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ Hot Module Replacement API</span></span><br><span class="line"><span class="regexp">if (module.hot) &#123;</span></span><br><span class="line"><span class="regexp">  module.hot.accept('./</span>components/App<span class="string">', () =&gt; &#123;</span></span><br><span class="line"><span class="string">    const NewApp = require('</span>./components/App<span class="string">').default</span></span><br><span class="line"><span class="string">    render(NewApp)</span></span><br><span class="line"><span class="string">  &#125;);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ./src/components/App.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">'./App.css'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">  &lt;div className=&#123;styles.app&#125;&gt;</span><br><span class="line">    &lt;h2&gt;Hello, &lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.app</span> &#123;</span><br><span class="line">    <span class="attribute">text-size-adjust</span>: none;</span><br><span class="line">    <span class="attribute">font-family</span>: helvetica, arial, sans-serif;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">200%</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">6px</span> <span class="number">20px</span> <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个需要特别注意的是 <code>module</code> 的引用：</p><ol><li>Webpack 会暴露出 <code>module.hot</code> 给我们的代码，当我们设置 <code>devServer: { hot: true }</code> 时；</li><li>这样我们可以使用 <code>module.hot</code> 来给特定的资源弃用 HMR （这里是 <code>App.js</code>）. 这里有一个非常重要的 API <code>module.hot.accept</code> ,用来决定如何处理这些特定的依赖。</li><li><p>需要注意的是，webpack2 内建支持 ES2015 模块语法，你不需要在 <code>module.hot.accept</code> 中重新引用跟组件。为了达到这个目的，需要在 <code>.babelrc</code> 配置 Babel ES2015 的预先设置：</p> <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="string">"es2015"</span>, &#123;<span class="string">"modules"</span>: <span class="literal">false</span>&#125;]</span><br></pre></td></tr></table></figure><p> 就像我们在之前 Babel Config 中配置的那样。需要注意，禁用 Babel 的模块功能 不仅仅是为了启用 HMR。如果你不关掉这个配置，那么你会碰到需要问题。</p></li><li>如果你在 webpack2 的配置文件中使用 ES6 模块，并且你按照 #3 修改了 <code>.babelrc</code>，那么你需要使用 <code>require</code> 语法来创建两个 <code>.babelrc</code> 文件：<ol><li>一个放在根目录下面并配置为 <code>&quot;presets: [&quot;es2015&quot;]&quot;</code></li><li>一个放在 webpack 要编译的文件夹下，比如在这个例子中，就是 <code>src/</code><br>所以在这个案例中，<code>module.hot.accept</code> 会执行 <code>render</code> 方法无论 <code>src/compoents/App.js</code> 或者其它的依赖文件变化的时候 ——这意味着当 <code>App.css</code> 被引入到 <code>App.js</code> 中以后，即使是 <code>App.css</code> 被修改，<br><code>render</code> 方法同样会被执行。</li></ol></li></ol><h3 id="Index-html"><a href="#Index-html" class="headerlink" title="Index.html"></a>Index.html</h3><p>入口页面需要被放在页面 <code>dist</code> 下面，webpack-dev-server 的运行需要这个文件。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Example Index<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"bundle.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Package-json"><a href="#Package-json" class="headerlink" title="Package.json"></a>Package.json</h3><p>最后，我们需要启动 <code>webpack-dev-server</code> 来打包我们的代码并且看看 HMR 是如何工作的。我们可以使用如下的 <code>package.json</code> 入口：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span> : &#123;</span><br><span class="line">    <span class="attr">"start"</span> : <span class="string">"webpack-dev-server"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行 <code>npm start</code>, 打开浏览器输入 <code>http://localhost:8080</code>, 应该可以看到下面这些项展示在 console.log中：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dev-server.js:49[HMR] Waiting for update signal from WDS…</span><br><span class="line">only-dev-server.js:74[HMR] Waiting for update signal from WDS…</span><br><span class="line">client?c7c8:24 [WDS] Hot Module Replacement enabled.</span><br></pre></td></tr></table></figure><p>然后编辑并且修改 <code>App.js</code> 文件，你会在 console.log 中看到类似如下的日志：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[WDS] App updated. Recompiling…</span><br><span class="line">client?c7c8:91 [WDS] App hot update…</span><br><span class="line">dev-server.js:45 [HMR] Checking for updates on the server…</span><br><span class="line">log-apply-result.js:20 [HMR] Updated modules:</span><br><span class="line">log-apply-result.js:22 [HMR]  - ./components/App.js</span><br><span class="line">dev-server.js:27 [HMR] App is up to date.</span><br></pre></td></tr></table></figure><p>注意 HMR 指出了更新模块的路径。这是因为我们使用了 <code>NamedModulesPlugin</code>.</p><h1 id="开发环境（Development）"><a href="#开发环境（Development）" class="headerlink" title="开发环境（Development）"></a>开发环境（Development）</h1><p>这个章节介绍在开发过程中可以使用的一些工具。</p><p><strong>需要注意，不能在生产环境使用</strong></p><h2 id="Source-Map"><a href="#Source-Map" class="headerlink" title="Source Map"></a>Source Map</h2><p>当 JS 发生异常的时候，我们需要指导是哪一个文件的哪一行出错了。但是当文件都被 webpack 打包以后，找问题会变得很麻烦。<br>Source Map 就是为了解决这个问题的。它有很多不同的<a href="https://webpack.js.org/configuration/devtool" target="_blank" rel="noopener">选项</a>，每一种都有的好处和不足。在一开始，我们使用：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">devtool: <span class="string">"cheap-eval-source-map"</span></span><br></pre></td></tr></table></figure><h2 id="选择一个工具（Choosing-a-Tool）"><a href="#选择一个工具（Choosing-a-Tool）" class="headerlink" title="选择一个工具（Choosing a Tool）"></a>选择一个工具（Choosing a Tool）</h2><p>Webpack 可被用于监视模式（watch mode）。这种模式下， webpack 会监视你的文件，当它们有变动的时候就会重编译。Webpack-dev-server 提供了一个很方便使用的开发环境的服务，并且支持自动刷新功能。如果你已经有了一个开发环境的服务，并且希望能够拥有更好的适应性，那么 webpack-dev-middleware 可以被用作一个中间件来达到这个目的。</p><p>Webpack-dev-server 和 webpack-dev-middleware 实在内存中进行编译的，这意味着打包后的代码包并不会保存到本地磁盘中。这回使打包变得很快，同时不会产生很多临时文件来污染你的本地文件系统。</p><p>大多数情况下，你都会想要去使用 webpack-dev-server， 因为它使用起来很方便，而且提供了许多开箱即用的功能。</p><h3 id="Webpack-监视模式（wtach-mode）"><a href="#Webpack-监视模式（wtach-mode）" class="headerlink" title="Webpack 监视模式（wtach mode）"></a>Webpack 监视模式（wtach mode）</h3><p>Webpack 的监视模式会检测文件的变动。只要变动被检测到，它就会重新进行一次编译。我们希望它的编译过程能有一个很好的进度展示。那么就执行以下命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">webpack --progress --watch</span><br></pre></td></tr></table></figure><p>随便修改一个文件然后保存，你就会看到重新编译的过程。</p><p>监视模式没有考虑任何和服务有关的问题，所以你需要自己提供一个服务。一个简单的服务就是 <code>[server](https://github.com/tj/serve)</code>. 当安装好后（<code>npm i server -g</code>），在你打包后的文件目录下运行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server</span><br></pre></td></tr></table></figure><p>当每次重新编译后，你都需要手动的去刷新浏览器。</p><h3 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h3><p>webpack-dev-server 提供一个支持自动刷新的服务。</p><p>首先，确认你 <code>index.html</code> 页面里面已经引用了你的代码包。我们先假设 <code>output.filename</code> 设置为 <code>bundle.js</code>:</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/bundle.js"</span>&gt;</span><span class="xml"><span class="tag">&lt;/<span class="name">srcipt</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>从 npm 安装 <code>webpack-dev-server</code>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install webpack-dev-server --save-dev</span><br></pre></td></tr></table></figure><p>然后就可以执行 <code>webpack-dev-server</code> 的命令了：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">webpack-dev-server --open</span><br></pre></td></tr></table></figure><p>上面的命令会自动打开你的浏览器并指定到 <code>http://localhost:8080</code>.</p><p>修改一下你的文件并保存。你会发现代码被重新打包了，当打包完成的时候，页面会自动刷新。如果没有如愿达到效果，那么你需要调整 <code>watchOptions(https://webpack.js.org/configuration/dev-server#devserver-watchoptions-)</code>.</p><p>现在你有了一个可以自动刷新的服务，接下来我们看如何启用动态模块替换（Hot Module Replacement）。这是一个可以提供不刷新页面替换模块的接口，查看<a href="https://webpack.js.org/guides/hmr-react" target="_blank" rel="noopener">这里</a>了解更多 。</p><p>webpack-dev-server 可以做很多的事情，比如代理请求到你的后端服务。想了解更多的配置项，那就查看 <a href="https://webpack.js.org/configuration/dev-server" target="_blank" rel="noopener">devServer 的文档吧</a>。</p><h3 id="webpack-dev-middleware"><a href="#webpack-dev-middleware" class="headerlink" title="webpack-dev-middleware"></a>webpack-dev-middleware</h3><p>webpack-dev-middleware 适用于基于中间件的链接堆栈（好难翻译）。当你已经有一个 Node.js 服务或者你想要完全的控制服务的时候会很有用。</p><p>这个中间件会让文件编译在内存中进行。当一个编译在进行过程中，它会延迟一个文件请求，直到它编译完成。</p><p>首先从 npm 上安装：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install express webpack-dev-server --save-dev</span><br></pre></td></tr></table></figure><p>作为一个例子，我们可以这样使用中间件：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>);</span><br><span class="line"><span class="keyword">var</span> webpackDevMiddleware = <span class="built_in">require</span>(<span class="string">"webpack-dev-middleware"</span>);</span><br><span class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">"webpack"</span>);</span><br><span class="line"><span class="keyword">var</span> webpackConfig = <span class="built_in">require</span>(<span class="string">"./webpack.config"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"><span class="keyword">var</span> compiler = webpack(webpackConfig);</span><br><span class="line"></span><br><span class="line">app.use(webpackDevMiddleware(compiler, &#123;</span><br><span class="line">  publicPath: <span class="string">"/"</span> <span class="comment">// Same as `output.publicPath` in most cases.</span></span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Listening on port 3000!"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>根据你在 <code>output.publicPath</code> 和 <code>output.filename</code> 中的配置，你打包的代码应该可以通过 <code>http://localhost:3000/bundle.js</code> 访问。</p><p>默认情况下使用的是监视模式。它还支持懒模式（lazy mode），只有在有请求进来的时候才会重新编译。</p><p>配置如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.use(webpackDevMiddleware(compiler, &#123;</span><br><span class="line">  lazy: <span class="literal">true</span>,</span><br><span class="line">  filename: <span class="string">"bundle.js"</span> <span class="comment">// Same as `output.filename` in most cases.</span></span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><p>还有许多其它有用的选项，详细内容可以查看 <a href="https://webpack.js.org/configuration/dev-server" target="_blank" rel="noopener">文档</a>.</p><h1 id="为生产环境构建（Building-for-Production）"><a href="#为生产环境构建（Building-for-Production）" class="headerlink" title="为生产环境构建（Building for Production）"></a>为生产环境构建（Building for Production）</h1><p>本章介绍如何用 webpack 来做生产环境的构建。</p><h2 id="一条自动化的方式"><a href="#一条自动化的方式" class="headerlink" title="一条自动化的方式"></a>一条自动化的方式</h2><p>执行 <code>webpack -p</code>(等同于 <code>webpack --optimize--minimize --define process.env.NODE_ENV=&quot;production&quot;</code>).<br>这会执行以下几个步骤：</p><ul><li>使用 <code>UglifyJsPlugin</code> 压缩文件</li><li>执行了 <code>LoaderOptionsPlugin</code>, 查看<a href="https://webpack.js.org/plugins/loader-options-plugin" target="_blank" rel="noopener">文档</a></li><li>设置 Node 的环境变量</li></ul><h3 id="源码压缩"><a href="#源码压缩" class="headerlink" title="源码压缩"></a>源码压缩</h3><p>webpack 使用 <code>UglifyJsPlugin</code> 来压缩源码，通过执行 <a href="http://lisperator.net/uglifyjs/" target="_blank" rel="noopener">UglifyJs</a> 来达到压缩输出代码的目的。这个插件支持所有 UgilfyJs 的功能。在命令行里输入 <code>--optimize-minimize</code> ，那么相当与在配置文件中添加了以下配置：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">/*...*/</span></span><br><span class="line">  plugins:[</span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin(&#123;</span><br><span class="line">      sourceMap: options.devtool &amp;&amp; (options.devtool.indexOf(<span class="string">"sourcemap"</span>) &gt;= <span class="number">0</span> || options.devtool.indexOf(<span class="string">"source-map"</span>) &gt;= <span class="number">0</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样，基于 <a href="https://webpack.js.org/configuration/devtool/" target="_blank" rel="noopener">devtools option</a> ，在打包的时候会生成 Source Map.</p><h3 id="资源映射（Source-Map）"><a href="#资源映射（Source-Map）" class="headerlink" title="资源映射（Source Map）"></a>资源映射（Source Map）</h3><p>我们推荐在开发环境启用 Source Map. 因为在 debug 或者测试的时候很有用。Webpack 可以生成包含在代码包或者分离文件中的 inline Source Map.</p><p>在配置文件中，通过修改 <code>devtools</code> 配置来设置 Source Map 类型。目前我们支持七种不同类型的 Source Map. 可以在<a href="https://webpack.js.org/configuration/devtool" target="_blank" rel="noopener">具体文档</a>中找到更加详细的介绍。</p><p>一个比较好好的选择是使用 <code>cheap-module-source-map</code>，可以将源映射简化为每行映射(simplifies the Source Maps to a single mapping per line)。</p><h3 id="Node-环境变量"><a href="#Node-环境变量" class="headerlink" title="Node 环境变量"></a>Node 环境变量</h3><p>执行 <code>webpack -p</code>( <code>--define process.env.NODE_EMV=&quot;production&quot;</code>) 会通过如下的配置调用 <code>DefinePlugin</code>:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">/*...*/</span></span><br><span class="line">  plugins:[</span><br><span class="line">    <span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">      <span class="string">'process.env.NODE_ENV'</span>: <span class="built_in">JSON</span>.stringify(<span class="string">'production'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>DefindPlugin</code> 会在源码中进行查找和替换的工作。所有找到的 <code>process.env.NODE_ENV</code> 都会被替换为 <code>production</code>.  这样，类似与 <code>if(process.env.NODE_ENV !==&#39;procution&#39;) console.log(…)</code> 这样的代码就会被 <code>UnglifyJs</code> 认为等同于  <code>if(false) console.log(…)</code> .</p><h2 id="一个手动的方式：为-webpack-配置不同环境变量下的配置文件"><a href="#一个手动的方式：为-webpack-配置不同环境变量下的配置文件" class="headerlink" title="一个手动的方式：为 webpack 配置不同环境变量下的配置文件"></a>一个手动的方式：为 webpack 配置不同环境变量下的配置文件</h2><p>一个最简单的方式来为 webpack 配置不同环境变量下的配置文件的方法就是建立多个配置文件。比如：</p><p><strong>dev.js</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 此处官网文档有语法错误，我改了一下</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">env</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    devtool: <span class="string">'cheap-module-source-map'</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">      path: path.join(__dirname, <span class="string">'/../dist/assets'</span>),</span><br><span class="line">      filename: <span class="string">'[name].bundle.js'</span>,</span><br><span class="line">      publicPath: publicPath,</span><br><span class="line">      sourceMapFilename: <span class="string">'[name].map'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    devServer: &#123;</span><br><span class="line">      port: <span class="number">7777</span>,</span><br><span class="line">      host: <span class="string">'localhost'</span>,</span><br><span class="line">      historyApiFallback: <span class="literal">true</span>,</span><br><span class="line">      noInfo: <span class="literal">false</span>,</span><br><span class="line">      stats: <span class="string">'minimal'</span>,</span><br><span class="line">      publicPath: publicPath</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>prod.js</strong><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">env</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    output: &#123;</span><br><span class="line">      path: path.join(__dirname, <span class="string">'/../dist/assets'</span>),</span><br><span class="line">      filename: <span class="string">'[name].bundle.js'</span>,</span><br><span class="line">      publicPath: publicPath,</span><br><span class="line">      sourceMapFilename: <span class="string">'[name].map'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">      <span class="keyword">new</span> webpack.LoaderOptionsPlugin(&#123;</span><br><span class="line">        minimize: <span class="literal">true</span>,</span><br><span class="line">        debug: <span class="literal">false</span></span><br><span class="line">      &#125;),</span><br><span class="line">      <span class="keyword">new</span> UglifyJsPlugin(&#123;</span><br><span class="line">        beautify: <span class="literal">false</span>,</span><br><span class="line">        mangle: &#123;</span><br><span class="line">          screw_ie8: <span class="literal">true</span>,</span><br><span class="line">          keep_fnames: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        compress: &#123;</span><br><span class="line">          screw_ie8: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        comments: <span class="literal">false</span></span><br><span class="line">      &#125;)</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后把我们的 webpack.config.js 的内容改成下面这样：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildConfig</span>(<span class="params">env</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">require</span>(<span class="string">'./config/'</span> + env + <span class="string">'.js'</span>)(&#123; <span class="attr">env</span>: env &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = buildConfig(env);</span><br></pre></td></tr></table></figure><p>最后，在 <code>package.json</code> 中添加如下命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">"build:dev"</span>: <span class="string">"webpack --env=dev --progress --profile --colors"</span>,</span><br><span class="line"> <span class="string">"build:dist"</span>: <span class="string">"webpack --env=prod --progress --profile --colors"</span>,</span><br></pre></td></tr></table></figure><p>可以看到，我们把环境变量传给了 webpack.config.js 文件。从这里我们使用一个简单的方式通过传递环境变量来决定使用正确的配置文件。</p><p>一个更加高级的途径是我们有一个基础配置文件，里面有所有共通的功能，然后在不同环境变量下的不同功能通过指定特定的文件，然后使用 <code>webpack-merge</code> 来合并成一个完整的配置。这样可以避免写很多<br>重复的代码。比如，类似与解析 js,ts,png,jpeg 等都是共通的功能，需要放在基础配置文件里面：</p><p><strong>base.js</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">      <span class="string">'polyfills'</span>: <span class="string">'./src/polyfills.ts'</span>,</span><br><span class="line">      <span class="string">'vendor'</span>: <span class="string">'./src/vendor.ts'</span>,</span><br><span class="line">      <span class="string">'main'</span>: <span class="string">'./src/main.ts'</span></span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">      path: path.join(__dirname, <span class="string">'/../dist/assets'</span>),</span><br><span class="line">      filename: <span class="string">'[name].bundle.js'</span>,</span><br><span class="line">      publicPath: publicPath,</span><br><span class="line">      sourceMapFilename: <span class="string">'[name].map'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    resolve: &#123;</span><br><span class="line">      extensions: [<span class="string">''</span>, <span class="string">'.ts'</span>, <span class="string">'.js'</span>, <span class="string">'.json'</span>],</span><br><span class="line">      modules: [path.join(__dirname, <span class="string">'src'</span>), <span class="string">'node_modules'</span>]</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">      loaders: [&#123;</span><br><span class="line">        test: <span class="regexp">/\.ts$/</span>,</span><br><span class="line">        loaders: [</span><br><span class="line">          <span class="string">'awesome-typescript-loader'</span>,</span><br><span class="line">          <span class="string">'angular2-template-loader'</span></span><br><span class="line">        ],</span><br><span class="line">        exclude: [<span class="regexp">/\.(spec|e2e)\.ts$/</span>]</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        loaders: [<span class="string">'to-string-loader'</span>, <span class="string">'css-loader'</span>]</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        test: <span class="regexp">/\.(jpg|png|gif)$/</span>,</span><br><span class="line">        loader: <span class="string">'file'</span></span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        test: <span class="regexp">/\.(woff|woff2|eot|ttf|svg)$/</span>,</span><br><span class="line">        loader: <span class="string">'url-loader?limit=100000'</span></span><br><span class="line">      &#125;],</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">      <span class="keyword">new</span> ForkCheckerPlugin(),</span><br><span class="line"></span><br><span class="line">      <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">        name: [<span class="string">'polyfills'</span>, <span class="string">'vendor'</span>].reverse()</span><br><span class="line">      &#125;),</span><br><span class="line">      <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">        template: <span class="string">'src/index.html'</span>,</span><br><span class="line">        chunksSortMode: <span class="string">'dependency'</span></span><br><span class="line">      &#125;)</span><br><span class="line">    ],</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后使用 <code>webpack-merge</code> 来合并特定环境变量下指定的配置文件。来看一个合并生产环境下特定配置的例子（和上面 prod.js 对比以下）：</p><p><strong>prod.js(updated)</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> webpackMerge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> commonConfig = <span class="built_in">require</span>(<span class="string">'./base.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">env</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> webpackMerge(commonConfig(), &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">      <span class="keyword">new</span> webpack.LoaderOptionsPlugin(&#123;</span><br><span class="line">        minimize: <span class="literal">true</span>,</span><br><span class="line">        debug: <span class="literal">false</span></span><br><span class="line">      &#125;),</span><br><span class="line">      <span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">        <span class="string">'process.env'</span>: &#123;</span><br><span class="line">          <span class="string">'NODE_ENV'</span>: <span class="built_in">JSON</span>.stringify(<span class="string">'prod'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;),</span><br><span class="line">      <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin(&#123;</span><br><span class="line">        beautify: <span class="literal">false</span>,</span><br><span class="line">        mangle: &#123;</span><br><span class="line">          screw_ie8: <span class="literal">true</span>,</span><br><span class="line">          keep_fnames: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        compress: &#123;</span><br><span class="line">          screw_ie8: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        comments: <span class="literal">false</span></span><br><span class="line">      &#125;)</span><br><span class="line">    ]</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以注意到，在 ‘prod.js’ 中主要有三处更新，分别是：</p><pre><code>• 通过 &apos;webpack-meger&apos; 合并了 `base.js`• 把 `output` 属性移到了 `base.js` 中。我们只要关心在 `base.js` 中以外的不同的配置就可以了• 通过 `DefinePlugin` 把 `process.env.NODE_ENV` 设置为 `prod`. 这样，整个应用代码中的 `process.env.NODE_ENV` 都有一个为 `prod` 的值了。</code></pre><p>哪些需要在不同的环境变量下保持一致都由你来决定。这里只是通过一个 DEMO 来典型的说明一下如何在不同的环境变量下保持部分配置的统一。</p><p>可以看到，<code>webpack-merge</code> 是多么强大，可以让我们避免写很多重复的代码（外国人话真多）。</p><h1 id="React-懒加载（Lazy-Loading-React）"><a href="#React-懒加载（Lazy-Loading-React）" class="headerlink" title="React 懒加载（Lazy Loading - React）"></a>React 懒加载（Lazy Loading - React）</h1><p>通过使用高阶函数可以使一个组件懒加载它的依赖而不需要它的消费者知道，或者使用一个接收函数或者模块的组件，可以使一个消费者可以懒加载它的子组件而不需要它的子组件知道。</p><h2 id="组件懒加载"><a href="#组件懒加载" class="headerlink" title="组件懒加载"></a>组件懒加载</h2><p>先看一个消费者选择去懒加载一些组件。<code>importLazy</code> 是一个返回 <code>defualt</code> 属性的函数，这是为了能和 Babel/ES2015 互通。如果你不需要，可以忽略掉 <code>importLazy</code> 方法。<code>importLazy</code> 只是简单的返回了通过 <code>export default</code> 暴露出的模块。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;LazilyLoad modules=&#123;&#123;</span><br><span class="line">  TodoHandler: <span class="function"><span class="params">()</span> =&gt;</span> importLazy(<span class="keyword">import</span>(<span class="string">'./components/TodoHandler'</span>)),</span><br><span class="line">  TodoMenuHandler: <span class="function"><span class="params">()</span> =&gt;</span> importLazy(<span class="keyword">import</span>(<span class="string">'./components/TodoMenuHandler'</span>)),</span><br><span class="line">  TodoMenu: <span class="function"><span class="params">()</span> =&gt;</span> importLazy(<span class="keyword">import</span>(<span class="string">'./components/TodoMenu'</span>)),</span><br><span class="line">&#125;&#125;&gt;</span><br><span class="line">  &#123;(&#123;TodoHandler, TodoMenuHandler, TodoMenu&#125;) =&gt; (</span><br><span class="line">    &lt;TodoHandler&gt;</span><br><span class="line">      &lt;TodoMenuHandler&gt;</span><br><span class="line">        &lt;TodoMenu /&gt;</span><br><span class="line">      &lt;<span class="regexp">/TodoMenuHandler&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>TodoHandler&gt;</span><br><span class="line">  )&#125;</span><br><span class="line">&lt;<span class="regexp">/LazilyLoad&gt;</span></span><br></pre></td></tr></table></figure><h2 id="高阶组件（Higher-Order-Component）"><a href="#高阶组件（Higher-Order-Component）" class="headerlink" title="高阶组件（Higher Order Component）"></a>高阶组件（Higher Order Component）</h2><p>作为一个组件，你可以确保整个组件本身的依赖是懒加载的。当一个组件依赖一个非常大的库文件的时候会很有用。假设我们要写一个支持代码高亮的 Todo 组件：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Todo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.props.isCode ? <span class="xml"><span class="tag">&lt;<span class="name">Highlight</span>&gt;</span>&#123;content&#125;<span class="tag">&lt;/<span class="name">Highlight</span>&gt;</span></span> : content&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>我们可以确保只有当我们需要代码高亮功能的时候才去加载这个代价高昂的库文件：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Highlight.js</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Highlight</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;Highlight&#125; = <span class="keyword">this</span>.props.highlight;</span><br><span class="line">    <span class="comment">// highlight js is now on our props for use</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> LazilyLoadFactory(Highlight, &#123;</span><br><span class="line">  highlight: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'highlight'</span>),</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注意这个 Highlight 组件的消费者是如何在不知情的情况下被懒加载的。</p><h2 id="完整的代码"><a href="#完整的代码" class="headerlink" title="完整的代码"></a>完整的代码</h2><p>LazilyLoad 组件的源码，暴露了组件接口和高阶组件接口。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LazilyLoad</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>(...arguments);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      isLoaded: <span class="literal">false</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillMount() &#123;</span><br><span class="line">    <span class="keyword">this</span>.load(<span class="keyword">this</span>.props);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">this</span>._isMounted = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillReceiveProps(next) &#123;</span><br><span class="line">    <span class="keyword">if</span> (next.modules === <span class="keyword">this</span>.props.modules) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.load(next);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    <span class="keyword">this</span>._isMounted = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  load(props) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      isLoaded: <span class="literal">false</span>,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> &#123; modules &#125; = props;</span><br><span class="line">    <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(modules);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Promise</span>.all(keys.map(<span class="function">(<span class="params">key</span>) =&gt;</span> modules[key]()))</span><br><span class="line">      .then(<span class="function">(<span class="params">values</span>) =&gt;</span> (keys.reduce(<span class="function">(<span class="params">agg, key, index</span>) =&gt;</span> &#123;</span><br><span class="line">        agg[key] = values[index];</span><br><span class="line">        <span class="keyword">return</span> agg;</span><br><span class="line">      &#125;, &#123;&#125;)))</span><br><span class="line">      .then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>._isMounted) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123; <span class="attr">modules</span>: result, <span class="attr">isLoaded</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.state.isLoaded) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> React.Children.only(<span class="keyword">this</span>.props.children(<span class="keyword">this</span>.state.modules));</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LazilyLoad.propTypes = &#123;</span><br><span class="line">  children: React.PropTypes.func.isRequired,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> LazilyLoadFactory = <span class="function">(<span class="params">Component, modules</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">props</span>) =&gt;</span> (</span><br><span class="line">    &lt;LazilyLoad modules=&#123;modules&#125;&gt;</span><br><span class="line">      &#123;(mods) =&gt; <span class="xml"><span class="tag">&lt;<span class="name">Component</span> &#123;<span class="attr">...mods</span>&#125; &#123;<span class="attr">...props</span>&#125; /&gt;</span>&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">LazilyLoad</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> importLazy = <span class="function">(<span class="params">promise</span>) =&gt;</span> (</span><br><span class="line">  promise.then(<span class="function">(<span class="params">result</span>) =&gt;</span> result.default)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> LazilyLoad;</span><br></pre></td></tr></table></figure><p>提示</p><ul><li>通过使用 bundle loader 可以语义化命名代码块，一次来智能的加载一组代码</li><li>确保你使用了 babel-preset-2015, 并且设置 modules 为 false，这允许 webpack 去处理 modules</li></ul><h1 id="公开路径？（Public-Path）"><a href="#公开路径？（Public-Path）" class="headerlink" title="公开路径？（Public Path）"></a>公开路径？（Public Path）</h1><p>Webpack 提供了一个很长有用的功能，可以设置你应用中所有资源引用的基础路径。它被称之为 <code>publicPath</code>.</p><h2 id="使用场景（Use-case）"><a href="#使用场景（Use-case）" class="headerlink" title="使用场景（Use case）"></a>使用场景（Use case）</h2><p>这里有一些真实应用中的场景，通过这个功能来达到目的。</p><h3 id="在构建的时候设置值"><a href="#在构建的时候设置值" class="headerlink" title="在构建的时候设置值"></a>在构建的时候设置值</h3><p>在开发模式下，我们通常会把 <code>assets/</code> 目录放在和入口页同级的目录下面。这样没有问题，但是假如在生产环境下你的静态资源是存放在 CDN 上那又该怎么办呢？</p><p>可以很方便的通过环境变量来解决这个问题。假设我们有一个变量 <code>ASSET_PATH</code>:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里看起来好像有问题</span></span><br><span class="line"><span class="keyword">import</span> webpack <span class="keyword">from</span> <span class="string">'webpack'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Whatever comes as an environment variable, otherwise use root</span></span><br><span class="line"><span class="keyword">const</span> ASSET_PATH = process.env.ASSET_PATH || <span class="string">'/'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  output: &#123;</span><br><span class="line">    publicPath: ASSET_PATH</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// This makes it possible for us to safely use env vars on our code</span></span><br><span class="line">    <span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">      <span class="string">'process.env.ASSET_PATH'</span>: <span class="built_in">JSON</span>.stringify(ASSET_PATH)</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="在开发中设置值（Set-Value-on-the-fly）"><a href="#在开发中设置值（Set-Value-on-the-fly）" class="headerlink" title="在开发中设置值（Set Value on the fly）"></a>在开发中设置值（Set Value on the fly）</h3><p>另一种方式是在开发过程成设置 public 路径。Webpack 暴露了一个全局变量 <code>__webpack_public_path__</code> 来让我们达到这个目的。所以在你的入口文件中，你可以这样做：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">__webpack_publick_path__ = process.en.ASSET_PATH;</span><br></pre></td></tr></table></figure><p>如何来做都取决于你。当我们通过 <code>DefinePlugin</code> 进行了配置以后， <code>process.env.ASSET_PATH</code> 在任何地方都可以直接拿来使用。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;动态模块替换（Hot-Module-Repalcement-React）&quot;&gt;&lt;a href=&quot;#动态模块替换（Hot-Module-Repalcement-React）&quot; class=&quot;headerlink&quot; title=&quot;动态模块替换（Hot Module Repalcement -React）&quot;&gt;&lt;/a&gt;动态模块替换（Hot Module Repalcement -React）&lt;/h1&gt;&lt;p&gt;就像之前 &lt;a href=&quot;https://webpack.js.org/concepts/hot-module-repalcement&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;理念页面&lt;/a&gt; 中解析的细节那样，动态模块替换（HMR）会在应用运行时动态的替换、添加或者删除模块而不用重新刷新页面。 HMR 非常有用，当应用只有一个状态树（single state tree）时。&lt;/p&gt;
&lt;p&gt;下面介绍的方法描述中使用了 Babel 和 React ,但这并不是使用 HRM 所必须的工具。&lt;/p&gt;
&lt;h2 id=&quot;项目配置&quot;&gt;&lt;a href=&quot;#项目配置&quot; class=&quot;headerlink&quot; title=&quot;项目配置&quot;&gt;&lt;/a&gt;项目配置&lt;/h2&gt;&lt;p&gt;这里会指导你如何用 Babel， React 和 PostCss 一起使用 HMR 去演示一个项目。为了能够跟着下面走下去，需要把这些依赖添加到 &lt;code&gt;package.json&lt;/code&gt; 中去。&lt;/p&gt;
&lt;p&gt;为了使用 HMR，你需要如下这些依赖：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;npm install --save-dev babel@6.5.2 babel-core@6.13.2 babel-loader@6.2.4 babel-preset-es2015@6.13.2 babel-preset-react@6.11.1 babel-preset-stage-2@6.13.0 css-loader@0.23.1 postcss-loader@0.9.1 react-hot-loader@3.0.0-beta.6 style-loader@0.13.1 webpack@2.1.0-beta.25 webpack-dev-server@2.1.0-beta.0&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;同时，为了达到我们演示的目的，还需要：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;npm install --save react@15.3.0 react-dom@15.3.0&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;Babel-Config&quot;&gt;&lt;a href=&quot;#Babel-Config&quot; class=&quot;headerlink&quot; title=&quot;Babel Config&quot;&gt;&lt;/a&gt;Babel Config&lt;/h3&gt;&lt;p&gt;&lt;code&gt;.babelrc&lt;/code&gt; 文件应该如下：&lt;/p&gt;
&lt;figure class=&quot;highlight json&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attr&quot;&gt;&quot;presets&quot;&lt;/span&gt;: [&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;string&quot;&gt;&quot;es2015&quot;&lt;/span&gt;, &amp;#123;&lt;span class=&quot;attr&quot;&gt;&quot;modules&quot;&lt;/span&gt;: &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;&amp;#125;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // webpack understands the native import syntax, and uses it for tree shaking&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;stage-2&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // Specifies what level of language features to activate.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // Stage &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; is &lt;span class=&quot;string&quot;&gt;&quot;draft&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt; is finished, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; is strawman.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // See https://tc39.github.io/process-document/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;react&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // Transpile React components to JavaScript&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attr&quot;&gt;&quot;plugins&quot;&lt;/span&gt;: [&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;react-hot-loader/babel&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // Enables React code to work with HMR.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;Webpack-Config&quot;&gt;&lt;a href=&quot;#Webpack-Config&quot; class=&quot;headerlink&quot; title=&quot;Webpack Config&quot;&gt;&lt;/a&gt;Webpack Config&lt;/h3&gt;
    
    </summary>
    
      <category term="技术" scheme="https://blog.kisnows.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="webpack" scheme="https://blog.kisnows.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>【翻译向】webpack2 指南（上）</title>
    <link href="https://blog.kisnows.com/2017/01/17/webpack2-guide-1/"/>
    <id>https://blog.kisnows.com/2017/01/17/webpack2-guide-1/</id>
    <published>2017-01-17T05:49:35.000Z</published>
    <updated>2017-01-18T12:39:40.638Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前置定义"><a href="#前置定义" class="headerlink" title="前置定义"></a>前置定义</h1><p>Bundle 代码包<br>Chunk 代码块</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>npm install webpack –save-dev</p><h1 id="代码分割"><a href="#代码分割" class="headerlink" title="代码分割"></a>代码分割</h1><p>代码分割是 webpack 中最引人注目的功能之一。它允许你把代码分割成各种可以根据需求载入的代码包，就像一个用户浏览器去匹配路由一样，或者一个用户发出的事件。这允许你小的模块，允许你控制资源的载入优先级，如果使用得当的话，可以大大影响（降低）你应用的加载时间。</p><h2 id="缓存和并行加载的资源分割"><a href="#缓存和并行加载的资源分割" class="headerlink" title="缓存和并行加载的资源分割"></a>缓存和并行加载的资源分割</h2><h3 id="第三方代码分割"><a href="#第三方代码分割" class="headerlink" title="第三方代码分割"></a>第三方代码分割</h3><p>一个典型的应用会依赖很多第三方的框架和库文件。不像应用代码本身，这些第三方代码的变更非常频繁。<br>如果我们保持这些库在它本身的代码包中，从应用代码本身分离出来，那么我们就可以使用浏览器的缓存策略去在一个长时间内把这些代码缓存到最终用户的机器上。</p><p>为了达到这个效果，第三方代码的 verndor 包的 hash 部分必须保持不变，不管应用代码如何变化。学习 <a href="https://webpack.js.org/guids/code-splitting-libraries" target="_blank" rel="noopener">如何通过 <code>CommonsChunkPlugin</code> 来分割 verndor/libray 代码</a>。</p><h3 id="CSS-分割"><a href="#CSS-分割" class="headerlink" title="CSS 分割"></a>CSS 分割</h3><p>你可能也想把样式文件分割成为一个单独的包，从应用逻辑总独立出来。这可以增强样式文件的可缓存性，并且允许浏览器在加载应用代码时并行加载你的样式文件，因此也可以避免 FOUC （一个无样式内容的闪屏）。<br>学习 <a href="https//webpack.js.org/guides/code-splitting-css">如何去分割 CSS</a> 通过使用 <code>ExtractTextWebpackPlugin</code>.</p><h2 id="按需代码分割"><a href="#按需代码分割" class="headerlink" title="按需代码分割"></a>按需代码分割</h2><p>虽然前面的资源分割需要用户在配置文件中预先指定分割点，但是也可以在应用代码中创建动态的分割点。</p><p>这个功能在有很多细微颗粒代码块时会很有用，举个例子，每一个应用的路由或者按照用户的预测行为。这可以使用户按需加载需要的资源。</p><h3 id="通过-require-ensure-来分割代码"><a href="#通过-require-ensure-来分割代码" class="headerlink" title="通过 require.ensure() 来分割代码"></a>通过 <code>require.ensure()</code> 来分割代码</h3><p><code>require.ensure</code> 是一个 CommonJS 风格的方式去异步加载资源。通过添加 <code>require.ensure([&lt;fileurl&gt;])</code> , 我们可以在代码中定义一个分割点。 Webpack 可以创建一个包含在这个分割点中的所有代码的代码包。学习 <a href="https://webpack.js.org/guides/code-splitting-require" target="_blank" rel="noopener">如何分割代码</a> 通过使用 <code>require.ensure()</code>.</p><blockquote><p>TODO System.import()</p></blockquote><a id="more"></a><h1 id="代码分割-CSS"><a href="#代码分割-CSS" class="headerlink" title="代码分割 - CSS"></a>代码分割 - CSS</h1><p>在 webpack 中，当你使用 css-loader 并且在 JavaScript 中引入 CSS 文件，那么 CSS 文件会被打包在你的 JavaScript 文件中。这有一个不好的地方，就是你无法使用浏览器异步并行加载 CSS 的能力。相反，你的页面会等到整个 JavaScript 文件加载完成，才完成了样式文件的加载。Webpack 可以通过使用 extract-text-webpack-plugin 和 css-loader 来把样式文件分离出来去解决这个问题。</p><h2 id="使用-css-loader"><a href="#使用-css-loader" class="headerlink" title="使用 css-loader"></a>使用 <code>css-loader</code></h2><p>引入 css 到你的 JavaScript 中，需要使用 css-loader 去配置 webpack 的配置文件。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js</span></span><br><span class="line"></span><br><span class="line">modules.exports = <span class="function"><span class="keyword">function</span>(<span class="params">env</span>)</span>&#123;</span><br><span class="line">    entry: <span class="string">'..'</span>,</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [&#123;</span><br><span class="line">            test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">            exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">            loader: <span class="string">'css-loader'</span></span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用-extract-text-webpack-plugin-ExtractTextPlugin"><a href="#使用-extract-text-webpack-plugin-ExtractTextPlugin" class="headerlink" title="使用 extract-text-webpack-plugin - ExtractTextPlugin"></a>使用 <code>extract-text-webpack-plugin</code> - ExtractTextPlugin</h2><p>安装：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm I --save-dev extract-text-webpack-plugin</span><br></pre></td></tr></table></figure><p>要使用这个 <code>ExtractTextPlugin</code>,需要通过两个步骤配置在 <code>webpack.config.js</code> 中。</p><h3 id="在-lodaer-里面"><a href="#在-lodaer-里面" class="headerlink" title="在 lodaer 里面"></a>在 lodaer 里面</h3><p>从之前的 <code>css-loader</code> 中适配，我们应该如下添加 <code>ExtractTextPlugin</code>.</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">loader: ExtractTextPlugin.extract(<span class="string">'css-loader?sourceMap'</span>) //Can be used without sourcemaps too.</span><br></pre></td></tr></table></figure><h3 id="在-plugin-里面"><a href="#在-plugin-里面" class="headerlink" title="在 plugin 里面"></a>在 plugin 里面</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">new ExtractTextPlugin(&#123; filename: <span class="string">'bundle.css'</span>, <span class="built_in">disable</span>: <span class="literal">false</span>, allChunks: <span class="literal">true</span> &#125;)</span><br></pre></td></tr></table></figure><p>通过这两步，就可以生成一个新的包含所有 CSS 模块的代码包，然后把他们添加到 <code>index.html</code> 的 <code>heade</code> 中去。可以通过 <a href="https://github.com/webpack/extract-text-webpack-plugin#api" target="_blank" rel="noopener">ExtractTextPlugin</a> 去了解关于它 api 的更多信息。</p><p>完整的配置文件如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ExtractTextPlugin = <span class="built_in">require</span>(<span class="string">'extract-text-webpack-plugin'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        entry: <span class="string">'./main.js'</span>,</span><br><span class="line">        output: &#123;</span><br><span class="line">            path: <span class="string">'./dist'</span>,</span><br><span class="line">            filename: <span class="string">'bundle.js'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="built_in">module</span>: &#123;</span><br><span class="line">            rules: [&#123;</span><br><span class="line">                test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">                exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">                loader: ExtractTextPlugin.extract(&#123;</span><br><span class="line">                    loader: <span class="string">'css-loader?sourceMap'</span></span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;]</span><br><span class="line">        &#125;,</span><br><span class="line">        devtool: <span class="string">'source-map'</span>,</span><br><span class="line">        plugins: [</span><br><span class="line">            <span class="keyword">new</span> ExtractTextPlugin(&#123; <span class="attr">filename</span>: <span class="string">'bundle.css'</span>, <span class="attr">disable</span>: <span class="literal">false</span>, <span class="attr">allChunks</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="代码分割-库文件"><a href="#代码分割-库文件" class="headerlink" title="代码分割-库文件"></a>代码分割-库文件</h1><p>一个典型的应用会依赖很多第三方来提供框架或功能支持。项目中使用的固定版本的库/框架文件的代码一般不会有变动，然而应用本身的业务逻辑代码却经常会有变动。</p><p>把应用代码和库文件的代码打包在一起是一件非常低效的事情。这是因为浏览器可以根据缓存头缓存这些资源文件到本地而不用每次都去服务端或者 cdn 上去发请求重新获取，如果文件内容没有变动的话。为了能够享受这个好处，我们需要保持第三方文件的 hash 不变，无论应用本身的代码如何变化。</p><p>我们只有把应用代码和第三方代码分离开才可以达到这样的效果。</p><p>我们考虑一个一个简单的应用，它使用了 momentjs ，一个通常用来时间格式化的库。</p><p>安装 <code>moment</code> ：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save moment</span><br></pre></td></tr></table></figure><p>Index 文件会引用 <code>moment</code> 作为一个依赖并且打印当前的时间：</p><p><strong>Index.js</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> moment = <span class="built_in">require</span>(<span class="string">'moment'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(moment().format());</span><br></pre></td></tr></table></figure><p>我们可以通过如下这个配置文件来打包这个应用</p><p><strong>Webapck.config.js</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">env</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    entry: <span class="string">'./index.js'</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">      filename: <span class="string">'[chunkhash].[name].js'</span>,</span><br><span class="line">      path: <span class="string">'./dist'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当运行 <code>webapck</code> 命令的时候，如果你检查打包后的文件，你会发现 <code>moment</code> 和 <code>index.js</code> 都被打包在了 <code>bundle.js</code> 中。</p><p>这不是一个很好的解决方案。如果 <code>index.js</code> 修改了，那么这打包文件会重新构建，浏览器就需要重新去加载这个文件，即使 moment.js 文件并没有任何改动。</p><h2 id="多个入口"><a href="#多个入口" class="headerlink" title="多个入口"></a>多个入口</h2><p>让我们缓和这个问题，我们给 moment 添加一个新的入口命名为 vendors.</p><p><strong>Webpack.config.js</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">env</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">      main: <span class="string">'./index.js'</span>,</span><br><span class="line">      vendor: <span class="string">'moment'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">      filename: <span class="string">'[chunkhash].[name].js'</span>,</span><br><span class="line">      path: <span class="string">'./dist'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在执行 webpack 命令，我们会看到两个打包后的文件。如果你检查里面代码的话，你会看到 <code>moment</code> 的代码同时出现在两个代码包中。</p><p>为了解决这个问题，我们需要使用 <a href="https://webpack.js.org/plugins/commons-chunk-plugin" target="_blank" rel="noopener">CommonsChunkPlugin</a>.</p><h2 id="CommonsChunksPlugin"><a href="#CommonsChunksPlugin" class="headerlink" title="CommonsChunksPlugin"></a><code>CommonsChunksPlugin</code></h2><p>这是一个相当复杂的插件。它从根本上允许你从不同的代码包中提取出所有的相同模块并且把它们加入到共同的代码包中。如果这个相同的代码包不存在，那么就创建一个新的。</p><p>我们可以修改 webpack 的配置文件来使用这个 <code>CommonsCunksPlugin</code></p><p><strong>Webpack.config.js</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">env</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">      main: <span class="string">'./index.js'</span>,</span><br><span class="line">      vendor: <span class="string">'moment'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">      filename: <span class="string">'[chunkhash].[name].js'</span>,</span><br><span class="line">      path: <span class="string">'./dist'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">      <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">        name: <span class="string">'vendor'</span> <span class="comment">// Specify the common bundle's name.</span></span><br><span class="line">      &#125;)</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的话， <code>moment</code> 的代码就只会出现在 vendor 代码包中了。</p><h2 id="清单文件（Manifest-File）"><a href="#清单文件（Manifest-File）" class="headerlink" title="清单文件（Manifest File）"></a>清单文件（Manifest File）</h2><p>但是，如果我们可以修改应用的代码并且再次执行 <code>webpack</code> 命令，我们看到 vendors 文件的 hash 还是变化了。即使我们已经分离了 <code>vendor</code> 和 <code>main</code> 代码包，但是当应用代码发生修改的时候 <code>vendor</code> 还是变化了。 这意味着我们依旧不能享受浏览器缓存带来的好处，因为每一次重新编译都会修改 vendors 的 hash 值。</p><p>这个问题是因为每一次编译，webpack 生成一些 webpack 运行时代码，用来帮助 webpack 来做它的工作。当那里存在一个单独的代码包，运行时会驻留在其中。但当多个代码包被生成的时候，运行时代码会被提取到公共的模块中，就是这个 <code>vendor</code> 文件。</p><p>为了阻止这个，我们需要提取出运行时到一个分离的清单文件（Manifest File）。虽然我们又多创建另一个代码包，但它的开销也被我们在 vendor 文件上获得的长期缓存所带来的好处所抵消了。</p><p><strong>Webpack.config.js</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">env</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">      main: <span class="string">'./index.js'</span>,</span><br><span class="line">      vendor: <span class="string">'moment'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">      filename: <span class="string">'[chunkhash].[name].js'</span>,</span><br><span class="line">      path: <span class="string">'./dist'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">      <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">        names: [<span class="string">'vendor'</span>, <span class="string">'manifest'</span>] <span class="comment">// Specify the common bundle's name.</span></span><br><span class="line">      &#125;)</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过上面这个配置文件，我们会看到三个代码包被生成。<code>vendor</code>,<code>main</code> 和 <code>manifest</code>. 这样当应用代码修改的时候，重新打包后，修改的就只有 <code>main</code> 和 <code>manifest</code> 了。 <code>manifest</code> 被修改是因为里面有对生成文件 hash 值的引用。</p><h1 id="代码分割-使用-RequireJS"><a href="#代码分割-使用-RequireJS" class="headerlink" title="代码分割-使用 RequireJS"></a>代码分割-使用 RequireJS</h1><p>在这个章节，我们讨论 webpack 如何通过 <code>require.ensure()</code> 分割代码。</p><h2 id="require-ensure"><a href="#require-ensure" class="headerlink" title="require.ensure()"></a><code>require.ensure()</code></h2><p>Webpack 静态分析给 <code>require.ensure()</code> 在代码中当构建和添加模块到分离的代码块中。这个新的代码块会被 webpack 在需要的时候通过 jsonp 引入。</p><p>它的语法如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>.ensure(dependencies: <span class="built_in">String</span>[], <span class="attr">callback</span>: <span class="function"><span class="keyword">function</span>(<span class="params">require</span>), <span class="title">chunkName</span>: <span class="title">String</span>)</span></span><br></pre></td></tr></table></figure><h3 id="依赖-dependencies"><a href="#依赖-dependencies" class="headerlink" title="依赖(dependencies)"></a>依赖(dependencies)</h3><p>这是一个字符串数组，用来声明所有需要在执行回掉函数之前就需要预先加载好且可用的模块。</p><h3 id="回调函数-callback"><a href="#回调函数-callback" class="headerlink" title="回调函数(callback)"></a>回调函数(callback)</h3><p>一个回调函数会被 webpack 执行一次当所有依赖(dependencies)都被加载以后。Require 对象的实现作为一个参数传递给这个回调函数。这样，我们可以更进一步 <code>require</code> 需要的依赖(dependencies)和其他需要执行的模块。</p><h3 id="代码块名字-chunkName"><a href="#代码块名字-chunkName" class="headerlink" title="代码块名字(chunkName)"></a>代码块名字(chunkName)</h3><p>代码块名字是一个用来命名通过 <code>require.ensrue()</code> 创建的代码块。通过给不同的 <code>require.ensure()</code> 创建的代码分割点分割出来的代码块一个相同的名字，我们可以确保所有的依赖都被打包到同一个代码块中。</p><p>我们来看一下如下结构的一个项目</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\\ file structure</span><br><span class="line">    |</span><br><span class="line">    js --|</span><br><span class="line">    |    |-- entry.js</span><br><span class="line">    |    |-- a.js</span><br><span class="line">    |    |-- b.js</span><br><span class="line">    webpack.config.js</span><br><span class="line">    |</span><br><span class="line">    dist</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// entry.js</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'a'</span>);</span><br><span class="line"><span class="built_in">require</span>.ensure([], <span class="function"><span class="keyword">function</span>(<span class="params">require</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">require</span>(<span class="string">'b'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'***** I AM a *****'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'***** I AM b *****'</span>);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">env</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    entry: <span class="string">'./js/entry.js'</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">      filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">      path: <span class="string">'./dist'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当运行 webpack 命令的时候，我们发现 webpack 创建了两个新的代码包，<code>bundle.js</code> 和 <code>0.bundle.js</code>.</p><p><code>entry.js</code> 和 <code>a.js</code> 被打包到了 <code>bundle.js</code> 中。</p><p><code>b.js</code> 被打包到了 <code>0.bundle.js</code></p><h2 id="require-ensure-的陷阱"><a href="#require-ensure-的陷阱" class="headerlink" title="require.ensure() 的陷阱"></a><code>require.ensure()</code> 的陷阱</h2><h3 id="空数组作为一个参数"><a href="#空数组作为一个参数" class="headerlink" title="空数组作为一个参数"></a>空数组作为一个参数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>.ensure([], <span class="function"><span class="keyword">function</span>(<span class="params">require</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">require</span>(<span class="string">'./a.js'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面的代码确保一个分割点被创建， <code>a.js</code> 会被 webpack 单独的打包成一个文件。</p><h3 id="依赖作为参数"><a href="#依赖作为参数" class="headerlink" title="依赖作为参数"></a>依赖作为参数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>.ensure([<span class="string">'./a.js'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">require</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">require</span>(<span class="string">'./b.js'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面的代码，<code>a.js</code> 和 <code>b.js</code>  会被一起打包并且从主代码包中分离出来。但是只有 <code>b.js</code> 的内容被执行了。 <code>a.js</code> 的内容只是是可用的但并没有被执行。为了执行 <code>a.js</code>, 我们需要 require 它作为一个同步的方式比如 <code>require(&#39;./a.js)</code> ，这样 JavaScript 就可以执行它了。 </p><h1 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h1><pre><code>Ø es6 moduleØ CommonjsØ Amd</code></pre><h2 id="表达式依赖（require-with-expression）"><a href="#表达式依赖（require-with-expression）" class="headerlink" title="表达式依赖（require with expression）"></a>表达式依赖（require with expression）</h2><p>当你通过表达式去引入一个模块的时候，就会创建一个上下文，所以当编译的时候我们并不知道准确的模块是哪个。</p><p>例：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">"./template/"</span> + name + <span class="string">".ejs"</span>);</span><br></pre></td></tr></table></figure><p>Webpack 解析 <code>require()</code> 的调用，并且提取出来一些信息：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Directory:./template</span><br><span class="line">Regularexpression:/^.*\.ejs$/</span><br></pre></td></tr></table></figure><h3 id="上下文模块（context-module）"><a href="#上下文模块（context-module）" class="headerlink" title="上下文模块（context module）"></a>上下文模块（context module）</h3><p>一个上下文模块被生成。它包含了在这个文件夹下所有可以被上面的正则匹配所匹配到的模块的引用。上下文模块包含了一个把请求解释到模块 id 的 map.<br>例：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"./table.ejs"</span>: <span class="number">42</span>,</span><br><span class="line">  <span class="attr">"./table-row.ejs"</span>: <span class="number">43</span>,</span><br><span class="line">  <span class="attr">"./directory/folder.ejs"</span>: <span class="number">44</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上下文模块同样包含了一些运行时代码用来访问这个 map.</p><p>这意味着动态的引用可以被支持，但是会导致所有可能被用到的模块都被打包到了最终的代码包中。</p><h3 id="require-context"><a href="#require-context" class="headerlink" title="require.context"></a><code>require.context</code></h3><p>你可以通过 <code>require.context()</code> 方法创建你自己的上下文。它允许你传入一个用来查询的文件夹，一个用来决定是否递归查找子文件夹的标识，还有一个用来匹配文件的正则表达式。</p><p>Webpack 会在代码打包的时候解析 <code>require.context()</code></p><p>它的语法如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>.context(directory, useSubdirectories = <span class="literal">false</span>, regExp = <span class="regexp">/^\.\//</span>)</span><br></pre></td></tr></table></figure><p>例：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>.context(<span class="string">"./test"</span>, <span class="literal">false</span>, /\.test\.js$/);</span><br><span class="line"><span class="comment">// a context with files from the test directory that can be required with a request endings with `.test.js`.</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>.context(<span class="string">"../"</span>, <span class="literal">true</span>, /\.stories\.js$/);</span><br><span class="line"><span class="comment">// a context with all files in the parent folder and descending folders ending with `.stories.js`.</span></span><br></pre></td></tr></table></figure><h2 id="上下文模块API（context-module-API）"><a href="#上下文模块API（context-module-API）" class="headerlink" title="上下文模块API（context module API）"></a>上下文模块API（context module API）</h2><p>一个上下文模块暴露一个方法，它接收一个参数：请求的内容。<br>暴露出来的函数有三个属性：<code>resolve</code>,<code>key</code>,<code>id</code><br>    • <code>resolve</code> 是一个函数，执行后返回解析后的请求内容的模块 id<br>    • <code>keys</code>是一个函数，执行后返回一个数组，包含所有可能被上下文模块所请求的所有的模块的 id<br>    当你想要通过正则匹配引入一个文件夹下所有模块时，这会非常有用：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">importAll</span> (<span class="params">r</span>) </span>&#123;</span><br><span class="line">  r.keys().forEach(r);</span><br><span class="line">&#125;</span><br><span class="line">importAll(<span class="built_in">require</span>.context(<span class="string">'../components/'</span>, <span class="literal">true</span>, /\.js$/))</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cache = &#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">importAll</span> (<span class="params">r</span>) </span>&#123;</span><br><span class="line">  r.keys().forEach(<span class="function"><span class="params">key</span> =&gt;</span> cache[key] = r(key));</span><br><span class="line">&#125;</span><br><span class="line">importAll(<span class="built_in">require</span>.context(<span class="string">'../components/'</span>, <span class="literal">true</span>, /\.js$/));</span><br><span class="line"><span class="comment">// At build-time cache will be polulated with all required modules.</span></span><br></pre></td></tr></table></figure><pre><code>• `id` 是上下文模块生成的模块 id. 当使用 `module.hot.accept` 时，这会非常有用。</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前置定义&quot;&gt;&lt;a href=&quot;#前置定义&quot; class=&quot;headerlink&quot; title=&quot;前置定义&quot;&gt;&lt;/a&gt;前置定义&lt;/h1&gt;&lt;p&gt;Bundle 代码包&lt;br&gt;Chunk 代码块&lt;/p&gt;
&lt;h1 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h1&gt;&lt;p&gt;npm install webpack –save-dev&lt;/p&gt;
&lt;h1 id=&quot;代码分割&quot;&gt;&lt;a href=&quot;#代码分割&quot; class=&quot;headerlink&quot; title=&quot;代码分割&quot;&gt;&lt;/a&gt;代码分割&lt;/h1&gt;&lt;p&gt;代码分割是 webpack 中最引人注目的功能之一。它允许你把代码分割成各种可以根据需求载入的代码包，就像一个用户浏览器去匹配路由一样，或者一个用户发出的事件。这允许你小的模块，允许你控制资源的载入优先级，如果使用得当的话，可以大大影响（降低）你应用的加载时间。&lt;/p&gt;
&lt;h2 id=&quot;缓存和并行加载的资源分割&quot;&gt;&lt;a href=&quot;#缓存和并行加载的资源分割&quot; class=&quot;headerlink&quot; title=&quot;缓存和并行加载的资源分割&quot;&gt;&lt;/a&gt;缓存和并行加载的资源分割&lt;/h2&gt;&lt;h3 id=&quot;第三方代码分割&quot;&gt;&lt;a href=&quot;#第三方代码分割&quot; class=&quot;headerlink&quot; title=&quot;第三方代码分割&quot;&gt;&lt;/a&gt;第三方代码分割&lt;/h3&gt;&lt;p&gt;一个典型的应用会依赖很多第三方的框架和库文件。不像应用代码本身，这些第三方代码的变更非常频繁。&lt;br&gt;如果我们保持这些库在它本身的代码包中，从应用代码本身分离出来，那么我们就可以使用浏览器的缓存策略去在一个长时间内把这些代码缓存到最终用户的机器上。&lt;/p&gt;
&lt;p&gt;为了达到这个效果，第三方代码的 verndor 包的 hash 部分必须保持不变，不管应用代码如何变化。学习 &lt;a href=&quot;https://webpack.js.org/guids/code-splitting-libraries&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;如何通过 &lt;code&gt;CommonsChunkPlugin&lt;/code&gt; 来分割 verndor/libray 代码&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;CSS-分割&quot;&gt;&lt;a href=&quot;#CSS-分割&quot; class=&quot;headerlink&quot; title=&quot;CSS 分割&quot;&gt;&lt;/a&gt;CSS 分割&lt;/h3&gt;&lt;p&gt;你可能也想把样式文件分割成为一个单独的包，从应用逻辑总独立出来。这可以增强样式文件的可缓存性，并且允许浏览器在加载应用代码时并行加载你的样式文件，因此也可以避免 FOUC （一个无样式内容的闪屏）。&lt;br&gt;学习 &lt;a href=&quot;https//webpack.js.org/guides/code-splitting-css&quot;&gt;如何去分割 CSS&lt;/a&gt; 通过使用 &lt;code&gt;ExtractTextWebpackPlugin&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&quot;按需代码分割&quot;&gt;&lt;a href=&quot;#按需代码分割&quot; class=&quot;headerlink&quot; title=&quot;按需代码分割&quot;&gt;&lt;/a&gt;按需代码分割&lt;/h2&gt;&lt;p&gt;虽然前面的资源分割需要用户在配置文件中预先指定分割点，但是也可以在应用代码中创建动态的分割点。&lt;/p&gt;
&lt;p&gt;这个功能在有很多细微颗粒代码块时会很有用，举个例子，每一个应用的路由或者按照用户的预测行为。这可以使用户按需加载需要的资源。&lt;/p&gt;
&lt;h3 id=&quot;通过-require-ensure-来分割代码&quot;&gt;&lt;a href=&quot;#通过-require-ensure-来分割代码&quot; class=&quot;headerlink&quot; title=&quot;通过 require.ensure() 来分割代码&quot;&gt;&lt;/a&gt;通过 &lt;code&gt;require.ensure()&lt;/code&gt; 来分割代码&lt;/h3&gt;&lt;p&gt;&lt;code&gt;require.ensure&lt;/code&gt; 是一个 CommonJS 风格的方式去异步加载资源。通过添加 &lt;code&gt;require.ensure([&amp;lt;fileurl&amp;gt;])&lt;/code&gt; , 我们可以在代码中定义一个分割点。 Webpack 可以创建一个包含在这个分割点中的所有代码的代码包。学习 &lt;a href=&quot;https://webpack.js.org/guides/code-splitting-require&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;如何分割代码&lt;/a&gt; 通过使用 &lt;code&gt;require.ensure()&lt;/code&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;TODO System.import()&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="技术" scheme="https://blog.kisnows.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="webpack" scheme="https://blog.kisnows.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>2016年终总结</title>
    <link href="https://blog.kisnows.com/2016/12/09/2016-year-end-summary/"/>
    <id>https://blog.kisnows.com/2016/12/09/2016-year-end-summary/</id>
    <published>2016-12-09T14:03:10.000Z</published>
    <updated>2018-06-09T07:56:32.426Z</updated>
    
    <content type="html"><![CDATA[<h1 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h1><p>时间也真是快，从 15 年到现在算来我做前端开发也将近两年了，没想到这一路走过来这么顺利，运气真是挺好的。</p><p>当初自学三个月，然后投简历面试，就拿到了好几个 offer，一切都太顺利了。然后去了一家做互联网金融的公司，老大对我很好，然而待了一年多还是在今年五月份选择了离职。原因很简单，公司的开发模式过于保守，一直待下去真的不会有任何长进了， 整天干的活都像是美工干的活，公司很不重视前端，而且前后端不分离，同一份文件前后端两个人一起改，想想真是痛苦。</p><p>那离职了就要找工作，不得不说，找工作的经历真有意思。</p><h2 id="找工作"><a href="#找工作" class="headerlink" title="找工作"></a>找工作</h2><p>有一家创业公司，人家对我还比较满意，但就是薪资没谈妥，就算了，谁知道后来我都拿到另一家公司的 offer 了又说那个薪资可以接受了。</p><p>有一家外企，面试的时候对他们的工作环境非常满意，然而面试发挥太差，连 sass 的循环都写不出来，结果可想而知。面试官还很和蔼，说回去等消息吧，然后我出门不到五分钟就收到了短信，‘您不适合本公司的要求’，嗯，效率真高，挺喜欢这点。</p><p>有一家在滨江的大公司，面试通过了，薪资都谈妥了， Hr 说回去等 offer 吧，一般三天内就会发出来。我很高兴，第二天回原公司就提了离职。结果等了一星期还没收到 offer ，就打电话问，对方很不好意思的回答说，部门公司架构重组，我面试的那个事业部已经没了,,Ծ ㅂ Ծ,,，我也不好说什么了。</p><p>中途还有一堆不靠谱的公司，当然也有我能力不足没通过面试的。</p><p>有一个最直接就是蘑菇街的人问你能接受加班吗，我说偶尔可以，经常不行，然后人家来了一句，那不行，我们这边加班还是很严重的，几乎每天 11 点。然后，就没有然后了。后来小伙伴给内推了阿里，面天猫挂在了三面，又面了滨江的 B2B 部门。</p><p>到二面的时候，接到了网易的面试，面网易的时候谈的很高兴，双方都很满意，最后 hr 问说有没有在面其他公司，我说当然， 比如阿里也在面，现在已经到了二面。然后就有了下面的对话：</p><pre><code>Hr ：“那如果阿里和网易同时给你发 offer 你去哪个？“我当时随口一说，“哪个先发 offer 就去哪个”</code></pre><p>然后当天晚上就电话通知我面试通过了，第二天就发了 offer。现在想想，我真是机智啊，O(∩_∩)O</p><h2 id="网易"><a href="#网易" class="headerlink" title="网易"></a>网易</h2><p>找工作的事情就告一段落，来到网易。首先网易给我的第一印象就是，食堂真好（虽然已经吃腻了），仿佛回到了大学时候一样，然后妹子真多，嗯，真的。</p><p>不得不说大公司跟小公司还是有很多差别的。首先，流程上就很规范，不会出现说之前公司那种产品经理过来一会要这样一会要那样的事情，但同时也有弊端，就是会议太多。想想那些会议有没有必要开，还是有必要的，但是会议的整体效率，真是低啊。</p><a id="more"></a><p>一开始去网易除了业务上的需求，还自发奋勇接了几个前端技术部的非业务工作，可能这一点让老大觉得我积极性比较强，就又比较看好我。中途本来还要做个前端监控系统的，可惜刚搞好前期工作，负责人就离职了，项目也就搁置了。想想也是挺可惜的。</p><p>都说进了网易会长胖，然而短短半年时间，我竟瘦了七八斤。不得不说，工作还是挺忙的，每天都得八九点多才能下班。想想以前六点下班，下班后看两小时书，打俩小时游戏，然后躺床睡觉，劳逸结合，简直完美。现在一下班就跟死猪一样了，什么都不想干，游戏都懒得打，就刷刷微博、A、B 站然后就睡了。看书很少了，偶尔也看看一些前端相关的博客和文章。所以感觉这半年，除了工作经验上的积累，个人知识拓展上几乎是停滞的，长期这样下去肯定是不行的。</p><p>而且我们那条业务线负责人离职后，老大让我顶大梁。虽然这对我来说是个锻炼，但确实亚历山大，每天除了业务需求，还有一堆杂七杂八的事情要处理，搞得焦头烂额。</p><p>不过，还好。公司的同事都挺有意思的，上班整体也挺开心，这到挺好的。</p><h1 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h1><p>翻了一下去年的日记，哦，不对，应该叫月记。看来日常生活上还是那个样子，跟去年没什么大的区别。</p><h2 id="找房子"><a href="#找房子" class="headerlink" title="找房子"></a>找房子</h2><p>一开年就又是找房子，原来的房东直接涨价 500 块，真心不能接受。就只能开始又一次找房子的旅程了，跑了很多小区，最后在原来房子附近的小区找到一个还行的，不过价格也真是高。这种每年都要找房子的感觉真是不爽。</p><p>找到的房子是个三室一厅的，就拉了个前同事入伙，开始三人合租的日子。</p><p>新室友养了只猫，挺可爱的， 就是那猫实在掉毛掉的厉害，猫主人又很少打扫，这里让人不太愉快。不过还好，大家关系都不错，周末一起看个电影吃个饭，偶尔也去西湖、九溪等地方逛逛，挺好的。</p><h2 id="方向"><a href="#方向" class="headerlink" title="方向"></a>方向</h2><p>到现在都还是有点迷茫，还是不知道自己到底是个怎样的人，想要成为什么样的人。有点找不到方向的感觉 。</p><p>年初和同学聊天，聊到想在哪里发展。他说不太想待杭州，又不想回去，比较想去上海。然而年中就结婚并定居杭州了。我呢，是想回去又不想回去，跟所有出来工作的人一样，纠结。</p><p>总想活的潇洒一点，可又给自己画了很多条条框框，画地为牢，把自己困在原地。</p><p>果然，一个人想要改变自己还是挺难的。</p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>先看看去年给自己定的目标吧：</p><blockquote><p>在此给明年订个简单的规定：</p></blockquote><ol><li>每个月至少写一篇博客</li><li>至少每两周看一次电影</li><li>每两个月看一本书</li><li>加强身体锻炼</li><li>该追的美剧不能落下</li></ol><p>除了 2，5 其他的一个都没完成，果然这执行力还是不行啊。</p><ul><li>博客自从进了网易就没有更新过；</li><li>书，一年下来就看了四本，好多书买回来，连封皮都没撕；</li><li>锻炼身体，买了瑜伽毯，买了新的咏具，但锻炼总是断断续续的，一直没能坚持下来；</li></ul><p>所以今年的计划就简单一点吧：</p><ol><li>每个月至少一篇博客</li><li>每个月都要出去走走，哪怕一个人</li><li>书还是要看的，那就三个月一本书吧</li><li>身体还是要锻炼的，心里有这个事情就行</li><li>写一个个人项目，并发布出来，无论项目多水</li></ol><h2 id="感情"><a href="#感情" class="headerlink" title="感情"></a>感情</h2><div style="opacity:0">→←</div><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>整体的感觉，就是这一年过的真快呀！转眼毕业都两年多了，有时都觉得挺可怕的，必须得再次告诫自己：<br><strong><em>Seize the day.</em></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;工作&quot;&gt;&lt;a href=&quot;#工作&quot; class=&quot;headerlink&quot; title=&quot;工作&quot;&gt;&lt;/a&gt;工作&lt;/h1&gt;&lt;p&gt;时间也真是快，从 15 年到现在算来我做前端开发也将近两年了，没想到这一路走过来这么顺利，运气真是挺好的。&lt;/p&gt;
&lt;p&gt;当初自学三个月，然后投简历面试，就拿到了好几个 offer，一切都太顺利了。然后去了一家做互联网金融的公司，老大对我很好，然而待了一年多还是在今年五月份选择了离职。原因很简单，公司的开发模式过于保守，一直待下去真的不会有任何长进了， 整天干的活都像是美工干的活，公司很不重视前端，而且前后端不分离，同一份文件前后端两个人一起改，想想真是痛苦。&lt;/p&gt;
&lt;p&gt;那离职了就要找工作，不得不说，找工作的经历真有意思。&lt;/p&gt;
&lt;h2 id=&quot;找工作&quot;&gt;&lt;a href=&quot;#找工作&quot; class=&quot;headerlink&quot; title=&quot;找工作&quot;&gt;&lt;/a&gt;找工作&lt;/h2&gt;&lt;p&gt;有一家创业公司，人家对我还比较满意，但就是薪资没谈妥，就算了，谁知道后来我都拿到另一家公司的 offer 了又说那个薪资可以接受了。&lt;/p&gt;
&lt;p&gt;有一家外企，面试的时候对他们的工作环境非常满意，然而面试发挥太差，连 sass 的循环都写不出来，结果可想而知。面试官还很和蔼，说回去等消息吧，然后我出门不到五分钟就收到了短信，‘您不适合本公司的要求’，嗯，效率真高，挺喜欢这点。&lt;/p&gt;
&lt;p&gt;有一家在滨江的大公司，面试通过了，薪资都谈妥了， Hr 说回去等 offer 吧，一般三天内就会发出来。我很高兴，第二天回原公司就提了离职。结果等了一星期还没收到 offer ，就打电话问，对方很不好意思的回答说，部门公司架构重组，我面试的那个事业部已经没了,,Ծ ㅂ Ծ,,，我也不好说什么了。&lt;/p&gt;
&lt;p&gt;中途还有一堆不靠谱的公司，当然也有我能力不足没通过面试的。&lt;/p&gt;
&lt;p&gt;有一个最直接就是蘑菇街的人问你能接受加班吗，我说偶尔可以，经常不行，然后人家来了一句，那不行，我们这边加班还是很严重的，几乎每天 11 点。然后，就没有然后了。后来小伙伴给内推了阿里，面天猫挂在了三面，又面了滨江的 B2B 部门。&lt;/p&gt;
&lt;p&gt;到二面的时候，接到了网易的面试，面网易的时候谈的很高兴，双方都很满意，最后 hr 问说有没有在面其他公司，我说当然， 比如阿里也在面，现在已经到了二面。然后就有了下面的对话：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Hr ：“那如果阿里和网易同时给你发 offer 你去哪个？“
我当时随口一说，“哪个先发 offer 就去哪个”
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后当天晚上就电话通知我面试通过了，第二天就发了 offer。现在想想，我真是机智啊，O(∩_∩)O&lt;/p&gt;
&lt;h2 id=&quot;网易&quot;&gt;&lt;a href=&quot;#网易&quot; class=&quot;headerlink&quot; title=&quot;网易&quot;&gt;&lt;/a&gt;网易&lt;/h2&gt;&lt;p&gt;找工作的事情就告一段落，来到网易。首先网易给我的第一印象就是，食堂真好（虽然已经吃腻了），仿佛回到了大学时候一样，然后妹子真多，嗯，真的。&lt;/p&gt;
&lt;p&gt;不得不说大公司跟小公司还是有很多差别的。首先，流程上就很规范，不会出现说之前公司那种产品经理过来一会要这样一会要那样的事情，但同时也有弊端，就是会议太多。想想那些会议有没有必要开，还是有必要的，但是会议的整体效率，真是低啊。&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="https://blog.kisnows.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="年终总结" scheme="https://blog.kisnows.com/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
</feed>
